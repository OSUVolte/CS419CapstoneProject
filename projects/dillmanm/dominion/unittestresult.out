File 'dominion.c'
Lines executed:25.11% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
      176:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      176:   11:  if (*(int*)a < *(int*)b)
       62:   12:    return -1;
      114:   13:  return 0;
      176:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
       12:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      132:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
     1320:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
     1140:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
      600:   65:        }
       60:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        6:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        6:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
     1980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      114:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
       12:  116:		    state->supplyCount[i] = 8; 
       12:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
       12:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
      870:  130:	}
        -:  131:
      120:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       36:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       96:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
       36:  145:	}
      192:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
       84:  150:	}
       12:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       36:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
       12:  160:    }
        -:  161:
        -:  162:  //draw player hands
       36:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
       12:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      336:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
      162:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       72:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
       30:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        6:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       14:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       14:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       14:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      288:  214:  while (state->deckCount[player] > 0) {
      130:  215:    card = floor(Random() * state->deckCount[player]);
      130:  216:    newDeck[newDeckPos] = state->deck[player][card];
      130:  217:    newDeckPos++;
      796:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
      268:  219:      state->deck[player][i] = state->deck[player][i+1];
      268:  220:    }
      130:  221:    state->deckCount[player]--;
        -:  222:  }
      288:  223:  for (i = 0; i < newDeckPos; i++) {
      130:  224:    state->deck[player][i] = newDeck[i];
      130:  225:    state->deckCount[player]++;
      130:  226:  }
        -:  227:
       14:  228:  return 0;
       14:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
        6:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
        6:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
        6:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
        6:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       12:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
        6:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        6:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
        6:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
        6:  269:  return 0;
        6:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
        6:  315:  int currentPlayer = whoseTurn(state);
        6:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
       15:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
       36:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
       24:  532:    for (i = 0; i < state->discardCount[player];i++){
       10:  533:      state->deck[player][i] = state->discard[player][i];
       10:  534:      state->discard[player][i] = -1;
       10:  535:    }
        -:  536:
        2:  537:    state->deckCount[player] = state->discardCount[player];
        2:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
        2:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
        2:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
        2:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
        2:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
        2:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
        2:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  562:    state->deckCount[player]--;
        2:  563:    state->handCount[player]++;//Increment hand count
        2:  564:  }
        -:  565:
        -:  566:  else{
       34:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
       34:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
       34:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       34:  575:    state->deckCount[player]--;
       34:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
       36:  579:  return 0;
       36:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
        6:  652:  int currentPlayer = whoseTurn(state);
        6:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
        6:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
        6:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
        6:  659:  int z = 0;// this is the counter for the temp hand
        6:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
        6:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
        3:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
        3:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
        3:  823:      discardCard(handPos, currentPlayer, state, 0);
        3:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
        3:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
        6: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
        6: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
        6: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        6: 1124:      state->playedCardCount++;
        6: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
        6: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
        6: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
        6: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
        6: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
        6: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
        6: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
        6: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
       12: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
      144: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
       60: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
       32: 1203:	  state->coins += 1;
       32: 1204:	}
       28: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
       28: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
       60: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
       12: 1216:  state->coins += bonus;
        -: 1217:
       12: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
        3: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
        3: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
        3: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
        3: 1273:      discardCard(handPos, currentPlayer, state, 0);
        3: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
File 'dominion.c'
Lines executed:25.11% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
      176:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      176:   11:  if (*(int*)a < *(int*)b)
       62:   12:    return -1;
      114:   13:  return 0;
      176:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
       12:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      132:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
     1320:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
     1140:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
      600:   65:        }
       60:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        6:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        6:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
     1980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      114:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
       12:  116:		    state->supplyCount[i] = 8; 
       12:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
       12:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
      870:  130:	}
        -:  131:
      120:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       36:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       96:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
       36:  145:	}
      192:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
       84:  150:	}
       12:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       36:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
       12:  160:    }
        -:  161:
        -:  162:  //draw player hands
       36:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
       12:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      336:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
      162:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       72:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
       30:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        6:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       14:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       14:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       14:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      288:  214:  while (state->deckCount[player] > 0) {
      130:  215:    card = floor(Random() * state->deckCount[player]);
      130:  216:    newDeck[newDeckPos] = state->deck[player][card];
      130:  217:    newDeckPos++;
      796:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
      268:  219:      state->deck[player][i] = state->deck[player][i+1];
      268:  220:    }
      130:  221:    state->deckCount[player]--;
        -:  222:  }
      288:  223:  for (i = 0; i < newDeckPos; i++) {
      130:  224:    state->deck[player][i] = newDeck[i];
      130:  225:    state->deckCount[player]++;
      130:  226:  }
        -:  227:
       14:  228:  return 0;
       14:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
        6:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
        6:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
        6:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
        6:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       12:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
        6:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        6:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
        6:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
        6:  269:  return 0;
        6:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
        6:  315:  int currentPlayer = whoseTurn(state);
        6:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
       15:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
       36:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
       24:  532:    for (i = 0; i < state->discardCount[player];i++){
       10:  533:      state->deck[player][i] = state->discard[player][i];
       10:  534:      state->discard[player][i] = -1;
       10:  535:    }
        -:  536:
        2:  537:    state->deckCount[player] = state->discardCount[player];
        2:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
        2:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
        2:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
        2:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
        2:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
        2:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
        2:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  562:    state->deckCount[player]--;
        2:  563:    state->handCount[player]++;//Increment hand count
        2:  564:  }
        -:  565:
        -:  566:  else{
       34:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
       34:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
       34:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       34:  575:    state->deckCount[player]--;
       34:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
       36:  579:  return 0;
       36:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
        6:  652:  int currentPlayer = whoseTurn(state);
        6:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
        6:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
        6:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
        6:  659:  int z = 0;// this is the counter for the temp hand
        6:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
        6:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
        3:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
        3:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
        3:  823:      discardCard(handPos, currentPlayer, state, 0);
        3:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
        3:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
        6: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
        6: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
        6: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        6: 1124:      state->playedCardCount++;
        6: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
        6: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
        6: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
        6: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
        6: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
        6: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
        6: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
        6: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
       12: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
      144: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
       60: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
       32: 1203:	  state->coins += 1;
       32: 1204:	}
       28: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
       28: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
       60: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
       12: 1216:  state->coins += bonus;
        -: 1217:
       12: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
        3: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
        3: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
        3: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
        3: 1273:      discardCard(handPos, currentPlayer, state, 0);
        3: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
File 'dominion.c'
Lines executed:25.11% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
      176:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      176:   11:  if (*(int*)a < *(int*)b)
       62:   12:    return -1;
      114:   13:  return 0;
      176:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
       12:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      132:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
     1320:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
     1140:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
      600:   65:        }
       60:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        6:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        6:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
     1980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      114:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
       12:  116:		    state->supplyCount[i] = 8; 
       12:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
       12:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
      870:  130:	}
        -:  131:
      120:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       36:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       96:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
       36:  145:	}
      192:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
       84:  150:	}
       12:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       36:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
       12:  160:    }
        -:  161:
        -:  162:  //draw player hands
       36:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
       12:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      336:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
      162:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       72:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
       30:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        6:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       14:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       14:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       14:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      288:  214:  while (state->deckCount[player] > 0) {
      130:  215:    card = floor(Random() * state->deckCount[player]);
      130:  216:    newDeck[newDeckPos] = state->deck[player][card];
      130:  217:    newDeckPos++;
      796:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
      268:  219:      state->deck[player][i] = state->deck[player][i+1];
      268:  220:    }
      130:  221:    state->deckCount[player]--;
        -:  222:  }
      288:  223:  for (i = 0; i < newDeckPos; i++) {
      130:  224:    state->deck[player][i] = newDeck[i];
      130:  225:    state->deckCount[player]++;
      130:  226:  }
        -:  227:
       14:  228:  return 0;
       14:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
        6:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
        6:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
        6:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
        6:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       12:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
        6:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        6:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
        6:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
        6:  269:  return 0;
        6:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
        6:  315:  int currentPlayer = whoseTurn(state);
        6:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
       15:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
       36:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
       24:  532:    for (i = 0; i < state->discardCount[player];i++){
       10:  533:      state->deck[player][i] = state->discard[player][i];
       10:  534:      state->discard[player][i] = -1;
       10:  535:    }
        -:  536:
        2:  537:    state->deckCount[player] = state->discardCount[player];
        2:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
        2:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
        2:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
        2:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
        2:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
        2:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
        2:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  562:    state->deckCount[player]--;
        2:  563:    state->handCount[player]++;//Increment hand count
        2:  564:  }
        -:  565:
        -:  566:  else{
       34:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
       34:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
       34:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       34:  575:    state->deckCount[player]--;
       34:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
       36:  579:  return 0;
       36:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
        6:  652:  int currentPlayer = whoseTurn(state);
        6:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
        6:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
        6:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
        6:  659:  int z = 0;// this is the counter for the temp hand
        6:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
        6:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
        3:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
        3:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
        3:  823:      discardCard(handPos, currentPlayer, state, 0);
        3:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
        3:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
        6: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
        6: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
        6: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        6: 1124:      state->playedCardCount++;
        6: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
        6: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
        6: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
        6: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
        6: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
        6: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
        6: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
        6: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
       12: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
      144: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
       60: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
       32: 1203:	  state->coins += 1;
       32: 1204:	}
       28: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
       28: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
       60: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
       12: 1216:  state->coins += bonus;
        -: 1217:
       12: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
        3: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
        3: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
        3: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
        3: 1273:      discardCard(handPos, currentPlayer, state, 0);
        3: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
File 'dominion.c'
Lines executed:25.11% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
      176:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      176:   11:  if (*(int*)a < *(int*)b)
       62:   12:    return -1;
      114:   13:  return 0;
      176:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
       12:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      132:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
     1320:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
     1140:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
      600:   65:        }
       60:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        6:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        6:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
     1980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      114:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
       12:  116:		    state->supplyCount[i] = 8; 
       12:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
       12:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
      870:  130:	}
        -:  131:
      120:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       36:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       96:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
       36:  145:	}
      192:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
       84:  150:	}
       12:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       36:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
       12:  160:    }
        -:  161:
        -:  162:  //draw player hands
       36:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
       12:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      336:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
      162:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       72:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
       30:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        6:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       14:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       14:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       14:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      288:  214:  while (state->deckCount[player] > 0) {
      130:  215:    card = floor(Random() * state->deckCount[player]);
      130:  216:    newDeck[newDeckPos] = state->deck[player][card];
      130:  217:    newDeckPos++;
      796:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
      268:  219:      state->deck[player][i] = state->deck[player][i+1];
      268:  220:    }
      130:  221:    state->deckCount[player]--;
        -:  222:  }
      288:  223:  for (i = 0; i < newDeckPos; i++) {
      130:  224:    state->deck[player][i] = newDeck[i];
      130:  225:    state->deckCount[player]++;
      130:  226:  }
        -:  227:
       14:  228:  return 0;
       14:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
        6:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
        6:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
        6:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
        6:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       12:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
        6:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        6:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
        6:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
        6:  269:  return 0;
        6:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
        6:  315:  int currentPlayer = whoseTurn(state);
        6:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
       15:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
       36:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
       24:  532:    for (i = 0; i < state->discardCount[player];i++){
       10:  533:      state->deck[player][i] = state->discard[player][i];
       10:  534:      state->discard[player][i] = -1;
       10:  535:    }
        -:  536:
        2:  537:    state->deckCount[player] = state->discardCount[player];
        2:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
        2:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
        2:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
        2:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
        2:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
        2:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
        2:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  562:    state->deckCount[player]--;
        2:  563:    state->handCount[player]++;//Increment hand count
        2:  564:  }
        -:  565:
        -:  566:  else{
       34:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
       34:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
       34:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       34:  575:    state->deckCount[player]--;
       34:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
       36:  579:  return 0;
       36:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
        6:  652:  int currentPlayer = whoseTurn(state);
        6:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
        6:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
        6:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
        6:  659:  int z = 0;// this is the counter for the temp hand
        6:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
        6:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
        3:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
        3:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
        3:  823:      discardCard(handPos, currentPlayer, state, 0);
        3:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
        3:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
        6: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
        6: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
        6: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        6: 1124:      state->playedCardCount++;
        6: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
        6: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
        6: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
        6: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
        6: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
        6: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
        6: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
        6: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
       12: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
      144: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
       60: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
       32: 1203:	  state->coins += 1;
       32: 1204:	}
       28: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
       28: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
       60: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
       12: 1216:  state->coins += bonus;
        -: 1217:
       12: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
        3: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
        3: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
        3: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
        3: 1273:      discardCard(handPos, currentPlayer, state, 0);
        3: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
File 'dominion.c'
Lines executed:25.11% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
      176:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      176:   11:  if (*(int*)a < *(int*)b)
       62:   12:    return -1;
      114:   13:  return 0;
      176:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
       12:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      132:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
     1320:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
     1140:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
      600:   65:        }
       60:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        6:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        6:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
     1980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      114:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
       12:  116:		    state->supplyCount[i] = 8; 
       12:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
       12:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
      870:  130:	}
        -:  131:
      120:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       36:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       96:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
       36:  145:	}
      192:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
       84:  150:	}
       12:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       36:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
       12:  160:    }
        -:  161:
        -:  162:  //draw player hands
       36:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
       12:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      336:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
      162:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       72:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
       30:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        6:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       14:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       14:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       14:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      288:  214:  while (state->deckCount[player] > 0) {
      130:  215:    card = floor(Random() * state->deckCount[player]);
      130:  216:    newDeck[newDeckPos] = state->deck[player][card];
      130:  217:    newDeckPos++;
      796:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
      268:  219:      state->deck[player][i] = state->deck[player][i+1];
      268:  220:    }
      130:  221:    state->deckCount[player]--;
        -:  222:  }
      288:  223:  for (i = 0; i < newDeckPos; i++) {
      130:  224:    state->deck[player][i] = newDeck[i];
      130:  225:    state->deckCount[player]++;
      130:  226:  }
        -:  227:
       14:  228:  return 0;
       14:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
        6:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
        6:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
        6:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
        6:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       12:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
        6:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        6:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
        6:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
        6:  269:  return 0;
        6:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
        6:  315:  int currentPlayer = whoseTurn(state);
        6:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
       15:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
       36:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
       24:  532:    for (i = 0; i < state->discardCount[player];i++){
       10:  533:      state->deck[player][i] = state->discard[player][i];
       10:  534:      state->discard[player][i] = -1;
       10:  535:    }
        -:  536:
        2:  537:    state->deckCount[player] = state->discardCount[player];
        2:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
        2:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
        2:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
        2:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
        2:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
        2:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
        2:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  562:    state->deckCount[player]--;
        2:  563:    state->handCount[player]++;//Increment hand count
        2:  564:  }
        -:  565:
        -:  566:  else{
       34:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
       34:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
       34:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       34:  575:    state->deckCount[player]--;
       34:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
       36:  579:  return 0;
       36:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
        6:  652:  int currentPlayer = whoseTurn(state);
        6:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
        6:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
        6:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
        6:  659:  int z = 0;// this is the counter for the temp hand
        6:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
        6:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
        3:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
        3:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
        3:  823:      discardCard(handPos, currentPlayer, state, 0);
        3:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
        3:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
        6: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
        6: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
        6: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        6: 1124:      state->playedCardCount++;
        6: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
        6: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
        6: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
        6: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
        6: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
        6: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
        6: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
        6: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
       12: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
      144: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
       60: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
       32: 1203:	  state->coins += 1;
       32: 1204:	}
       28: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
       28: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
       60: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
       12: 1216:  state->coins += bonus;
        -: 1217:
       12: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
        3: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
        3: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
        3: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
        3: 1273:      discardCard(handPos, currentPlayer, state, 0);
        3: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
File 'dominion.c'
Lines executed:25.11% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
      176:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      176:   11:  if (*(int*)a < *(int*)b)
       62:   12:    return -1;
      114:   13:  return 0;
      176:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
       12:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      132:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
     1320:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
     1140:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
      600:   65:        }
       60:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        6:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        6:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
     1980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      114:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
       12:  116:		    state->supplyCount[i] = 8; 
       12:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
       12:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
      870:  130:	}
        -:  131:
      120:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       36:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       96:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
       36:  145:	}
      192:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
       84:  150:	}
       12:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       36:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
       12:  160:    }
        -:  161:
        -:  162:  //draw player hands
       36:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
       12:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      336:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
      162:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       72:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
       30:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        6:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       14:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       14:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       14:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      288:  214:  while (state->deckCount[player] > 0) {
      130:  215:    card = floor(Random() * state->deckCount[player]);
      130:  216:    newDeck[newDeckPos] = state->deck[player][card];
      130:  217:    newDeckPos++;
      796:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
      268:  219:      state->deck[player][i] = state->deck[player][i+1];
      268:  220:    }
      130:  221:    state->deckCount[player]--;
        -:  222:  }
      288:  223:  for (i = 0; i < newDeckPos; i++) {
      130:  224:    state->deck[player][i] = newDeck[i];
      130:  225:    state->deckCount[player]++;
      130:  226:  }
        -:  227:
       14:  228:  return 0;
       14:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
        6:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
        6:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
        6:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
        6:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       12:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
        6:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        6:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
        6:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
        6:  269:  return 0;
        6:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
        6:  315:  int currentPlayer = whoseTurn(state);
        6:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
       15:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
       36:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
       24:  532:    for (i = 0; i < state->discardCount[player];i++){
       10:  533:      state->deck[player][i] = state->discard[player][i];
       10:  534:      state->discard[player][i] = -1;
       10:  535:    }
        -:  536:
        2:  537:    state->deckCount[player] = state->discardCount[player];
        2:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
        2:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
        2:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
        2:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
        2:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
        2:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
        2:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  562:    state->deckCount[player]--;
        2:  563:    state->handCount[player]++;//Increment hand count
        2:  564:  }
        -:  565:
        -:  566:  else{
       34:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
       34:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
       34:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       34:  575:    state->deckCount[player]--;
       34:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
       36:  579:  return 0;
       36:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
        6:  652:  int currentPlayer = whoseTurn(state);
        6:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
        6:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
        6:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
        6:  659:  int z = 0;// this is the counter for the temp hand
        6:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
        6:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
        3:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
        3:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
        3:  823:      discardCard(handPos, currentPlayer, state, 0);
        3:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
        3:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
        6: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
        6: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
        6: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        6: 1124:      state->playedCardCount++;
        6: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
        6: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
        6: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
        6: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
        6: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
        6: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
        6: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
        6: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
       12: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
      144: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
       60: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
       32: 1203:	  state->coins += 1;
       32: 1204:	}
       28: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
       28: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
       60: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
       12: 1216:  state->coins += bonus;
        -: 1217:
       12: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
        3: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
        3: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
        3: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
        3: 1273:      discardCard(handPos, currentPlayer, state, 0);
        3: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
File 'dominion.c'
Lines executed:25.11% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
      176:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      176:   11:  if (*(int*)a < *(int*)b)
       62:   12:    return -1;
      114:   13:  return 0;
      176:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
       12:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      132:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
     1320:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
     1140:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
      600:   65:        }
       60:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        6:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        6:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
     1980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      114:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
       12:  116:		    state->supplyCount[i] = 8; 
       12:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
       12:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
      870:  130:	}
        -:  131:
      120:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       36:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       96:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
       36:  145:	}
      192:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
       84:  150:	}
       12:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       36:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
       12:  160:    }
        -:  161:
        -:  162:  //draw player hands
       36:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
       12:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      336:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
      162:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       72:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
       30:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        6:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       14:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       14:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       14:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      288:  214:  while (state->deckCount[player] > 0) {
      130:  215:    card = floor(Random() * state->deckCount[player]);
      130:  216:    newDeck[newDeckPos] = state->deck[player][card];
      130:  217:    newDeckPos++;
      796:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
      268:  219:      state->deck[player][i] = state->deck[player][i+1];
      268:  220:    }
      130:  221:    state->deckCount[player]--;
        -:  222:  }
      288:  223:  for (i = 0; i < newDeckPos; i++) {
      130:  224:    state->deck[player][i] = newDeck[i];
      130:  225:    state->deckCount[player]++;
      130:  226:  }
        -:  227:
       14:  228:  return 0;
       14:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
        6:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
        6:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
        6:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
        6:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       12:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
        6:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        6:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
        6:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
        6:  269:  return 0;
        6:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
        6:  315:  int currentPlayer = whoseTurn(state);
        6:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
       15:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
       36:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
       24:  532:    for (i = 0; i < state->discardCount[player];i++){
       10:  533:      state->deck[player][i] = state->discard[player][i];
       10:  534:      state->discard[player][i] = -1;
       10:  535:    }
        -:  536:
        2:  537:    state->deckCount[player] = state->discardCount[player];
        2:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
        2:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
        2:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
        2:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
        2:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
        2:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
        2:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        2:  562:    state->deckCount[player]--;
        2:  563:    state->handCount[player]++;//Increment hand count
        2:  564:  }
        -:  565:
        -:  566:  else{
       34:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
       34:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
       34:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       34:  575:    state->deckCount[player]--;
       34:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
       36:  579:  return 0;
       36:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
        6:  652:  int currentPlayer = whoseTurn(state);
        6:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
        6:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
        6:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
        6:  659:  int z = 0;// this is the counter for the temp hand
        6:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
        6:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
        3:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
        3:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
        3:  823:      discardCard(handPos, currentPlayer, state, 0);
        3:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
        3:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
        6: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
        6: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
        6: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        6: 1124:      state->playedCardCount++;
        6: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
        6: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
        6: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
        6: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
        6: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
        6: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
        6: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
        6: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
       12: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
      144: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
       60: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
       32: 1203:	  state->coins += 1;
       32: 1204:	}
       28: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
       28: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
       60: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
       12: 1216:  state->coins += bonus;
        -: 1217:
       12: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
        3: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
        3: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
        3: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
        3: 1273:      discardCard(handPos, currentPlayer, state, 0);
        3: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                  __text          __TEXT               *                                 __stubs         __TEXT                                             __stub_helper   __TEXT              P                                __const         __TEXT          0    @       0                            __cstring       __TEXT          p    s      p                           __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                0                                __got           __DATA                                                  __nl_symbol_ptr __DATA                                    "           __la_symbol_ptr __DATA                                      $           __mod_init_func __DATA                                   	               __const         __DATA          @          @                            __data          __DATA                                                __bss           __DATA              P                                       H   __LINKEDIT       @     @             1                    "  0           @           H     "         %   @      P       V  V  )     #                           ? D                             /usr/lib/dyld             "P>7c$       
  
 *              (                      8         
   /usr/lib/libSystem.B.dylib      &      8% p   )      %                                                                                                                                                                                                                                                     UHH H   H H}HuH       H}H}LELELMA	LMED9AD9HOH4H   H4A       H H   H E      HZ       H}H}DD9AD9HLH4H   H4A       H< H   H/ E   H$ H   H E    H H   H E]ffffff.     UHHH H   H f  H H   H   HEHEH]D  UHAWAVSHXE(DU D]]L5 I   L5 ]DMDEMUuEDUD]}(   H` H   HR EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D})  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPH H   Ht UHu}HM   EEHMHMUUHuHu  Hc}  H0       E=   A=   HOH<H   H<AJ   H       M   @   HLH4H   H4@       H H   H Ej  H H   H MHEE    H_       M
   @
   HLH4H   H4@     H] H   HP E    H    
   M
   @
   HLH4H   H4@      H       M}9A9HEH4H   H4A   y   Hk       Hc}LEAHc}LEED9AD9HDH4H   H4A       H H   H E  Hz H   Hm Hn H   Ha M   MHQ H   HD HE H   H8 M   M!H       M   @   HDH4H   H4@   $   H H   H HE@
      H       M   @   HDH4H   H4@   $   H H   H HE@      H| H   Ho HE@   He H   HX Hq       M   @   HDH4H   H4@   :   H H   H HE@   HE@   HE@   5   H H   H HE@   HE@   HE@   <   H H   H iU   )HMAHMA(   HMA   E   Hq #   "   M   @   HNH4H   H4@     HG H   H: E    H &   %   M
   @
   HLH4H   H4@   <  H
 (   '   Hc}LEADMD9AD9HDH4H   H4A     Hq
 *   )   Hc}LEA   A   HDH4H   H4AS   H#
 ,   +   Hc}LEA
   A
   HDH4H   H4A      H	 .   -   M   @   HDH4H   H4@   )   H
 H   H
 HcEHMD   $   H
 H   H
 HcEHMD   H
 H   H
 $   H
 H   H
 HcEHMD
   H
 H   H
 ]   H
 H   Hv
 HcEHMDHg
 H   HZ
 H[
 H   HN
 M   MzH>
 H   H1
 H2
 H   H%
 M   MH
 H   H
 E    H2 ;   :   M}9A9HLH4H   H4A     H	 H   H	 HcEHM?      E    H >   =   M   @   HLH4H   H4@   y   Hm	 H   H`	 HcEHcMHUHH   Hi  H   HcEHM?     ?  H!	 H   H	 M   M=H	 H   H E   H C   B   M
   @
   HLH4H   H4@   y   H H   H HcEHcMHUHH   Hi  H   HcEHM?     ?  Hk H   H^ M   M=HN H   HA HB H   H5 M   MH% H   H E    H J   I   M}9A9HLH4H   H4A      }Hu  H5y L   K   =    A=    HLHH   HA       H H   H E  H H   Hw Hx H   Hk M   MH[ H   HN E    H R   Q   M}9A9HLH4H   H4A   _   H H   H HcEHM8       HcEHM^      H H   H M   M\H H   H E    H W   V   M   @   HNH4H   H4@   I   Hw H   Hj HcEHMDp    H[ H   HN M   MmH> H   H1 HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    H \   [   M   @   HLH4H   H4@   O   H H   Hv HE   Hu[  EHa H   HT M   Mg1HB H   H5 HE   Hu	  E    EH H   H EHP] UHH  H  H HEH H   H  HH        HH    LcLG?  A   AA   HLH4H   H4A   #   Hd H   HW      HH5; H   H5- HcHHH   Hi  HHcLIc?    H       HcLA?      A    HOH4H   H4A     H H   H   HcH*?  Y  ,HcHcHHH   Hi  HHc    H 	      HcLE?  A   D9AD9HLH4H   H4A      H H   H    HcHcHHH   Hi  HHcHcHHH   Hi  HH] H   HP    H: H   H- HcH?  ?  H H   H     H       9A9HLH4H   H4A      H H   H Hc HcHcHHH   Hi  HHcH?     ?  HQ H   HD    H. H   H!     H  H H   H H H;E   H  ]  fffff.     UHH@H H   H }HuH       MMH}H}LcELMG?  A    AA    HNH4H   H4A     H7 H   H* E    H       MHc}LEE^  D9AD9HLH4H   H4A      H H   H HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HHp H   Hc M   MHcEHM^  HcEHM?  HcEHM^      }HuMH 	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H H   H El  H H   Hy M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      H H   H HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   HE H   H8 E    H2 H   H% EH@]fff.     UHH H   H Hu}UH H   H MMHEHEUUHu       E    Hj       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H H   H HE         Q  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H_ H   HR HE            H    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   H H   H HE         H H   H H H   H H H   H H H   H M   M1H{ H   Hm UHM      ]UHAVSHPH  H   H  MUu}LEH        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H%  H   H  E  H        H}      A   HLH4H   H4A       H  H   H  E  }Hu  H5p        EE=   A=   HLHH   HAJ   H*  
   	   M   @   HOH4H   H4@       H8  H   H+  E   HE}uUMLEDMH$V  L     A   A=    =    MLOI   O       H  H   H  EJ   H  H   H  HE      HE   HuUAE    EHp  H   Hc  EHP[A^]    UHH H  H   H  }HuH  H   H  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL)  MLUL[  I   LM  HDL HHDDLLHC  H=     A   A   Lu  L]        LA   99MONI   N      H@  H   H3            H|o4  H4  HHcHH=\  H  H   Hq  Ht  H   Hg  H^  =4  H=  HT  H   HFq  H/  H   H"      HA           @   HLH4H   H4@   W   H  H   H  HxH  H   H     \H  H   H  H             Hf  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   H  H   H  HtH  H   H  H  H   H     1H  H   H  HHa      p1  H=  H  H   Hn  H@  H   H3      H  *   )   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHH   Hi  H4HcHcHcHH   Hi  HHm  H   H`         HE  H   H8  H   lH  /   .      @   HDH4H   H4@   l  H3  H5H  1   0   =    A=    HNHH   HA      H  H   H     H   h2  H  4   3   Ah9A9ILLI   LA   -   H=  H'  H   H     d>   1H  H   H  H9      `H  H   H  H  H   H  GH  H   H      H  ;   :   HcLE8   D9AD9HNH4H   H4A      HS  H   HF  HcHcHcHH   Hi  HHcH  H   H     H  H   H      -  H=\  H  H    Hj  H  H   H  K-  H=  Hb  H(   HTj  Hm  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   H  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   H  H   Hs  +  H=  F   E       @   HOH4H   H4@M   H  H   G        @    HLH4H   H4@   #   H  H   H  G+  HcHcHH   Hi  H<~.      \h.  HA  K   J   \9A9HOH4H   H4A   #   H\  H   HO  *     H<  H   H/   H?5  1HXY      THx  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H7  H   H*  HX  P?   H  H   H  H  H   H     H  H   H      (  H=  H  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5  W   V   AL9A9IOLI   LA   #   H  H   H  '  1H  H   H   H2  1HHV      DH  [   Z   HcLE8   D9AD9HLH4H   H4A      H[  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HU  @?   H  H   H  H  H   H     Hy  H   Hl      &  H=  H'  H8   Hc  HB  H   H5  HCX  %  H=  H  H@   Hb  H  H   H  H1H      H   H<T      8,%  H=  HC  HH   H5b  HN  e   d   H             A    HOHH   HA     H  H   H         H  h   g       @    HEH4H   H4@     Hs  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  HZ  H   HM  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  HR  m   l   HcLE8   D9AD9HLH4H   H4A      He  H   HX     HcHcHH   Hi  HHcHcHH   Hi  HH  H   H     
H  H   H  HcHHc8   HcHH   Hi  HHcH8   8         H  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5m  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5  v   Au   A=    A=    MDNI   NA   &   HV  H   HI  H5  0H8  H   H+  H,  H   H      &   H  H   H     H  H   H  H  H   H  .H  H   H  .     H"  H5     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5<     A   A=    A=    MDNI   NA   &   H  H   H  HL4  (H  H   H  H  H   H  H  H   H      F  H=  H]  HP   HO[  H  H   H  HQ    H=  H  HX   H[  1H         HL  H     A   A    A    MENI   NA$   9   H  H   H  H      H     HZ             @    HEH4H   H4@   ^  Hm  H   H`  Hd*  H=        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH  H   H      HQ           @   HLH4H   H4@   W   H  H   H  HHx  H   Hk     \HU  H   HH      H        HDD9AD9HLH4H   H4A   {  H>        9A9HEH4H   H4A     H        HcLA8      A   HOH4H   H4A     Hv  H   Hi  H        HcLA8       A    HOH4H   H4A   9   1H  H   H  HI  jH  H   H      H           @   HLH4H   H4@   W   H  H   H  HbHu  H   Hh     \HR  H   HE  HF  H   H9  H:  H   H-  H.  H   H!     4H  H   H  H  H   H  H  H   H      :  H=  HQ  H`   HCU  H  H   H  H DL    H=  H  Hh   HT  H        HcLA^  HcLA?     A   HNHH   HA     H        HcLA?      A    HOH4H   H4A   ~   H  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?    H        HcLA^      A    HOH4H   H4A   ~   H  H   H  HcH^     HcHcHH?  Hi  HUHcH^  ^     H{  H   Hn  Ho  H   Hb  Hc  H   HV  ~  H        HcLA?      A    HDH4H   H4A     H  H   H      H        HcLE^  D9AD9HLH4H   H4A     H  H   H  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  H  H   H     H  H   H  HH  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   H  H   H  MHHcf  H^  Hf     f  EH  H   H      H^           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4AR   Hw        HcL   A   HDH4H   H4A   2   H  H   H  H           H        HcL   A   HDH4H   H4A9  H        HcL   A   HDH4H   H4A   HY        HcL   A   HDH4H   H4A   H        HcL
   A
   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   I   H-  H   H   HNH64   H  H   H  H      H   H  H   H  H  H   H  H  H   H     ?H  H   Hx      <  H=  HS  Hp   HEJ  HN  H   HA  H C    H=  H  Hx   HI     H  H   H  H    H        HDD9AD9HLH4H   H4A   2  Hy        9A9HEH4H   H4A     HN  H   HA      H        HcLE8   D9AD9HLH4H   H4A     H        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1H  H   H{  H+:   o  H	        HcLE8   D9AD9HDH4H   H4A      H  H   H      H        HcLE8   D9AD9HLH4H   H4A   ?   H  H   H  H  H   H     dHz  H   Hm  ?   Hi  H   H\  H]  H   HP     H:  H   H-  H.  H   H!  H"  H   H     }1H  H   H  H08        H=  H  H   HE  H        H      H   HcLALAHDHH   HA   #   H>  H   H1       H  H   H  HcHtp   tpH7        H=}  H  H   HD  1H  H   H  H         H6      3  H=  HJ  H   H<D  HU        H             A    HEHH   HA   x   H  H   H  H   H	     H   H5  1Hu  H   Hh  H`5        H=  H  H   HB  H   H   H      H      HDD9AD9HLH4H   H4A     H      9A9HEH4H   H4A   &  H  H   H  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    Hp  H   Hc  Hd  H   HW     HA  H   H4        H=j  H  H   H@  H
  H   H      H      HcLE8   D9AD9HLH4H   H4A      H5      HcLcLI   Mi  MA   A   HDH4H   H4A   p   H      9A9HEH4H   H4A   %   H  H   H  ?   H  H   H  H  H   H     H      @HOH4H   H4@   5     Hs  H   Hf  H0     H0      Hd         @   HLH4H   H4@   a         H  H   H  H~  H  H   H     RH  H   H     U   Hs  H   Hf  2   H=  H5I  D=  H5E  H   H57  H  H'  H   H  H H;E   H(	  []   )v)hmyw     UHH0H  H   H  }HuH        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       H}  H   Hp  E  }Hu  H59        =   A=   HLHH   HA       H$  H   H  E*  HE   }M  H        AM9A9ILLI   LA       H  H   H  E   1H  H   H  HE      }HuM`  Hu   }EM   M)Hu   Hu      HE  H   H8  H9  H   H,  H-  H   H   E    H  H   H  EH0]@ UHH  H   H  }HuH
  H   H  MMHEHEHcUHuD]UHH H  H   H  }G      EEMHHHUHuh  H  HMHcHH=  Hu  H   HG9  Hx  H   Hk  E    G  H=  H9  H   H9  HD  H   H7  E     H=  H  H   H8  H  H   H  E     H=X  H  H    H8  H  H   H  E     H=  H  H(   HW8  H  H   H  E    W  H=  HI  H0   H8  Ht  H   Hg  E     H=  H  H8   H7  H@  H   H3  E     H=h  H  H@   H7  H  H   H  E     H=,  H  HH   Hg7  H  H   H  E   g  H=  HY  HP   H+7  H  H   H  E   +  H=  H  HX   H6  Hp  H   Hc  E     H=x  H  H`   H6  H<  H   H/  E     H=<  H  Hh   Hw6  H  H   H  E   w  H=   Hi  Hp   H;6  H  H   H  E   ;  H=  H-  Hx   H5  H  H   H  E     H=  H  H   H5  Hl  H   H_  E     H=L  H  H   H5  H8  H   H+  E     H=  Hy  H   HK5  H  H   H  E   K  H=  H=  H   H5  H  H   H  E     H=  H  H   H4  H  H   H  E     H=\  H  H   H4  Hh  H   H[  E     H=   H  H   H[4  H4  H   H'  E   [  H=  HM  H   H4  H   H   H  E     H=  H  H   H3  H  H   H  E      H=l  H  H   H3  H  H   H  E      H=0  H  H   Hk3  Hd  H   HW  E   k   H=  H]  H   H/3  H0  H   H#  E   /   H=  H5!  2  H5  H   H5  EH  H   H  EH ] ]M=y-iYI9u@ UHH0H  H   H  UHu}MEEHMHMUUuu}HuH        A=   A=   ILLI   LA       H\  H   HO  E   H$        M   @   HDH4H   H4@   d   H
  H   H  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  Hv        M   @   HDH4H   H4@   d   Ht  H   Hg  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  H  H   H  H  H   H  HcEHMTTE    H  H   H  EH0]fffff.     UHHHY  H   HL  H}HI  H   H<  HEHEH}   HcHM8   H]    UHH  H   H  H}H  H   H  HEHEHM   ]fff.     UHH  H   H  u}HUH  H   H  MMUUHEHEE    E    H        MHc}LEE?  D9AD9HLH4H   H4A      H=        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    Hc     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    H5        MHc}LEE^  D9AD9HLH4H   H4A      H        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H+  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E]UHH0H  H   H  H}H  H   H  HEHEH}EE    H        MHc}LEE8   D9AD9HLH4H   H4A      Hf  H   HY  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HH  H   H  M   MH        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   Hc  H   HV  M   HE   "   H?  H   H2  HE       H%  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    HL        M   @   HLH4H   H4@   O   Hj  H   H]  HE   HuEHH  H   H;  M   Mg1H)  H   H  HE   Hu1EH0]@ UHH  H   H  H}H        H}H}LEAH    A    HDH4H   H4A       H  H   H  E     H  H   Hy  E    E    HD        M   @   HLH4H   H4@      H        Hc}LEAL    A    HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   M	HM        M   @   HMH4H   H4@       Hs  H   Hf  E      H[  H   HN  E    HH  H   H;  E]fD  UHH@H1  H   H$  }HuH  H   H  MMHEHEE    E    H        MHc}LEE8   D9AD9HLH4H   H4A     H        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       HZ  H   HM  M   MH
        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MHr        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H(  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A     H        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H"  H   H  M   MH        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       HB  H   H5  M   MH
  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       Hb  H   HU  M   MH  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  E    H  1   0   MHc}LEE^  D9AD9HLH4H   H4A     H  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH*  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H*  H   H  M   MH
  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H}  H~  H   Hq  M   M+Ha  H   HT  EH@]ff.     UHH0HA  H   H4  H}HuH-  H   H   HEHEHMHME    H        M   @   HLH4H   H4@      H        MH}DD9AD9HMH4H   H4A   (   H  H   H  HcEHM+   Hu  H   Hh  }HuHcuHMHR  H   HE  HF  H   H9  M   MH)  H   H  E    E    H        M   @   HLH4H   H4@      Hm        Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMHz  H   Hm  Hn  H   Ha  M   M
HQ  H   HD  HcEHMUH}-EE    H        M   @   HLH4H   H4@      HB        Hc}LEADMD9AD9HDH4H   H4A   m   H        M}9A9HOH4H   H4A   (   Ht  H   Hg  HcEHM   HT  H   HG  HH  H   H;  M   MH+  H   H  E    E    H)        M   @   HLH4H   H4@      H         Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH|  H   Ho  Hp  H   Hc  M   M
HS  H   HF  HcEHMUE    H
  &   %   M   @   HLH4H   H4@      H  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   H  H   H  HcEHM   #   H  H   H  HcEHM    H|  H   Ho  Hp  H   Hc  M   M1HQ  H   HC  H0]D  UHH   H>  H HEH  H   H  HH  H   H  HHH       Ht           @   HLH4H   H4@     H'        HcLA?     A   HLH4H   H4A   ,   H  H   H  H[H#H=iy  HcH8      HcHcLI   Hi  IA &w  H+        A   A   IDLI   LA   H  
   	      @   HDH4H   H4@M   H           @   HDH4H   H4@   +   H  H   H     \   H  H   H  Hc HcH8   8      H8  H   H+  3H'  H   H  H               @    HMH4H   H4@      H  H   H     Hc HcH^     ^  HcHcLI?  Hi  IA   "1HS  H   HF  H.   H  HH;U   1H   ]s  @ UHH  H   H  HUu}MH        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   Hs  H   Hf  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  H        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   H  H   H  HcEHM8   8   \  HF        Hc}LEA8      A   HDH4H   H4A   5   H7  H   H*  HcEHM8   8      H
  H   H  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   HV  H   HI  1HH  H   H:  ]     UHH0H  H   H  H}uH  H   H  HEHEMMH}REE    H        M   @   HLH4H   H4@   H   Hg  H   HZ  }HuEHL  H   H?  M   Mn1H-  H   H   }uHU1EH0]@ UHH0H  H   H  H}uH  H   H  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPH  H   H  MUuH}DEHEHEMMUUuu}}H}H=     A   AEE=   A=   MDNI   NA   7   Hn  H   Ha  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   H  H   H  HE      HE   <   1H  H   H  }uHU1}uHUEEH  H   H     H  H   H  }uHUQ1EHP]@ UHHPH  H   H  UuH}MHEHEMMUUuuH}H=M     A   AEE    E=   A=   MONI   NAJ   H        M    @    HLH4H   H4@       H  H   H  E  H        M}9A9HDH4H   H4A       H  H   H  E{  Hw  H   Hj  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  H        M}9A9HEH4H   H4A      H{        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       Ha  H   HT  M   MHI  H   H<  H=  H   H0  M   MdHx        M}9A9HLH4H   H4A       H  H   H  E_  H  H   H  MHcEHULLE    H        MH}DD9AD9HLH4H   H4A      H        M}9A9HEH4H   H4A   E   1H;  H   H.  HcEHcMHuH   Hi  H<HuM:EH   H   H  H  H   H  M   M1H  H   H  }uHUYE    EH  "   !   M}9A9HLH4H   H4A     H{  H   Hn  E    HH  %   $   MHc}LEE8   D9AD9HLH4H   H4A      H  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      H  H   H  }uHUE9   H  H   H|  H}  H   Hp  M   MH`  H   HS  HT  H   HG  M   M'H7  H   H*  E    H$  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=!h  H5rh  V K  1H5dh  /AVUMP  	   H51~  lT     H55h  [H1AVO     H5J~  =T     H5h  1AVO     H5+~  T     H5g  VI1AVO  a   H5~  S     H5g  ;|1AVQO     H5  S     H5g  ] t1AV"O     H5f  S     H5g  T1AVN     H5  RS     H5Xg  w1AVN     H5  #S     H56g  YAr1AVN     H5  R  	   H5g  j1AVfN     H5  R  
   H5f  a'Hr1AV7N     H5  R     H5f  @1AVN     H5\  gR     H5f  -1AVM     H5=  8R     H5f  "mw1AVM     H5  	R     H5\f  |1AV{M  G   H5  Q     H56f  b1AVLM  .   H5   Q     H5f  W71AVM     H5A  |Q     H5e  `1AVL  :   H5  MQ     H5e  eW1AVL    H53  Q     H5e  Qw1AVL     H5  P     H5~e  :/T1AVaL     H5E  P     H5Xe  r%1AV2L     H5  P     H55e  Ba1AVL     H5  bP     H5e  PR1AVK     H5h  3P     H5d  Ce&1AVK     H5q  P     H5d  #e,1AVvK  /   H5Z  O     H5d  Ql1AVGK  
   H5  O  S  \  H]fD  UHH|y      Hiy      HVy      HCy      H0y      Hy      H
y      Hx      Hx      H)y      Hy      H#y      Hy      H{      H{      Hz      Hz      Hz      Hz      Hz      Hz      H}z      Hjz      HWz      HDz      H1z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hsy      H`y      HMy      H:y      H'y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      H|x      Hix      HVx      HCx      H0x      Hx      H
x      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hrw      H_w      HLw      H9w      H&w      Hw      H w      Hv      Hv      Hv      Hv      Hv      Hv      H{v      Hhv      H]y      HJy      H7y      H$y      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hyx      Hfx      HSx      H@x      H-x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      How      H\w      HIw      H6w      H#w      Hw      Hv      Hx      Hx      Htx      Hax      HNx      H;x      H(x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      H}w      Hjw      HWw      HDw      H1w      HFx      H3x      H x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Huw      Hbw      HOw      H<w      H)w      Hw      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hsw      H`w      HMw      H:w      H'w      Hw      Hw      Hvw      Hcw      Hpw      H]w      Hjw      HWw      H,x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hnw      H[w      HHw      H5w      H"w      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hwv      Hdv      HQv      Hw      Hw      Hw      Huw      Hbw      HOw      H<w      H)w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      H~v      Hkv      H`w      HMw      H:w      H'w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      H|v      Hiv      HVv      HCv      H0v      Hx      Hx      Hx      Htx      Hax      HNx      H;x      H(x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      H}w      Hjw      HWw      HDw      H1w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hsv      H`v      HMv      H:v      H'v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      H|u      Hiu      HVu      HCu      H0u      Hu      H
u      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hrt      H_t      HLt      H9t      H&t      Ht      H t      H%v      Hv      Hu      Hu      Hu      Hu      Hu      HPw      H=w      H*w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hlv      HYv      HFv      H3v      H v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Huu      Hbu      HOu      H<u      H)u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      H~t      Hkt      HXt      HEt      H2t      Ht      Ht      Hs      Hu      Hu      Hu      Hu      Hu      Hou      H\u      HIu      H6u      H#u      Hu      Ht      Ht      Ht      Ht      Hw      Hv      Hv      Hv      Hv      Hv      Hv      H|v      Hiv      HVv      HCv      H0v      Hv      H
v      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hru      H_u      HLu      H9u      H&u      Hu      H u      Ht      Ht      Ht      Ht      Ht      Ht      H{t      Hht      HUt      HBt      H/t      Ht      H	t      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hqs      H^s      HKs      H8s      H%s      Hs      Hr      Hr      Hr      Hr      Hv      Hpv      H]v      HJv      H7v      H$v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hyu      Hfu      HSu      H@u      H-u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hot      H\t      HIt      H6t      H#t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hxs      Hes      HRs      H?s      H,s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hnr      H[r      HHr      H5r      H"r      Hr      Hq      Hq      Hq      Hu      Hu      Hu      Hu      Hwu      Hdu      HQu      H>u      H+u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hmt      HZt      HGt      H4t      H!t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hvs      Hcs      HPs      H=s      H*s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hlr      HYr      HFr      H3r      H r      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Huq      Hbq      HOq      H<q      H)q      Hq      Hu      Ht      Ht      Ht      Ht      Ht      Ht      H~t      Hkt      HXt      HEt      H2t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hts      Has      HNs      H;s      H(s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      H}r      Hjr      HWr      HDr      H1r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hsq      H`q      HMq      H:q      H'q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      H|p      Hip      HVp      HCt      H0t      Ht      H
t      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hrs      H_s      HLs      H9s      H&s      Hs      H s      Hr      Hr      Hr      Hr      Hr      Hr      H{r      Hhr      HUr      HBr      H/r      Hr      H	r      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hqq      H^q      HKq      H8q      H%q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hzp      Hgp      HTp      HAp      H.p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      H{r      Hhr      HUr      HBr      H/r      Hr      H	r      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hqq      H^q      HKq      H8q      H%q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hzp      Hgp      HTp      HAp      Hq      Hq      Hpq      H]q      HJq      H7q      H$q      Hq      Hp      Hp      Hp      Hp      Hp      Hq      Hlq      HYq      HFq      H3q      H q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Huq      Hbq      HOq      H<q      H)q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      H~p      Hkp      HXp      HEp      H2p      HWq      HDq      H1q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hsp      H`p      HMp      H:p      H'p      Hp      Hp      Ho      Ho      Hp      Hp      Hp      Hwp      Hdp      HQp      H>p      Hsp      H`p      Hq      Hq      Hq      Hq      Hq      H~q      Hkq      HXq      HEq      H2q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Htp      Hap      HNp      H;p      H(p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      H}o      Hjo      HWo      HDo      H1o      Ho      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hsn      H0p      Hp      H
p      Ho      Ho      Ho      Ho      Ho      Ho      Ho      ] UHH=H5y;  ]UHH@g  HJ  H HEHo  H   Ho  1E    <  <  H=@  1f  HL>  (   ALUEJ  E   E    HLLHLH;  HHH;  H ;  HHu}UDHEE  Hn        =AAAALcI    AI    HEH<H   H<A      H=B  H5?  5   H?  :  H=n  H   H0n  Ht  H=m        =AAAALcI    AI    HEH4H   H4A      H=zA  H5s>  6   H>  :  Hm  H   Hm  H  H=]m  
   	   =AAAALcI    AI    HEH4H   H4A      H=@  H5=  7   H>  ~9  H=m  H   H0m  H  H=l        =   AAAALcI    AI    HEH4H   H4A      H=:@  H53=  8   Hw=  8  Hl  H   Hl  H  H=l        =   AAAALcI    AI    HEH4H   H4A      H=?  H5<  9   H<  >8  H=l  H   H0l  H  H=}k        =   AAAALcI    AI    HEH4H   H4A      H=>  H5;  :   Hb<  7  Hk  H   Hk  H=_<  Hk  H   Hk   7  H=GE  MH?H;}   H@g  ]=7      UHH0HQk  H   HDk  H}H=;  HEHEHM       HM      HM        T7     HuE?Hj        EE=A=HDHH   HA   *   H=~;  Hj  H   Hj   6  E%   H=f;  Hj  H   Hj   6  EHvj  H   Hij  EH0]     UHH0Hj  H   Htj  H}H=1;  HEHEHM       HM      HMA      '6     HuEHj        EE=A=HDHH   HA   *   H=Q:  Hi  H   Hi   5  E%   H=9:  Hi  H   Hi   5  EHi  H   Hi  HE@ 
   EH0]UHH@Hi  H   Hi  H}H=:  HEHEE    HM       HM   
   HM      HM    4  
   HM   uuEu
   u)uHM      HuHi        LEA   DMD9AD9HDHH   HAE      Hh  H   Hh  E   Hh        M    @    HEH4H   H4@   7   H=H9  Huh  H   Hhh  HE   U 3  E2   H=E9  HFh  H   H9h  HE   U 3  EH#h  H   Hh  HE@,
   EH@]fUHH0Hg  H   Htg  H}
   HEHEHM       HM   
   HM      HuH)g        LEA   }}    A    HEHH   HAE   *   H=7  Hf  H   Hf   w2  E/   H=7  Hf  H   Hf  HE    C2  EHf  H   Hf  HE@,
   EH0]@ UHH Hf  H   Hf  H}
   HEHEE    HM       HM   
   HM      HM   UHuHUf        A=    A=    IDLI   LA       H'f  H   Hf  E      Hf  H   Hf  E    
   HuH5e        =    A=    HDHH   HA       He  H   He  E      He  H   He  E    HFe  
   	   M    @    HEH4H   H4@   7   H=6  HMe  H   H@e  uHE    0  E2   H=6  He  H   He  uHE    /  EHd  H   Hd  HE@,
   EH ]fUHH0Hc  H   Htc  H}H=>4  HEHEHM       HM   
   HM        T/     HuE?Hc        EE=A=HDHH   HA   *   H=~3  Hb  H   Hb   .  E%   H=f3  Hb  H   Hb   .  EHb  H   Hb  HE      EH0]f.     UHHH=4  H50  {d`  1H55  NuzA{dUMM     H5a       H54  8*1A{d     H5a  }     H54  i^1A{d     H5a  N     H54  	1A{d     H5a       H5f4  X1A{d     H5a       H5B4  l41A{db  	   H5a       H5%4  Cq^1A{d3     H5a    m  (  H]fUHwH`      Hq`      H^`      HK`      H8`      H%`      H`      H_      H_      H_      H_      H_      H_      H_      Hz_      Hg_      HT_      HA_      H._      H_      H_      H^      H^      H^      H^      H^      H_      H_      Hp_      H]_      HJ_      H7_      H_      Hq_      H^_      HK_      H8_      H%_      Hr_      H__      HL_      H9_      H&_      H_      H`_      HM_      H:_      H'_      H_      H_      Hf_      HS_      H@_      H-_      H_      H_      H^      H^      H^      H{_      Hh_      HU_      HB_      H/_      H_      H	_      H^      H^      H^      H^      H^      H^      H^      ]fUHH=EH5I(  ]UHH^  H   H^  H^          L9  HE  HEG  Lc~^  OHELHUHHHi  Lc\^  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   H9  H^  H   H^  HMHc]  H2   H8  H]  H   H]  HMHHc]  H**  H8  H]  H   H]  Hco]  H*^(]UHH@H]  H   H]  H}1H]  H   Hr]  HEHEHEm HE  ]     ]  M  H}  M\  E   H]        M   @   HLH4H   H4@   K  H\        m L7  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   H6  HC\  H   H5\  HMHcUH/   H6  H\  H   H\  HMHHcUHH[  H   H[  H[  H   H[  M   MkH[  H   H[  H@]fUHHH\  H   Ht\  }Hj\        MM}   =Z  =Z      A    HDH4H   H4A   n   H\        Z      @    HEH4H   H4@   !   [H[  H   H[  H[  H   H[  H]    UHH0HZ  H   HZ  H}HZ        H}H}E LEI    AI    HOH4H   H4A   )   HQZ  H   HCZ  HEHHHUHZ        H}H    AH    HLH4H   H4A   .   1HY  H   HY  $  1HHUHY        H}H    AH    HDH4H   H4A     HY  H   HY  H;Y     
   } @@@HEH4H   H4@   "  H=D*   !#  H=l*  HuE #  1H5X  1   A   ALUL9AL9MLJ<H   J<AEU   "   HX  H   HX  H}MEHWX        $EE< A< HEH<H   H<A%   H=)  HX  H   HX   )"  EH{X  H   HnX  HjX  H   H]X  H.2  HWX  H   HIX  HMHcV  HH0]@ UHH-X  H   H X  H}H1  HX  H   HX  HMHMHcV  HHUH]fff.     UHH0H!X  H   HX  1HX  H   HX  E %   +HE    HW        H}H'  AH'  HLH4H   H4A   E   HW  H   HW  EHW  H   HW  HEH   HEnH}   H}Z$EY   H}1H=	W        M    A    HEH4H   H4AE   "   HV  H   HV  H}Y  MEHV  
   	   $EE< A< HEH<H   H<A   *   H=&  HV  H   HV   c  E%   H=&  HyV  H   HlV   9  EHcV  H   HVV  H0]     UHHH=&  H5R!  M_   1H50'  hnAM_UM     H5T  L     H5 '  8I1AM_     H5T       H5&   1AM_     H53T       H5&  r~61AM_`     H5T       H5&  XH1AM_1     H5T       H5l&  
1AM_     H5T  a  <  g  H]UHHS      HS      HR      HR      HR      HR      H*S      HS      HS      HR      HR      HR      HR      HR      HR      HR      HlR      HaS      HNS      H;S      H(S      HS      HS      HR      HR      HR      HR      HR      HR      H}R      HjR      HWR      HDR      H1R      HR      HR      HQ      HQ      HR      HwR      HR      HR      HR      H{R      HhR      HUR      HBR      HR      HR      HR      HR      HR      HR      HmR      HZR      HGR      H4R      H!R      HR      HQ      HQ      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH=$    HH=$    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IHz  IK|&I  HHHL  AD./tB3/IHLLL  EL<$H9Q  :Q      1H  2  tL5T"     Q  H=P      1  1  L5'"  uhH-P  H]fffff.     Ht/u   HE  /H=P      1@  |1         =a1  L  HbP  H_P      H\P      HYP      2P  u&1     HH'P  H$P        1   Hl  H=O  f  H5P  HtfD0  1      E1Hf  HHO  H     8H%  HH-O  q  HH5B"  1HH  sO  HxO      HuO      H-vO  1H  t)H H  1H  HH9O  H-:O  1   H  O  H-&O  tbHEH;O  vrH  H  HH  HN  H-N  HN  N  adcgHN  HCHN  t?+adcgHN  HHN  1gHN  adcgHN  HCHN  HSH;nN  v8H  H  H=ON  H  H@N  HAN  HBN  N  H%N  A74H(N  HCHN  t?HKH;N  v2H  H  H=M  H  HM  HM  HM  HM  D,HM  H[A\A]A^A_]  8H#  HH-wM  Z  HH5  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=M   1  T$D$L  u?HM  HCH;L  v+H  H  H=L  H  HL  HL  HL  HL     HL  L{L=L  MtLY  Hl(eL  tfHCH;nL     H  H  H=KL  H  H<L  H=L  H>L  L  ,H-L  HCH"L  u\HL  B,8H	L  HHK  HK  D$HK  HHK     HK  B,8HK  HCHK  HKH;K  vVH  H  H=K  H=  H~K  HK  HK  YK  D$HnK  HCHcK  u^HEK  D$HJK  HCH?K  HKH;,K  v2H  H  H=K  H  HJ  HJ  H K  HJ  T$H-J  H]HJ  EtjJ  u?HEH;J  v2H  H  H=J  HM  HJ  H-J  HJ  HyJ  $H|J  HHqJ  My  L&  HH0J  uKHCAH;5J  v>H  H  H=J  H  HJ  HJ  D=I  HJ  E1HI  ,H-I  HH-I  L  IAtALHH;I  v2H H  H=I  HL  HI  HI  H-I  H-xI  HLL  H-sI  LH-iI  L'  H   H).I  u?L4+L;56I  v2I I  H=I  L  HI  L5	I  H-
I  H-H  1HHn  HH  H[A\A]A^A_]     UAWAVAUATSPIAH=H      L%H  H     L%H  ID$H;H  }  I  I  H=fH  L  HWH  L%XH  HYH  2H    HDH  HCH9H  C,6E1  ;  H[A\A]A^A_]HG  B#ID$HG  E1       BL#Il$H-G    D9  DH  IEtvAN1AtH+HH-G  I   tOHILAVp)f.     Ht+H-\G  HqH4+H}H=IG  H1HHHuL%.G  B#  HG  HHG  C,6jHF  B   HF  HCHF  C,6HKE1H;F  v5H  H  H=F  Hd  HF  HF  E1HF  HF  ,HF  HHF  E  M   Lff.     I] H] I] 5F  u@L%IF  ID$H;5F  v+I  I  H=F  L  HF  L%F  H	F  HE  HHE  HIAu   fff.     Im E  u?HCH;E  v2H  H  H=E  HF  HE  HE  HE  HrE  H,HwE  HHlE  IAuLH[A\A]A^A_]  HF  H8HE  H5x  H,  H8HD  H5  1H[A\A]A^A_]N  fffff.     SH=D     HD  D  tzHD  HCH;D     H  H  H=D  HK  HD  HD  HD  gD     HyD  HKHnD       oHGD  HCHID        LHCH.D  	l  DHKHD     HC     HC  HKHC  HCH;C    H  H  H=C  Hi  HC  HC  HC  C  	   HC  HKHC     uS       HhC     HZC  HHOC  H8C  
	   H:C  HH/C  HC  
    HC  HHC  HB  
    HB  HHB  HB  
HB  HHB  HB      HB  HHB  HB      HB  HHB  H|B      H~B  HHsB  H\B      H^B  HHSB  H<B      H>B  HH3B  HB      HB  HHB  HA     HA  HHA  HA      HA  [HA  	   HA  HKHA  HCH;A  vbH  H  H=A  H9
  HzA  H{A  H|A  UA      HgA  HKH\A     ? H5A      H7A  HKH,A  HCH;A     H  H  H=@  H	  H@  H@  H@  @      H@  HKH@     ZH  H8H@  H5  H  H8Hf@  H5h  1[  Hh@      Hj@  HKH_@  HCH;L@  v]H  H  H=-@  H  H@  H@  H @  ?     H@  HCH @  $ H?     H?  HCH?  HKH;?  v[H  H  H=?  HS  H?  H?  H?  p?      H?  HCHw?   HV?      HX?  HCHM?  HKH;:?  v]H  H  H=?  H  H?  H?  H?  >      H>  HCH>  R H>      H>  HCH>  HKH;>  v]H  H  H=>  HA  H>  H>  H>  ]>      Ho>  HCHd>   HB>      HD>  HCH9>  HKH;&>  v]H  H  H=>  H  H=  H=  H=  =      H=  HCH=  ~ H=      H=  HCH=  HKH;=  v]H  H  H=}=  H-  Hn=  Ho=  Hp=  I=      H[=  HCHP=   H.=      H0=  HCH%=  HKH;=  vZH  H  H=<  H  H<  H<  H<  <      H<  HCH<  u%H<      H<  HCH<  HKH;<  v]H  H  H=l<  H  H]<  H^<  H_<  8<     HJ<  HCH?<  C H<     H<  HCH<  HKH;<  H  H  H=;  H  H;  H;  H;  @ AVSPH=;   N  ;  uIH;  HKH;;  v5H  H  H=o;  H  H`;  Ha;  C;  1HX;  HA;  H
    H5B;  HH57;  H= ;  tH;     {  H=;  ]  sH56;       u4
  8H  L0H:    HH5  1LH  H=:  H5:  @  H:      H:      H={:    =`       H[:      HX:      H=9:  H[A^  ffff.     SH     HH@    H=/:   tH.:  HAH#:  [H:  H:  [f     SH9  fD  1H[Hu[Pffff.     HGH9    H=9  HuH9      H9      Xfff.     SH     HH@    H=9   tH~9  HAHs9  [Hj9  H[9  [f     SHH9  fD  1H[Hu[Pffff.     HGH9  F  H=	9  HuH9      H8      Xfff.     AVSPIHHtA     HH@    H=8   tH8  HAH8  H8  H8  MtA      L0H@    H=n8   tHm8  HAHb8  HY8  HJ8  T8  tH[A^A8  H=1   H=.%   H=H[A^   %   %  %  %  %  %
  %  %  %  %  %  %  %  %  %  %  %   %"  %$  %&  %(  %*  %,  %.  %0  %2  %4  %6  %8  %:  %<  %>    L5  AS%%  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h~  h  h  h  h  h                    	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for: buyCard()
===================
      unittest1.c lowMoney(&state)==-1 notEnoughBuys(&state)==-1 noSupply(&state)==-1 checkCost(&state)==1 checkPhase(&state)==1 checkMultipleBuys(&state)==1 All tests succesful!

 	Running test: insufficient coins.
 	Test succesful.
 	##TEST FAILED##
 	Running test: insufficient buys.
 	Running test: insufficient supply.
 	Test succesful. State properly changed to 1.
 	##TEST FAILED. State phase: %d, proper phase: 1##
 numBuys: %d 	Test succesful. State coins: %d, Proper coins: %d
 	##TEST FAILED. State coins: %d, Proper coins: %d##
 	Test succesful. Initial buys: %d, Buys after two rounds: %d
 	##TEST FAILED. Initial buys: %d, Buys after two rounds: %d##
               /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest1.gcda      main lowMoney notEnoughBuys noSupply checkPhase checkCost         checkMultipleBuys               
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           0       0               H   H        H        P         ` P     W       P  @    P    ! a           zR x         zR x         zR x         zR x  <             ABB B(B0A8A@         \   h               <   |   hh       ABB B(B0A8A@      <             ABB B(B0A8A@            8,	       A  $     Hs       BAA      D  G        A     d          A       D        A          G        A       0        A       0D        A    $     `        BAA                                                
            (    2    <    F    P    Z    d    n    x                                                                    "                           x&    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &     '    '    '    '     '    ('    0'    8'    @'    H'    P'    `(    h(    p(    x(    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (     )                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `#A`1@___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time     _  _mh_execute_header c n kingdomCards i s d updateCoins play handCard buyCard g whoseTurn fullDeckCount endTurn main lowMoney Random P SelectStream GetSeed TestRandom     ompare ardEffect heck    ewGame umHandCards o      nitializeGame sGameOver    huffle upplyCount coreFor  2  rawCard iscardCard  <  D  Card A S GreatHall  J  P  Q      et ainCard  Cost Winners                    dventurer mbassador      mithy teward              Supply tEnoughBuys    Cost Phase MultipleBuys            lantSeeds utSeed               P	mP`P	P
H 
 ` 	 P PP P     d           M   d           X   f W       .          $          $   P         N  P         .  @	        $  @	        $   P          N  P          .  	        $  	        $   @         N  @         .  
        $  
        $            N           .  `        $  `        $            N           .  @        $  @        $            N           .  P"        $  P"        $             N            .  P%        $  P%        $            N           .  @(       $  @(        $             N            .  (       $  (        $   6         N  6         .  _       $  _        $   p         N  p         .  b     &  $  b        $   P          N  P          .  `b     3  $  `b        $   p         N  p         .  i     <  $  i        $            N           .  l     F  $  l        $   `          N  `          .  m     T  $  m        $   P          N  P          .  `m     _  $  `m        $            N           .  @q     n  $  @q        $   p         N  p         .  t     w  $  t        $   P         N  P         .   w       $   w        $   0         N  0         .  0       $  0        $            N           .         $          $            N           .  P       $  P        $             N            .  p       $  p        $             N            .         $          $             N            .  0       $  0        $            N           .         $          $            N           .          $           $   P          N  P          .  p       $  p        $   0         N  0         .       ,  $          $   $         N  $         .       ?  $          $             N         Q  &  @    i  &         &        &        &        &  8      &  H      &  `    
  &  p      &      .  &      @  &       R  &  (     d  &  8     w  &  P       &   !      &  0!      &  !      &  @"      &  $      &  %      &  p&      &  @(    "  &  @1    5  &  1    H  &   2    [  &  2    n  &  `3      &  3      &  3      &  05       d             d             d             f W       .         $          $             N            .       "  $          $   0         N  0         .        ,  $           $   0         N  0         .  P     6  $  P        $             N            .  P     A  $  P        $   @         N  @         .       M  $          $   `         N  `         .       `  $          $   @         N  @         .  0     o  $  0        $            N           .         $          $   0         N  0         .         $          $             N           &  5      &  P6      &  6      &  6      &  6      &  7      &  `7       d             d           -  d           4  f 
W       .          $           $   p         N  p         .  p       $  p        $   0         N  0         .         $          $            N           .         $          $   0         N  0         .         $          $   `          N  `          .  @       $  @        $   P         N  P         .         $          $   P         N  P         .         $          $            N           .         $          $             N            &        &  7      &  7      &  7    ,  &  8    >  &  p8    P  &  9    b  &  09    t  &  p9       d                        p                           0                       $         :         M         _         u                      0                  @              	         +	    0     O	         m	         {	         	    @    	    @    	         	        	        
        $
        (
        9
    8    K
    H    ]
    `    o
    p    
        
        
         
    (     
    8     
    P     
     !        0!        !    (    @"    ;    $    N    %    a    p&    t    @(        @1        1         2        2        `3        3        3        05        5    0    P6    C    6    V    6    i    6    |    7        `7        7        7        7        8        p8        9        09        p9    "    9    ,    9    6    9    C    9    Q     :    b    :    k    :    }    :         :        (:        0:        8:                 p                                     @               '    _     0    (     <    P     G         Z    P     f         o    P     |    @         @q         `m         i         `b         0         @(         
         t         	                           @	     
                   #    l     1         A         Q    P%     [         j    p     v    0          w         `         b         P"         m                                                                             
                                                 '            .            7            =            D            K            S            [            c            k            s            z                                                                                                                                                                                                                                                 @                                                                  /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 unittest1.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest1.o _main _lowMoney _noSupply _checkCost _checkPhase _checkMultipleBuys _notEnoughBuys ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr21 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr21 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _checkCost _checkMultipleBuys _checkPhase _compare _discardCard _drawCard _endTurn _fullDeckCount _gainCard _getCost _getWinners _handCard _initializeGame _isGameOver _kingdomCards _lowMoney _main _newGame _noSupply _notEnoughBuys _numHandCards _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder     File 'dominion.c'
Lines executed:0.00% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
    #####:   12:    return -1;
    #####:   13:  return 0;
    #####:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
    #####:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    #####:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
    #####:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
    #####:  215:    card = floor(Random() * state->deckCount[player]);
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
    #####:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
    #####:  226:  }
        -:  227:
    #####:  228:  return 0;
    #####:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
    #####:  315:  int currentPlayer = whoseTurn(state);
    #####:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
    #####:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
    #####:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
    #####:  532:    for (i = 0; i < state->discardCount[player];i++){
    #####:  533:      state->deck[player][i] = state->discard[player][i];
    #####:  534:      state->discard[player][i] = -1;
    #####:  535:    }
        -:  536:
    #####:  537:    state->deckCount[player] = state->discardCount[player];
    #####:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
    #####:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
    #####:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
    #####:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
    #####:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
    #####:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
    #####:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  562:    state->deckCount[player]--;
    #####:  563:    state->handCount[player]++;//Increment hand count
    #####:  564:  }
        -:  565:
        -:  566:  else{
    #####:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
    #####:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  575:    state->deckCount[player]--;
    #####:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
    #####:  579:  return 0;
    #####:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
    #####:  652:  int currentPlayer = whoseTurn(state);
    #####:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
    #####:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
    #####:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
    #####:  659:  int z = 0;// this is the counter for the temp hand
    #####:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
    #####:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
    #####:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
    #####:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
    #####:  823:      discardCard(handPos, currentPlayer, state, 0);
    #####:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
    #####:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
    #####: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
    #####: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
    #####: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1124:      state->playedCardCount++;
    #####: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
    #####: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
    #####: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
    #####: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
    #####: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
    #####: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
    #####: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
    #####: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
    #####: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
    #####: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
    #####: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
    #####: 1203:	  state->coins += 1;
    #####: 1204:	}
    #####: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
    #####: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
    #####: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
    #####: 1216:  state->coins += bonus;
        -: 1217:
    #####: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
    #####: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
    #####: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
    #####: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
    #####: 1273:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                    __text          __TEXT               :                                 __stubs         __TEXT          J           J                        __stub_helper   __TEXT              Z                                __const         __TEXT          p    @       p                            __cstring       __TEXT              3                                 __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                 0                                 __got           __DATA                                        !           __nl_symbol_ptr __DATA                                      #           __la_symbol_ptr __DATA                                       %           __mod_init_func __DATA          (!           (!            	               __const         __DATA          @!          @!                            __data          __DATA          "          "                            __bss           __DATA          *                                           H   __LINKEDIT       P     @       0     02                    "  0    0    0 @           H0   02 (        5   Q       P       V  V  )     $                           O F                             /usr/lib/dyld             O<("1'1$       
  
 *              (                      8         
   /usr/lib/libSystem.B.dylib      &      X5 p   )      5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     UHH H   H H}HuH       H}H}LELELMA	LMED9AD9HOH4H   H4A       Hr H   He E      H:       H}H}DD9AD9HLH4H   H4A       H H   H E   H H   H E    H H   H E]ffffff.     UHHH H   H f  H H   H   HEHEH]D  UHAWAVSHXE(DU D]]L5v I   L5h ]DMDEMUuEDUD]}(   H@ H   H2 EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D}9  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPHa H   HT UHu}HM   EEHMHMUUHuHu  Hc}  H       E=   A=   HOH<H   H<AJ   H       M   @   HLH4H   H4@       H H   H Ej  H H   H MHEE    H?       M
   @
   HLH4H   H4@     H= H   H0 E    H    
   M
   @
   HLH4H   H4@      H       M}9A9HEH4H   H4A   y   HK       Hc}LEAHc}LEED9AD9HDH4H   H4A       Hr H   He E  HZ H   HM HN H   HA M   MH1 H   H$ H% H   H M   M!H`       M   @   HDH4H   H4@   $   H H   H HE@
      H       M   @   HDH4H   H4@   $   Hx H   Hk HE@      H\ H   HO HE@   HE H   H8 HQ       M   @   HDH4H   H4@   :   H H   H HE@   HE@   HE@   5   H H   H HE@   HE@   HE@   <   H H   H iU   )HMAHMA(   HMA   E   HQ #   "   M   @   HNH4H   H4@     H' H   H E    H &   %   M
   @
   HLH4H   H4@   <  H (   '   Hc}LEADMD9AD9HDH4H   H4A     HQ *   )   Hc}LEA   A   HDH4H   H4AS   H ,   +   Hc}LEA
   A
   HDH4H   H4A      H .   -   M   @   HDH4H   H4@   )   H H   H HcEHMD   $   H H   H HcEHMD   H H   H $   H H   H HcEHMD
   Ht H   Hg ]   Hc H   HV HcEHMDHG H   H: H; H   H. M   MzH H   H H H   H M   MH H   H E    H ;   :   M}9A9HLH4H   H4A     H H   H HcEHM?      E    H >   =   M   @   HLH4H   H4@   y   HM H   H@ HcEHcMHUHH   Hi  H   HcEHM?     ?  H H   H M   M=H H   H E   H
 C   B   M
   @
   HLH4H   H4@   y   H H   H HcEHcMHUHH   Hi  H   HcEHM?     ?  HK H   H> M   M=H. H   H! H" H   H M   MH H   H E    H	 J   I   M}9A9HLH4H   H4A      }Hu  H5Y	 L   K   =    A=    HLHH   HA       H| H   Ho E  Hd H   HW HX H   HK M   MH; H   H. E    H R   Q   M}9A9HLH4H   H4A   _   H
 H   H
 HcEHM8       HcEHM^      H
 H   H
 M   M\H
 H   H
 E    H W   V   M   @   HNH4H   H4@   I   HW
 H   HJ
 HcEHMDp    H;
 H   H.
 M   MmH
 H   H
 HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    H \   [   M   @   HLH4H   H4@   O   Hc	 H   HV	 HE   Hu[  EHA	 H   H4	 M   Mg1H"	 H   H	 HE   Hu	  E    EH H   H EHP] UHH  Hn  H HEH H   H  HH        HH    LcLG?  A   AA   HLH4H   H4A   #   HD H   H7      HH5 H   H5 HcHHH   Hi  HHcLIc?    H       HcLA?      A    HOH4H   H4A     H H   Hz   HcH*?  Y'  ,HcHcHHH   Hi  HHc    H 	      HcLE?  A   D9AD9HLH4H   H4A      H H   H    HcHcHHH   Hi  HHcHcHHH   Hi  HH= H   H0    H H   H HcH?  ?  H H   H     Ha       9A9HLH4H   H4A      H H   H Hc HcHcHHH   Hi  HHcH?     ?  H1 H   H$    H H   H     H  H H   H H H;E   H  ]  fffff.     UHH@H H   Ht }HuHf       MMH}H}LcELMG?  A    AA    HNH4H   H4A     H H   H
 E    H
       MHc}LEE^  D9AD9HLH4H   H4A      H
 H   H
 HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HHP
 H   HC
 M   MHcEHM^  HcEHM?  HcEHM^      }HuMH	 	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H~	 H   Hq	 El  Hf	 H   HY	 M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      H H   H HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   H% H   H E    H H   H EH@]fff.     UHH H   H Hu}UH H   H MMHEHEUUHu       E    HJ       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H H   H HE         Q  H_       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H? H   H2 HE            H    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   H H   H HE         H H   H H H   H H H   Hy Hz H   Hm M   M1H[ H   HM UHM      ]UHAVSHPH  H   H  MUu}LEHj        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H  H   H  E  H        H}      A   HLH4H   H4A       H  H   H  E  }Hu  H5P        EE=   A=   HLHH   HAJ   H
  
   	   M   @   HOH4H   H4@       H  H   H  E   HE}uUMLEDMH$V  L     A   A=    =    MLOI   O       H  H   H  EJ   H  H   H  HE      HE   HuUAE    EHP  H   HC  EHP[A^]    UHH H  H   H  }HuH  H   H  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL	  MLUL; I   L- HDL HHDDLLHC  H=    A   A   L  L]        LA   99MONI   N      H  H   H     {      H|o4  H4  HHcHH=<  H  H   Hq  HT H   HG H^  =4  H=  H4  H   HFq  H H   H     H!          @   HLH4H   H4@   W   H H   H HxH H   H    \Hu H   Hh H             HF  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   H  H   H  HtH  H   H  H  H   H     1Hu  H   Hh  HHa      p1  H=  H  H   Hn  H   H   H      H  *   )   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHH   Hi  H4HcHcHcHH   Hi  HHM  H   H@         H%  H   H  H   lH  /   .      @   HDH4H   H4@   l  H3  H5(  1   0   =    A=    HNHH   HA      Hs  H   Hf     H   h2  H  4   3   Ah9A9ILLI   LA   -   H=  H  H   H     d>   1H  H   H  H9      `H  H   H  H  H   H  GH  H   H      H  ;   :   HcLE8   D9AD9HNH4H   H4A      H3  H   H&  HcHcHcHH   Hi  HHcH  H   H     H  H   H      -  H=<  H  H    Hj  H  H   Hw  K-  H=  HB  H(   HTj  HM  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   H  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   H`  H   HS  +  H  F   E       @   HOH4H   H4@M   H  H   G        @    HLH4H   H4@   #   H  H   H  G+  HcHcHH   Hi  H<~.      \h.  H!  K   J   \9A9HOH4H   H4A   #   H<  H   H/  *     H  H   H   H?5  1HXY      THX  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H
  HX  P?   H  H   H  H  H   H     H  H   H      (  H=  H  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5_  W   V   AL9A9IOLI   LA   #   H  H   H  '  1H  H   H   H2  1HHV      DH  [   Z   HcLE8   D9AD9HLH4H   H4A      H;  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HU  @?   H  H   H{  H|  H   Ho     HY  H   HL      &  H=  H  H8   Hc  H"  H   H  HCX  %  H=u  H  H@   Hb  H  H   H  H1H      H   H<T      8,%  H=  H#  HH   H5b  H.  e   d   H             A    HOHH   HA     H  H   H         H  h   g       @    HEH4H   H4@     HS  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  H:  H   H-  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  H2  m   l   HcLE8   D9AD9HLH4H   H4A      HE  H   H8     HcHcHH   Hi  HHcHcHH   Hi  HH  H   H     
H  H   H  HcHHc8   HcHH   Hi  HHcH8   8         H  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5M  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5  v   Au   A=    A=    MDNI   NA   &   H6  H   H)  H5  0H  H   H  H  H   H      &   H  H   H     H  H   H  H  H   H  .H  H   H  .     H"  H5     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5     A   A=    A=    MDNI   NA   &   H  H   H  HL4  (H  H   H  H  H   H  H  H   H      F  H=  H=  HP   HO[  Hx  H   Hk  HQ    H=  H  HX   H[  1H         HL  H     A   A    A    MENI   NA$   9   H  H   H  H      H     H:             @    HEH4H   H4@   ^  HM  H   H@  Hd*  H=        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH  H   H      H1           @   HLH4H   H4@   W   H|  H   Ho  HHX  H   HK     \H5  H   H(      Ho        HDD9AD9HLH4H   H4A   {  H        9A9HEH4H   H4A     H        HcLA8      A   HOH4H   H4A     HV  H   HI  Hb        HcLA8       A    HOH4H   H4A   9   1H  H   H  HI  jH  H   H      H           @   HLH4H   H4@   W   Hy  H   Hl  HbHU  H   HH     \H2  H   H%  H&  H   H  H  H   H  H  H   H     4H  H   H  H  H   H  H  H   H      :  H=  H1  H`   HCU  H  H   H  H DL    H=  H  Hh   HT  H        HcLA^  HcLA?     A   HNHH   HA     Hi        HcLA?      A    HOH4H   H4A   ~   H  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?    H        HcLA^      A    HOH4H   H4A   ~   H  H   H  HcH^     HcHcHH?  Hi  HUHcH^  ^     H[  H   HN  HO  H   HB  HC  H   H6  ~  Hr        HcLA?      A    HDH4H   H4A     H  H   H      H        HcLE^  D9AD9HLH4H   H4A     H  H   Hu  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  H  H   H     H  H   H  HHl  H   H_  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   H  H   H  MHHcf  H^  Hf     f  EH|  H   Ho      H>           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4AR   HW        HcL   A   HDH4H   H4A   2   Hm  H   H`  H           H        HcL   A   HDH4H   H4A9  H        HcL   A   HDH4H   H4A   H9        HcL   A   HDH4H   H4A   H        HcL
   A
   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   I   H  H   H   HNH64   H  H   H  H      H   H  H   H  H  H   H  H  H   H{     ?He  H   HX      <  H=  H3  Hp   HEJ  H.  H   H!  H C    H=  H  Hx   HI     H  H   H  H    H        HDD9AD9HLH4H   H4A   2  HY        9A9HEH4H   H4A     H.  H   H!      H        HcLE8   D9AD9HLH4H   H4A     H        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1Hh  H   H[  H+:   o  H        HcLE8   D9AD9HDH4H   H4A      H  H   H      Hn        HcLE8   D9AD9HLH4H   H4A   ?   H  H   H|  H}  H   Hp     dHZ  H   HM  ?   HI  H   H<  H=  H   H0     H  H   H  H  H   H  H  H   H     }1H  H   H  H08        H=x  H  H   HE  H        H      H   HcLALAHDHH   HA   #   H  H   H       H  H   H  HcHtp   tpH7        H=]  H  H   HD  1H  H   H~  H         H6      3  H=  H*  H   H<D  H5        H             A    HEHH   HA   x   H  H   H  H   H	     H   H5  1HU  H   HH  H`5        H=  H  H   HB  H   H   H      H      HDD9AD9HLH4H   H4A     H      9A9HEH4H   H4A   &  Hn  H   Ha  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    HP  H   HC  HD  H   H7     H!  H   H        H=J  H  H   H@  H  H   H      Hr      HcLE8   D9AD9HLH4H   H4A      H      HcLcLI   Mi  MA   A   HDH4H   H4A   p   H      9A9HEH4H   H4A   %   H  H   H  ?   H  H   H  H  H   H     H      @HOH4H   H4@   5     HS  H   HF  H0     H0      HD         @   HLH4H   H4@   a         H  H   H  H~  H  H   H     RHn  H   Ha     U   HS  H   HF  2   H=  H5)  D=  H5%  H   H5  H  H  H   H  H H;E   H(	  []   )v)hmyw     UHH0H  H   H  }HuH        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       H]  H   HP  E  }Hu  H5        =   A=   HLHH   HA       H  H   H  E*  HE   }M  H        AM9A9ILLI   LA       H  H   H  E   1H  H   H}  HE      }HuM`  Hu   }EM   M)Hu   Hu      H%  H   H  H  H   H  H  H   H   E    H  H   H  EH0]@ UHH  H   H  }HuH  H   H  MMHEHEHcUHuD]UHH H  H   H  }'      EEMHHHUHuh  H  HMHcHH=  HU  H   HG9  HX  H   HK  E    G  H=  H  H   H9  H$  H   H  E     H=t  H  H   H8  H  H   H  E     H=8  H  H    H8  H  H   H  E     H=  He  H(   HW8  H  H   H{  E    W  H=  H)  H0   H8  HT  H   HG  E     H=  H  H8   H7  H   H   H  E     H=H  H  H@   H7  H  H   H  E     H=  Hu  HH   Hg7  H  H   H  E   g  H=  H9  HP   H+7  H  H   Hw  E   +  H=  H  HX   H6  HP  H   HC  E     H=X  H  H`   H6  H  H   H  E     H=  H  Hh   Hw6  H  H   H  E   w  H=  HI  Hp   H;6  H  H   H  E   ;  H=  H  Hx   H5  H  H   Hs  E     H=h  H  H   H5  HL  H   H?  E     H=,  H  H   H5  H  H   H  E     H=  HY  H   HK5  H  H   H  E   K  H=  H  H   H5  H  H   H  E     H=x  H  H   H4  H|  H   Ho  E     H=<  H  H   H4  HH  H   H;  E     H=   Hi  H   H[4  H  H   H  E   [  H=  H-  H   H4  H  H   H  E     H=  H  H   H3  H  H   H  E      H=L  H  H   H3  Hx  H   Hk  E      H=  Hy  H   Hk3  HD  H   H7  E   k   H=  H=  H   H/3  H  H   H  E   /   H=  H5  2  H5  H   H5  EH  H   H  EH ] ]M=y-iYI9u@ UHH0H  H   H  UHu}MEEHMHMUUuu}HuHj        A=   A=   ILLI   LA       H<  H   H/  E   H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  HV        M   @   HDH4H   H4@   d   HT  H   HG  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  H  H   H  H  H   H  HcEHMTTE    Hl  H   H_  EH0]fffff.     UHHH9  H   H,  H}H)  H   H  HEHEH}   HcHM8   H]    UHH  H   H  H}H  H   H  HEHEHM   ]fff.     UHH  H   H  u}HUH  H   H  MMUUHEHEE    E    Hq        MHc}LEE?  D9AD9HLH4H   H4A      H        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    HC     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A      H        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E]UHH0H  H   H  H}H  H   H  HEHEH}EE    Hz        MHc}LEE8   D9AD9HLH4H   H4A      HF  H   H9  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HH  H   H  M   MHi        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   HC  H   H6  M   HE   "   H  H   H  HE       H  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    H,        M   @   HLH4H   H4@   O   HJ  H   H=  HE   HuEH(  H   H  M   Mg1H	  H   H  HE   Hu1EH0]@ UHH  H   H  H}H        H}H}LEAH    A    HDH4H   H4A       H~  H   Hq  E     Hf  H   HY  E    E    H$        M   @   HLH4H   H4@      H        Hc}LEAL    A    HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   M	H-        M   @   HMH4H   H4@       HS  H   HF  E      H;  H   H.  E    H(  H   H  E]fD  UHH@H  H   H  }HuH  H   H  MMHEHEE    E    H        MHc}LEE8   D9AD9HLH4H   H4A     Hr        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       H:  H   H-  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MHb     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       HZ  H   HM  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MHR        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A     H        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MHr  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H"  H   H  M   MH  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MHb  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       HB  H   H5  M   MH  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+Hy  H   Hl  E    H  1   0   MHc}LEE^  D9AD9HLH4H   H4A     H  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH
  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       HZ  H   HM  M   MH  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MHr  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMHj  H   H]  H^  H   HQ  M   M+HA  H   H4  EH@]ff.     UHH0H!  H   H  H}HuH  H   H   HEHEHMHME    H        M   @   HLH4H   H4@      H        MH}DD9AD9HMH4H   H4A   (   Hu  H   Hh  HcEHM+   HU  H   HH  }HuHcuHMH2  H   H%  H&  H   H  M   MH	  H   H  E    E    H        M   @   HLH4H   H4@      HM        Hc}LEAHc}LEED9AD9HOH4H   H4A      Hl  H   H_  MMHZ  H   HM  HN  H   HA  M   M
H1  H   H$  HcEHMUH}-EE    Hl        M   @   HLH4H   H4@      H"        Hc}LEADMD9AD9HDH4H   H4A   m   H        M}9A9HOH4H   H4A   (   HT  H   HG  HcEHM   H4  H   H'  H(  H   H  M   MH  H   H  E    E    H	        M   @   HLH4H   H4@      H         Hc}LEAHc}LEED9AD9HOH4H   H4A      Hn  H   Ha  MMH\  H   HO  HP  H   HC  M   M
H3  H   H&  HcEHMUE    H  &   %   M   @   HLH4H   H4@      H  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   H  H   H  HcEHM   #   Hw  H   Hj  HcEHM    H\  H   HO  HP  H   HC  M   M1H1  H   H#  H0]D  UHH   H  H HEH  H   H  HH  H   H  HHH       HT           @   HLH4H   H4@     H        HcLA?     A   HLH4H   H4A   ,   H  H   H  H[H#H=}  HcH8      HcHcLI   Hi  IA 6{  H        A   A   IDLI   LA   H  
   	      @   HDH4H   H4@M   Ht           @   HDH4H   H4@   +   H  H   H     \   Hl  H   H_  Hc HcH8   8      H  H   H  3H  H   H  Hs               @    HMH4H   H4@      H  H   H     Hc HcH^     ^  HcHcLI?  Hi  IA   "1H3  H   H&  H.   H  HH;U   1H   ]w  @ UHH  H   H  HUu}MH        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   HS  H   HF  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  H        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   H  H   H~  HcEHM8   8   \  H&        Hc}LEA8      A   HDH4H   H4A   5   H  H   H
  HcEHM8   8      H  H   H  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   H6  H   H)  1H(  H   H  ]     UHH0H  H   H  H}uH  H   H  HEHEMMH}REE    Hq        M   @   HLH4H   H4@   H   HG  H   H:  }HuEH,  H   H  M   Mn1H  H   H   }uHU1EH0]@ UHH0H  H   H  H}uH  H   H  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPH  H   H  MUuH}DEHEHEMMUUuu}}H}H=     A   AEE=   A=   MDNI   NA   7   HN  H   HA  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   H  H   H  HE      HE   <   1H  H   H  }uHU1}uHUEEH  H   Hy     Hu  H   Hh  }uHUQ1EHP]@ UHHPHq  H   Hd  UuH}MHEHEMMUUuuH}H=-     A   AEE    E=   A=   MONI   NAJ   H        M    @    HLH4H   H4@       H  H   H  E  Ht        M}9A9HDH4H   H4A       Ho  H   Hb  E{  HW  H   HJ  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  H        M}9A9HEH4H   H4A      H[        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       HA  H   H4  M   MH)  H   H  H  H   H  M   MdHX        M}9A9HLH4H   H4A       H  H   H  E_  H  H   H  MHcEHULLE    H        MH}DD9AD9HLH4H   H4A      Hz        M}9A9HEH4H   H4A   E   1H  H   H  HcEHcMHuH   Hi  H<HuM:EH  H   H  H  H   H  M   M1H  H   H  }uHUYE    EH  "   !   M}9A9HLH4H   H4A     H[  H   HN  E    H(  %   $   MHc}LEE8   D9AD9HLH4H   H4A      H  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      H  H   H  }uHUE9   Hi  H   H\  H]  H   HP  M   MH@  H   H3  H4  H   H'  M   M'H  H   H
  E    H  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=Al  H5l  V0O  1H5l  /AVUMT  	   H5  |X     H5Ul  [H1AVS     H5*  MX     H5.l  1AVS     H5  X     H5l  VI1AVS  a   H5  W     H5k  ;|1AVaS     H5  W     H5k  ] t1AV2S     H5F  W     H5k  T1AVS     H5  bW     H5xk  w1AVR     H5  3W     H5Vk  YAr1AVR     H5  W  	   H50k  j1AVvR     H5  V  
   H5k  a'Hr1AVGR     H5  V     H5j  @1AVR     H5<  wV     H5j  -1AVQ     H5  HV     H5j  "mw1AVQ     H5n  V     H5|j  |1AVQ  G   H5  U     H5Vj  b1AV\Q  .   H5  U     H52j  W71AV-Q     H5!  U     H5j  `1AVP  :   H5r  ]U     H5i  eW1AVP    H5  .U     H5i  Qw1AVP     H5  T     H5i  :/T1AVqP     H5%  T     H5xi  r%1AVBP     H5f  T     H5Ui  Ba1AVP     H5  rT     H55i  PR1AVO     H5H  CT     H5i  Ce&1AVO     H5Q  T     H5h  #e,1AVO  /   H5:  S     H5h  Ql1AVWO  
   H5  S  W  `  H]fD  UHH\}      HI}      H6}      H#}      H}      H|      H|      H|      H|      H	}      H|      H}      H|      H~      H~      H~      H~      H~      H~      H~      Hp~      H]~      HJ~      H7~      H$~      H~      H}      H}      H}      H}      H}      H}      H}      Hy}      Hf}      HS}      H@}      H-}      H}      H}      H|      H|      H|      H|      H|      H|      H|      Ho|      H\|      HI|      H6|      H#|      H|      H{      H{      H{      H{      H{      H{      H{      Hx{      He{      HR{      H?{      H,{      H{      H{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hnz      H[z      HHz      H=}      H*}      H}      H}      H|      H|      H|      H|      H|      H|      H|      Hl|      HY|      HF|      H3|      H |      H|      H{      H{      H{      H{      H{      H{      H{      Hu{      Hb{      HO{      H<{      H){      H{      H{      Hz      Hz      Hz|      Hg|      HT|      HA|      H.|      H|      H|      H{      H{      H{      H{      H{      H{      H{      Hp{      H]{      HJ{      H7{      H${      H{      H&|      H|      H |      H{      H{      H{      H{      H{      H{      H{{      Hh{      HU{      HB{      H/{      H{      H	{      Hz      H{      H{      H{      H{      H{      H{      Hy{      Hf{      HS{      H@{      H-{      H{      H{      Hz      Hz      HV{      HC{      HP{      H={      HJ{      H7{      H|      H{      H{      H{      H{      H{      H{      H{      Ht{      Ha{      HN{      H;{      H({      H{      H{      Hz      Hz      Hz      Hz      Hz      Hz      H}z      Hjz      HWz      HDz      H1z      Hz      Hz      Hh{      HU{      HB{      H/{      H{      H	{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hqz      H^z      HKz      H@{      H-{      H{      H{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hoz      H\z      HIz      H6z      H#z      Hz      H|      Hz|      Hg|      HT|      HA|      H.|      H|      H|      H{      H{      H{      H{      H{      H{      H{      Hp{      H]{      HJ{      H7{      H${      H{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hyz      Hfz      HSz      H@z      H-z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hoy      H\y      HIy      H6y      H#y      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hxx      Hex      HRx      H?x      H,x      Hx      Hx      Hw      Hw      Hz      Hy      Hy      Hy      Hy      Hy      Hy      H0{      H{      H
{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hrz      H_z      HLz      H9z      H&z      Hz      H z      Hy      Hy      Hy      Hy      Hy      Hy      H{y      Hhy      HUy      HBy      H/y      Hy      H	y      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hqx      H^x      HKx      H8x      H%x      Hx      Hw      Hw      Hw      Hy      Hy      Hy      Huy      Hby      HOy      H<y      H)y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hz      Hz      Hz      Hz      Hz      Hz      Hoz      H\z      HIz      H6z      H#z      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hxy      Hey      HRy      H?y      H,y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hnx      H[x      HHx      H5x      H"x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hww      Hdw      HQw      H>w      H+w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hcz      HPz      H=z      H*z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hly      HYy      HFy      H3y      H y      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hux      Hbx      HOx      H<x      H)x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      H~w      Hkw      HXw      HEw      H2w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Htv      Hav      HNv      H;v      H(v      Hv      Hv      Hu      Hu      Hu      Hu      Hy      Hy      H}y      Hjy      HWy      HDy      H1y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hsx      H`x      HMx      H:x      H'x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      H|w      Hiw      HVw      HCw      H0w      Hw      H
w      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hrv      H_v      HLv      H9v      H&v      Hv      H v      Hu      Hu      Hu      Hu      Hu      Hu      H{u      Hhu      HUu      HBu      H/u      Hu      H	u      Ht      Hx      Hx      Hx      Hx      Hx      Hx      Hqx      H^x      HKx      H8x      H%x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hzw      Hgw      HTw      HAw      H.w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hpv      H]v      HJv      H7v      H$v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hyu      Hfu      HSu      H@u      H-u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hot      H\t      HIt      H6t      H#x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hxw      Hew      HRw      H?w      H,w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hnv      H[v      HHv      H5v      H"v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hwu      Hdu      HQu      H>u      H+u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hmt      HZt      HGt      H4t      H!t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hvs      H[v      HHv      H5v      H"v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hwu      Hdu      HQu      H>u      H+u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hmt      HZt      HGt      H4t      H!t      Hvu      Hcu      HPu      H=u      H*u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      H_u      HLu      H9u      H&u      Hu      H u      Ht      Ht      Ht      Ht      Ht      Ht      H{t      Hht      HUu      HBu      H/u      Hu      H	u      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hqt      H^t      HKt      H8t      H%t      Ht      H7u      H$u      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hyt      Hft      HSt      H@t      H-t      Ht      Ht      Hs      Hs      Hs      Hs      Ht      H}t      Hjt      HWt      HDt      H1t      Ht      HSt      H@t      Hu      Hu      Hu      Hu      Hqu      H^u      HKu      H8u      H%u      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hzt      Hgt      HTt      HAt      H.t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hps      H]s      HJs      H7s      H$s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hyr      Hfr      HSr      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hxs      Hes      ] UHH=H5?  ]UHHg  HM  H HEHps  H   Hcs  1H`s  H   HRs  E    @  @  H=D  1f  HHB  A(   ELUEJ  HLHHLH@  HHH?  H @  E   Hr        M   @   HNH4H   H4@     H=pC  u ?     HHuUCHE  Hr        =   AAAALcI    AI    HEH<H   H<A      H=E  H5B  1   HB  g>  Hq  H   Hq     HHu1f  ILHH>  UHHBHHuE2  Hq  	      =   AAAALcI    AI    HEH<H   H<A      H=D  H5A  4   HB  l=  Hp  H   Hp     HHu1f  ILHH=  UHHAHE  H$p        =   AAAALcI    AI    HEH<H   H<A      H=C  H5@  7   H:A  u<  Hp  H   Hp     HHu1f  ILHH<  UHH@HHuE  H)o        =   AAAALcI    AI    HEH<H   H<A      H=B  H5@  :   H[@  z;  HAo  H   H4o     HHu1f  ILHxHp;  UHxHp?HHuE  H.n        =   AAAALcI    AI    HEH<H   H<A      H=A  H5?  =   H?  :  Hfn  H   HYn  HZn  H   HMn  HNn  H   HAn  M   MH=X?  H*n  H   Hn   :  H=G  H?H;}l   1Hg  ]9  fff.     UHH0Hm  H   Hm  H}H=>  HEHE .:  H}G    H}G    H}G    H}EH=m        EE=    A=    HEH4H   H4A   *   H=>  HLm  H   H?m   9  E%   H=i>  H*m  H   Hm   j9  EHm  H   Hm  EH0]fD  UHH@Hl  H   Hl  H}HuH=>  Hl  H   Hl  HEHEHMHM 8  E    EHl        M
   @
   HLH4H   H4@   Q   Hol  H   Hbl  HcEHMHcHMD    HKl  H   H>l  M   MeH}<H=k        EE=    A=    HEH4H   H4A   *   H=<  Hk  H   Hk   7  E%   H=<  Hk  H   Hk   7  EHk  H   Hk  EH@]D  UHH0Hk  H   Hk  H}H=l<  HEHE N7  H}G    H}E3H=Lk        EE=    A=    HEH4H   H4A   *   H=;  Hk  H   Hk   6  E%   H=;  Hj  H   Hj   6  EHj  H   Hj  EH0]fff.     UHH`Hj  H   Hj  H}HuHEHEHMHMG  H=x;  HEHEUHEPUHEPUHcEHMUHcEHMUHcEHMUHcEHMD    HcEHMD    HcEHMD    uUM 5  H}EH=i     A   AEE=    A=    MENI   NA   *   H=:  Hi  H   Hi   .5  E%   H=:  Hi  H   Hwi   5  EHni  H   Hai  EH`]UHH   HNi  H   HAi  H}HuHEHEHMHM  H=:  HEHEUHEPUHEPUHcEHM   UHcEHMUHcEHMU I4  H}E9Hh        EE=    A=    HEH4H   H4A*   H=8  H}h  H   Hph   3  E1   H=8  H[h  H   HNh   3  E    E  H=%9  u 3  uH}wH}EqH=g        EE=    A=    HEHH   HA*   H=7  Hg  H   Hg   3  E1   H=7  Hg  H   Hg   2  E    E  H=8  u 2  Hc}HMD    H}EHg  
   	   EE=    A=    HEHH   HA*   H=,7  H'g  H   Hg   ?2  E1   H=7  Hg  H   Hf   2  E    E   H=7  uU 1  Hc}HMD    H}EHKf        AEE=    A=    IELI   LA*   H=Z6  Huf  H   Hhf   m1  E1   H=B6  HSf  H   HFf   C1  E    E   H1f  H   H$f  E   Hf  H   Hf  EH   ]D  UHH H>  H HEHe  H   He  He  H   He  0  
   UHe  H   He  0  
   UHe        M}9A9HDH4H   H4AHe  H   Hre  Hse  H   Hfe  !0  
   UHe        UDED9AD9HDH<H   H<AE    He  H   He  M;MUEHd     
   HEH<H   H<?H<  HMHd  H   Hd  H H;EHM
   HEH ].  f     UHHH=15  H5r1    1H5u5  %{CAUM     H5a  \     H5C5  LF71A     H52b  -     H5"5  61A     H53b       H55  mJ 1Ap     H5db       H54  xj1AA     H5eb       H54  gF1A     H5fb  q     H54  N^91A     H5b  B     H)  H]fUHwHa      H`      H`      H`      H`      H`      H`      H`      Ht`      Ha`      HN`      H;`      H(`      H`      H`      H_      H_      H_      H_      H_      H_      H}_      Hj_      HW_      HD_      H1_      H_      H`      H`      H_      H_      H_      H_      H1`      H`      H`      H_      H_      H_      H_      H_      H_      H_      Hs_      H_      H_      H_      H_      H_      H_      H_      H_      H_      H_      H_      H_      H4`      H!`      H`      H_      H_      H_      H_      H_      H_      H_      Hv_      Hc_      HP_      H=_      H*_      H_      H_      H^      H^      H_      H_      H_      H_      H_      Ht_      Ha_      HN_      H;_      H(_      H_      H_      H^      ]ffff.     UHH=H5I(  ]UHH5_  H   H(_  H!_          Lu9  HE  HEG  Lc^  OHELHUHHHi  Lc^  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   H8  Hv^  H   Hh^  HMHc5^  H2   H8  HN^  H   H@^  HMHHc]  H:*  Hk8  H^  H   H^  Hc]  H*^(]UHH@H]  H   H]  H}1H]  H   H]  HEHEHEm HE  l]     b]  M  H}  MH]  E   Hz]        M   @   HLH4H   H4@   K  H0]        m LT7  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   H6  H\  H   H\  HMHcUH/   H6  H~\  H   Hp\  HMHHcUHH^\  H   HQ\  HR\  H   HE\  M   MkH5\  H   H(\  H@]fUHHH\  H   H\  }H\        MM}   =G[  =E[      A    HDH4H   H4A   n   Hh\        Z      @    HEH4H   H4@   !   [H<\  H   H.\  H*\  H   H\  H]    UHH0H[  H   H[  H}HZ        H}H}E LEI    AI    HOH4H   H4A   )   HZ  H   HZ  HEHHHUHwZ        H}H    AH    HLH4H   H4A   .   1HVZ  H   HHZ  $  1HHUHY        H}H    AH    HDH4H   H4A     HY  H   HY  HY     
   } @@@HEH4H   H4@   "  H=*   !#  H=<*  HuE $#  1H5-Y  1   A   ALUL9AL9MLJ<H   J<AEU   "   HLY  H   H?Y  H}MEHX        $EE< A< HEH<H   H<A%   H=j)  HX  H   HX   )"  EHX  H   HX  HX  H   HX  H1  HX  H   HX  HMHc^W  HH0]@ UHHX  H   HX  H}H1  HvX  H   HhX  HMHMHc	W  HHUH]fff.     UHH0HX  H   HtX  1HsX  H   HfX  E %   +HE    H<X        H}H'  AH'  HLH4H   H4A   E   HX  H   HX  EHW  H   HW  HEH   HEnH}   H}Z$EY   H}1H=iW        M    A    HEH4H   H4AE   "   H[W  H   HNW  H}Y  MEHV  
   	   $EE< A< HEH<H   H<A   *   H=&  HV  H   HV   c  E%   H=&  HV  H   HV   9  EHV  H   HV  H0]     UHHH=&  H5b!  M_   1H5 '  hnAM_UM     H5aT  L     H5&  8I1AM_     H5bT       H5&   1AM_     H5T       H5&  r~61AM_`     H5U       H5^&  XH1AM_1     H5T       H5<&  
1AM_     H5U  a  <  g  H]UHHtS      HaS      HNS      H;S      H(S      HS      HS      HwS      HdS      HQS      H>S      H+S      HS      HS      HR      HR      HR      HS      HS      HS      HS      HuS      HbS      HOS      H<S      H)S      HS      HS      HR      HR      HR      HR      HR      HR      H~R      HkR      HXR      HER      HR      HR      HS      HS      HR      HR      HR      HR      HR      H?S      H,S      HS      HS      HR      HR      HR      HR      HR      HR      HR      HnR      H[R      HHR      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH=$    HH=$    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IH  IK|&I  HHHL  AD./tB3/IHLLL  EL<$HQ  Q      1H  1  tL5$"     mQ  H=^Q      1  1  L5!  uhH-4Q  H]fffff.     Ht/u   HE  /H=P      1@  L1         =11  L  HP  HP      HP      HP      P  u&1     HHP  HP        1   Hl  H=YP  f  HP  HtfD0  1      E1Hf  HH(P  H     8H%  HH-O  w  HH5"  1HH  O  HO      HO      H-O  1H  t)H H  1H  HHO  H-O  1   H  mO  H-O  tbHEH;oO  vrH  H  HH  HEO  H-FO  HGO   O  adcgH2O  HCH'O  t?+adcgHO  HHO  1gHN  adcgHN  HCHN  HSH;N  v8H  H  H=N  H  HN  HN  HN  |N  HN  A74HN  HCH}N  t?HKH;eN  v2H  H  H=FN  H  H7N  H8N  H9N  H"N  D,H&N  H[A\A]A^A_]  8Hy#  HH-M  `  HH5  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=nM   1  T$D$NM  u?HbM  HCH;OM  v+H  H  H=0M  H  H!M  H"M  H M  H	M     HM  L{L= M  MtL_  Hl(L  tfHCH;L     H  H  H=L  H  HL  HL  HL  wL  ,HL  HCHL  u\HdL  B,8HiL  HH^L  HGL  D$HLL  HHAL     H%L  B,8H*L  HCHL  HKH;L  vVH  H  H=K  HC  HK  HK  HK  K  D$HK  HCHK  u^HK  D$HK  HCHK  HKH;K  v2H  H  H=mK  H  H^K  H_K  H`K  HIK  T$H-KK  H]H@K  EtjK  u?HEH;K  v2H  H  H=J  HS  HJ  H-J  HJ  HJ  $HJ  HHJ  My  L,  HHJ  uKHCAH;J  v>H  H  H=vJ  H  HgJ  HhJ  D=IJ  HbJ  E1HFJ  ,H-LJ  HH-AJ  L  IAtALHH;J  v2H H  H=I  HR  HI  HI  H-I  H-I  HLL  H-I  LH-I  L-  H   H)I  u?L4+L;5I  v2I I  H=wI  L  HhI  L5iI  H-jI  H-SI  1HHn  HOI  H[A\A]A^A_]     UAWAVAUATSPIAH=I      L%I  H     L%H  ID$H;H  }  I  I  H=H  L  HH  L%H  HH  H    HH  HCHH  C,6E1  ;  H[A\A]A^A_]H^H  B#ID$H^H  E1       BL#Il$H-5H    D9  DH  IEtvAN1AtH+HH-G  I   tOHILAVp)f.     Ht+H-G  HqH4+H}H=G  H1HHHuL%G  B#  HG  HHtG  C,6jHWG  B   HXG  HCHMG  C,6HKE1H;3G  v5H  H  H=G  Hj  HG  HG  E1HG  HF  ,HF  HHF  E  M   Lff.     I] H] I] F  u@L%F  ID$H;F  v+I  I  H=vF  L  HgF  L%hF  HiF  HRF  HHVF  HIAu   fff.     Im F  u?HCH;F  v2H  H  H=E  HL  HE  HE  HE  HE  H,HE  HHE  IAuLH[A\A]A^A_]  H  H8HtE  H5H  H  H8HZE  H5x  1H[A\A]A^A_]N  fffff.     SH=7E     HBE  E  tzH1E  HCH;E     H  H  H=D  HQ  HD  HD  HD  D     HD  HKHD       oHD  HCHD        LHCHD  	l  DHKHvD     HXD     HZD  HKHOD  HCH;<D    H  H  H=D  Ho  H
D  HD  HD  C  	   HC  HKHC     uS       HC     HC  HHC  HC  
	   HC  HHC  HxC  
    HzC  HHoC  HXC  
    HZC  HHOC  H8C  
H>C  HH3C  HC      HC  HHC  HB      HB  HHB  HB      HB  HHB  HB      HB  HHB  HB      HB  HHB  H|B      H~B  HHsB  H\B     H^B  HHSB  H<B      H=B  [H$B  	   H&B  HKHB  HCH;B  vbH  H  H=A  H?
  HA  HA  HA  A      HA  HKHA     ? HA      HA  HKHA  HCH;yA     H  H  H=VA  H	  HGA  HHA  HIA  "A      H4A  HKH)A     ZH  H8H@  H5  Hh  H8H@  H58  1[  H@      H@  HKH@  HCH;@  v]H  H  H=@  H  H~@  H@  H@  Y@     Hk@  HCH`@  $ H>@     H@@  HCH5@  HKH;"@  v[H  H  H=@  HY  H?  H?  H?  ?      H?  HCH?   H?      H?  HCH?  HKH;?  v]H  H  H={?  H  Hl?  Hm?  Hn?  G?      HY?  HCHN?  R H,?      H.?  HCH#?  HKH;?  v]H  H  H=>  HG  H>  H>  H>  >      H>  HCH>   H>      H>  HCH>  HKH;>  v]H  H  H=g>  H  HX>  HY>  HZ>  3>      HE>  HCH:>  ~ H>      H>  HCH>  HKH;=  v]H  H  H==  H3  H=  H=  H=  =      H=  HCH=   H=      H=  HCH=  HKH;r=  vZH  H  H=S=  H  HD=  HE=  HF=   =      H2=  HCH'=  u%H=      H	=  HCH<  HKH;<  v]H  H  H=<  H"  H<  H<  H<  <     H<  HCH<  C H}<     H<  HCHt<  HKH;a<  H  H  H=><  H  H/<  H0<  H1<  @ AVSPH=<   N  ;  uIH<  HKH;;  v5H  H  H=;  H%  H;  H;  ;  1H;  H;  H
    H5;  HH5;  H=;  tHm;     {  H=d;  ]  sH5;       u4
  8H  L0H;    HH5Z  1LH  H=;  H5E;  @  H:      H*;      H=:    =0       H:      H:      H=:  H[A^  ffff.     SH     HH@    H=:   tH:  HAH:  [Hz:  Hk:  [f     SHX:  fD  1H[Hu[Pffff.     HGH%:    H=:  HuH:      H9      Xfff.     SH     HH@    H=9   tH9  HAH9  [H9  H9  [f     SH9  fD  1H[Hu[Pffff.     HGHu9  F  H=i9  HuHa9      HN9      Xfff.     AVSPIHHtA     HH@    H=9   tH9  HAH8  H8  H8  MtA      L0H@    H=8   tH8  HAH8  H8  H8  8  tH[A^8  H=1   H=.%   H=H[A^   %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %   %  %  %  %  %
  %  %  %  L  AS%  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h{  h  h  h  h  h  h                      	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for: isGameOver()
===================
 Test routine for : %d Players
      unittest2.c testNoVictory(&state) == 1 testNoKingdom(&state,kingdom) == 1 testNoProvince(&state) == 1 testThreeSuppliesGone(&state,kingdom) == 1 testContinuation(&state,kingdom) == 1 All tests succesful!
 	Test no victory cards:
 	Test succesful.
 	##TEST FAILED##
 	Test no kingdom cards:
 	Testing game end after depletion of province pile:
 	Testing 3 empty kingdom decks: %d, %d, %d 	Test: Fresh game continuation:
 	Test: Random nonzero number of provinces (%d):
 	Test: One kingdom pile (%d) empty:
 	Test: Two kingdom pile (%d,%d) empty:
               /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest2.gcda      main testNoVictory testNoKingdom testNoProvince   testThreeSuppliesGone           testContinuation uniqueInts     
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           0       0               H   H   K     H        P         ` P     W     0 `  P   `    ! a           zR x         zR x         zR x         zR x  <             ABB B(B0A8A@         \                  <   |   h       ABB B(B0A8A@      <             ABB B(B0A8A@            h,	       A  $     xs       BAA      D  G        A     d           A        D        A         0G        A       `        A       `D        A    $             BAA                                        *    4    >    H    R    \    f    p    z                                                                    $    .    8    B    L    V    `                   x6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6     7    7    7    7     7    (7    07    87    @7    H7    P7    `8    h8    p8    x8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8     9                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `U   @___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_rand  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time        _  _mh_execute_header c n kingdomCards i s d u play handCard buyCard g whoseTurn fullDeckCount endTurn main test Random P SelectStream GetSeed TestRandom     ompare ardEffect  (  ewGame umHandCards  *  +  nitializeGame sGameOver  -  huffle upplyCount coreFor  K  rawCard iscardCard  T  pdateCoins niqueInts  \  Card A S GreatHall  b  h  i      et ainCard  Cost Winners                    dventurer mbassador      mithy teward            No ThreeSuppliesGone Continuation  Victory Kingdom Province                lantSeeds utSeed           (P	mP`P	P
H  ` 	 P PP P     d           M   d           X   f W       .          $          $   P         N  P         .  `        $  `        $   P          N  P          .          $          $   @         N  @         .          $          $            N           .  %        $  %        $            N           .  `*        $  `*        $            N           .  p.        $  p.        $             N            .  p1        $  p1        $            N           .  `4       $  `4        $             N            .  4       $  4        $   6         N  6         .  k       $  k        $   p         N  p         .  0n     &  $  0n        $   P          N  P          .  n     3  $  n        $   p         N  p         .  u     <  $  u        $            N           .  x     F  $  x        $   `          N  `          .  0y     T  $  0y        $   P          N  P          .  y     _  $  y        $            N           .  `}     n  $  `}        $   p         N  p         .       w  $          $   P         N  P         .          $           $   0         N  0         .  P       $  P        $            N           .         $          $            N           .  p       $  p        $             N            .         $          $             N            .         $          $             N            .  P       $  P        $            N           .  0       $  0        $            N           .  @       $  @        $   P          N  P          .         $          $   0         N  0         .       ,  $          $   $         N  $         .       ?  $          $             N         Q  &  @!    i  &   "      &  "      &  "      &  *      &  8+      &  H+      &  `+    
  &  p.      &  /    .  &  /    @  &  0    R  &  (0    d  &  80    w  &  P0      &   1      &  01      &  1      &  @2      &  4      &  5      &  p6      &  @8    "  &  @A    5  &  A    H  &   B    [  &  B    n  &  `C      &  C      &  C      &  0E       d             d             d             f W       .         $          $            N           .  p     "  $  p        $             N            .       1  $          $            N           .  P     @  $  P        $            N           .  `     P  $  `        $            N           .       g  $          $            N           .       y  $          $            N           .         $          $            N           .  0       $  0        $            N           .         $          $             N           &  E      &  `F      &  F      &  F    
  &   G      &  PG    0  &  G       d             d           C  d           J  f 
W       .  0       $  0        $   p         N  p         .         $          $   0         N  0         .         $          $            N           .         $          $   0         N  0         .         $          $   `          N  `          .  p       $  p        $   P         N  P         .         $          $   P         N  P         .         $          $            N           .         $          $             N           &  "      &  `H    $  &  dH    1  &  pH    B  &  H    T  &   I    f  &  I    x  &  I      &   J       d              @                                             0     (         :         P         c         u                               `        @        p    	        ,	    @    A	    `    e	        	         	         	    p    	    @!    	     "    	    "    
    "    4
    "    :
    *    >
    *    O
    8+    a
    H+    s
    `+    
    p.    
    /    
    /    
    0    
    (0    
    80    
    P0         1        01    +    1    >    @2    Q    4    d    5    w    p6        @8        @A        A         B        B        `C        C        C    "    0E    5    E    F    `F    Y    F    l    F         G        PG        G        `H        dH        pH        H         I        I        I    &     J    8    pJ    B    xJ    L    J    Y    J    g    J    x    J        J        J        J        J        J        J                                   0                  p     )          =    k     F    4     R         [    p     h    `*     r    `}     {    y         u         n         P         `4                                             `         x              
    0         p1     $         3         ?    P     L          V    %     _    0n     l         ~             P         p         `                  p.         0y                                                     #            .            6            <            D            L            S            Z            c            i            p            w                                                                                                                                                                                                                                                                                                                                       @                                                                    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 unittest2.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest2.o _main _testNoVictory _testNoKingdom _testNoProvince _testThreeSuppliesGone _testContinuation _uniqueInts ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr19 ___llvm_gcov_ctr20 ___llvm_gcov_ctr21 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr19 ___llvm_gcov_ctr20 ___llvm_gcov_ctr21 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _compare _discardCard _drawCard _endTurn _fullDeckCount _gainCard _getCost _getWinners _handCard _initializeGame _isGameOver _kingdomCards _main _newGame _numHandCards _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _testContinuation _testNoKingdom _testNoProvince _testNoVictory _testThreeSuppliesGone _uniqueInts _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _rand _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder   File 'dominion.c'
Lines executed:0.00% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
    #####:   12:    return -1;
    #####:   13:  return 0;
    #####:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
    #####:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    #####:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
    #####:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
    #####:  215:    card = floor(Random() * state->deckCount[player]);
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
    #####:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
    #####:  226:  }
        -:  227:
    #####:  228:  return 0;
    #####:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
    #####:  315:  int currentPlayer = whoseTurn(state);
    #####:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
    #####:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
    #####:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
    #####:  532:    for (i = 0; i < state->discardCount[player];i++){
    #####:  533:      state->deck[player][i] = state->discard[player][i];
    #####:  534:      state->discard[player][i] = -1;
    #####:  535:    }
        -:  536:
    #####:  537:    state->deckCount[player] = state->discardCount[player];
    #####:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
    #####:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
    #####:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
    #####:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
    #####:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
    #####:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
    #####:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  562:    state->deckCount[player]--;
    #####:  563:    state->handCount[player]++;//Increment hand count
    #####:  564:  }
        -:  565:
        -:  566:  else{
    #####:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
    #####:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  575:    state->deckCount[player]--;
    #####:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
    #####:  579:  return 0;
    #####:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
    #####:  652:  int currentPlayer = whoseTurn(state);
    #####:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
    #####:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
    #####:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
    #####:  659:  int z = 0;// this is the counter for the temp hand
    #####:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
    #####:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
    #####:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
    #####:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
    #####:  823:      discardCard(handPos, currentPlayer, state, 0);
    #####:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
    #####:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
    #####: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
    #####: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
    #####: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1124:      state->playedCardCount++;
    #####: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
    #####: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
    #####: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
    #####: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
    #####: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
    #####: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
    #####: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
    #####: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
    #####: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
    #####: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
    #####: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
    #####: 1203:	  state->coins += 1;
    #####: 1204:	}
    #####: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
    #####: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
    #####: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
    #####: 1216:  state->coins += bonus;
        -: 1217:
    #####: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
    #####: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
    #####: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
    #####: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
    #####: 1273:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                    __text          __TEXT                                                __stubs         __TEXT          z           z                        __stub_helper   __TEXT          <    P      <                          __const         __TEXT              @                                   __cstring       __TEXT              	                                 __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                 0                                 __got           __DATA                                                    __nl_symbol_ptr __DATA                                      "           __la_symbol_ptr __DATA                                        $           __mod_init_func __DATA           !            !            	               __const         __DATA          @!          @!                            __data          __DATA          "          "                            __bss           __DATA          *                                           H   __LINKEDIT       P     @       0     1                    "  0    0    0 @           H0    2         5   P      P       V  V  )     #                           O D                             /usr/lib/dyld             a_ <"s%k$       
  
 *              (     `                 8         
   /usr/lib/libSystem.B.dylib      &      85 p   )      5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     UHHe H   HX H}HuHI       H}H}LELELMA	LMED9AD9HOH4H   H4A       H H   H E      H       H}H}DD9AD9HLH4H   H4A       H H   H E   H H   H E    H H   Ht E]ffffff.     UHHHY H   HL f  HF H   H8   HEHEH]D  UHAWAVSHXE(DU D]]L5 I   L5 ]DMDEMUuEDUD]}(   H H   H EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D}  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPH H   H UHu}HM   EEHMHMUUHuHuP  Hc}W  H       E=   A=   HOH<H   H<AJ   H]       M   @   HLH4H   H4@       H; H   H. Ej  H# H   H MHEE    H       M
   @
   HLH4H   H4@     H H   H E    Hj    
   M
   @
   HLH4H   H4@      H        M}9A9HEH4H   H4A   y   H       Hc}LEAHc}LEED9AD9HDH4H   H4A       H H   H E  H H   H H H   H M   MH H   H H H   H M   M!H       M   @   HDH4H   H4@   $   H^ H   HQ HE@
      H       M   @   HDH4H   H4@   $   H H   H HE@      H H   H HE@   H H   H H       M   @   HDH4H   H4@   :   H H   H HE@   HE@   HE@   5   H] H   HP HE@   HE@   HE@   <   H+ H   H iU   )HMAHMA(   HMA   E   H #   "   M   @   HNH4H   H4@     H H   H E    H| &   %   M
   @
   HLH4H   H4@   <  H2 (   '   Hc}LEADMD9AD9HDH4H   H4A     H *   )   Hc}LEA   A   HDH4H   H4AS   H ,   +   Hc}LEA
   A
   HDH4H   H4A      H@ .   -   M   @   HDH4H   H4@   )   Hn H   Ha HcEHMD   $   HM H   H@ HcEHMD   H1 H   H$ $   H  H   H HcEHMD
   H H   H ]   H H   H HcEHMDH H   H H H   H M   MzH H   H H H   H M   MH H   Hx E    H
 ;   :   M}9A9HLH4H   H4A     H= H   H0 HcEHM?      E    H/
 >   =   M   @   HLH4H   H4@   y   H H   H HcEHcMHUHH   Hi  H   HcEHM?     ?  H H   H M   M=Ht H   Hg E   HQ	 C   B   M
   @
   HLH4H   H4@   y   H' H   H HcEHcMHUHH   Hi  H   HcEHM?     ?  H
 H   H
 M   M=H
 H   H
 H
 H   H
 M   MH
 H   H
 E    H: J   I   M}9A9HLH4H   H4A      }Hu  H5 L   K   =    A=    HLHH   HA       H
 H   H	 E  H	 H   H	 H	 H   H	 M   MH	 H   H	 E    H0 R   Q   M}9A9HLH4H   H4A   _   H	 H   Hv	 HcEHM8       HcEHM^      HQ	 H   HD	 M   M\H4	 H   H'	 E    Hq W   V   M   @   HNH4H   H4@   I   H H   H HcEHMDp    H H   H M   MmH H   H HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    HU \   [   M   @   HLH4H   H4@   O   H H   H HE   Hu[  EH H   H M   Mg1H H   H HE   Hu	  E    EH H   H| EHP] UHH  H  H HEH` H   HS  HH?        HH    LcLG?  A   AA   HLH4H   H4A   #   H H   H      HH5 H   H5 HcHHH   Hi  HHcLIc?    H<       HcLA?      A    HOH4H   H4A     H H   H
   HcH*?  Y  ,HcHcHHH   Hi  HHc    HG 	      HcLE?  A   D9AD9HLH4H   H4A      H3 H   H&    HcHcHHH   Hi  HHcHcHHH   Hi  HH H   H    H H   H HcH?  ?  Hw H   Hj     H       9A9HLH4H   H4A      H& H   H Hc HcHcHHH   Hi  HHcH?     ?  H H   H    H H   H     H  H H   Hs H H;E   H  ]  fffff.     UHH@H
 H   H
 }HuH	       MMH}H}LcELMG?  A    AA    HNH4H   H4A     H	 H   H	 E    Ht	       MHc}LEE^  D9AD9HLH4H   H4A      HP	 H   HC	 HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HH H   H M   MHcEHM^  HcEHM?  HcEHM^      }HuMHF 	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H H   H El  H H   H M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      He H   HX HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   H H   H E    H H   H EH@]fff.     UHH5 H   H( Hu}UH H   H MMHEHEUUHu       E    H       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   HN H   HA HE         Q  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H H   H HE            HX    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   HP H   HC HE         H. H   H! H" H   H H H   H	 H
 H   H M   M1H H   H UHM      ]UHAVSHPH  H   H  MUu}LEH        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H  H   H  E  H]        H}      A   HLH4H   H4A       H<  H   H/  E  }Hu  H5        EE=   A=   HLHH   HAJ   H  
   	   M   @   HOH4H   H4@       H  H   H  E   HE}uUMLEDMH$V  L     A   A=    =    MLOI   O       H:  H   H-  EJ   H"  H   H  HE      HE   HuUAE    EH  H   H  EHP[A^]    UHH HI  H   H<  }HuH6  H   H)  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL  MLUL I   L HDL HHDDLLHC  H=#    A   A   LE  L]        LA   99MONI   N      H  H   H            H|o4  H4  HHcHH=  H  H   Hq  H  H   H  H^  =4  H=  H  H   HFq  H  H   H      H           @   HLH4H   H4@   W   HL  H   H?  HxH(  H   H     \H  H   H  H             H  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   HZ  H   HM  HtH6  H   H)  H*  H   H     1H  H   H  HHa      p1  H=   He  H   Hn  H  H   H      HR  *   )   HcLE8   D9AD9HNH4H   H4A      HM  H   H@  HcHcHH   Hi  H4HcHcHcHH   Hi  HH  H   H         H  H   H  H   lH  /   .      @   HDH4H   H4@   l  H3  H5  1   0   =    A=    HNHH   HA      H  H   H     H   h2  H<  4   3   Ah9A9ILLI   LA   -   H=  H  H   H     d>   1Hw  H   Hj  H9      `HC  H   H6  H7  H   H*  GH&  H   H      H@  ;   :   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHcHH   Hi  HHcHn  H   Ha     HK  H   H>      -  H=  H  H    Hj  H  H   H  K-  H=  H  H(   HTj  H  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   HA  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   H  H   H  +  H  F   E       @   HOH4H   H4@M   He  H   G        @    HLH4H   H4@   #   H`  H   HS  G+  HcHcHH   Hi  H<~.      \h.  H  K   J   \9A9HOH4H   H4A   #   H  H   H  *     H  H   H   H?5  1HXY      TH  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HX  P?   Hx  H   Hk  Hl  H   H_     HI  H   H<      (  H=  HW  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5  W   V   AL9A9IOLI   LA   #   Hi  H   H\  '  1HL  H   H?   H2  1HHV      DH(  [   Z   HcLE8   D9AD9HLH4H   H4A      H  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1HG  H   H:  HU  @?   H  H   H  H  H   H     H  H   H      &  H=R  H  H8   Hc  H  H   H  HCX  %  H=  HJ  H@   Hb  Hm  H   H`  H1H      H   H<T      8,%  H=n  H  HH   H5b  H  e   d   H             A    HOHH   HA     H  H   H{         H0  h   g       @    HEH4H   H4@     H  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  H  H   H  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  H  m   l   HcLE8   D9AD9HLH4H   H4A      H  H   H     HcHcHH   Hi  HHcHcHH   Hi  HHo  H   Hb     
HL  H   H?  HcHHc8   HcHH   Hi  HHcH8   8         HK  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5U  v   Au   A=    A=    MDNI   NA   &   H  H   H  H5  0H  H   H  H  H   H      &   H  H   Ht     Hc  H   HV  HW  H   HJ  .HF  H   H9  .     H"  H54     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5     A   A=    A=    MDNI   NA   &   Hu  H   Hh  HL4  (HW  H   HJ  HK  H   H>  H?  H   H2      F  H=  H  HP   HO[  H  H   H  HQ    H=;  H  HX   H[  1H         HL  HX     A   A    A    MENI   NA$   9   HK  H   H>  H      H     H             @    HEH4H   H4@   ^  H  H   H  Hd*  H=]        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH_  H   HR      H           @   HLH4H   H4@   W   H  H   H  HH  H   H     \H  H   H      H        HDD9AD9HLH4H   H4A   {  H        9A9HEH4H   H4A     Hc        HcLA8      A   HOH4H   H4A     H  H   H  H        HcLA8       A    HOH4H   H4A   9   1H  H   H~  HI  jH\  H   HO      H>           @   HLH4H   H4@   W   H	  H   H  HbH  H   H     \H  H   H  H  H   H  H  H   H  H  H   H     4H{  H   Hn  Ho  H   Hb  Hc  H   HV      :  H=|  H  H`   HCU  H,  H   H  H DL    H=  Ha  Hh   HT  Hl        HcLA^  HcLA?     A   HNHH   HA     H        HcLA?      A    HOH4H   H4A   ~   H$  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?    H        HcLA^      A    HOH4H   H4A   ~   Ha  H   HT  HcH^     HcHcHH?  Hi  HUHcH^  ^     H  H   H  H  H   H  H  H   H  ~  H        HcLA?      A    HDH4H   H4A     Hu  H   Hh      H        HcLE^  D9AD9HLH4H   H4A     H  H   H  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  HC  H   H6     H   H   H  HH  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   HW  H   HJ  MHHcf  H^  Hf     f  EH  H   H      H           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   H4        HcL   A   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   2   H  H   H  H           Hc        HcL   A   HDH4H   H4A9  H        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4A   H|        HcL
   A
   HDH4H   H4AR   H/        HcL   A   HDH4H   H4A   I   H  H   H  HNH64   H\  H   HO  H      H   H0  H   H#  H$  H   H  H  H   H     ?H  H   H      <  H=~  H  Hp   HEJ  H  H   H  H C    H=%  Hj  Hx   HI     Hh  H   H[  H    H:        HDD9AD9HLH4H   H4A   2  H        9A9HEH4H   H4A     H  H   H      H        HcLE8   D9AD9HLH4H   H4A     H#        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1H  H   H  H+:   o  Hy        HcLE8   D9AD9HDH4H   H4A      H|  H   Ho      H        HcLE8   D9AD9HLH4H   H4A   ?   H  H   H  H  H   H      dH  H   H  ?   H  H   H  H  H   H     H  H   H  H  H   H  H  H   H     }1Hm  H   H`  H08        H=  HM  H   HE  HX        H      H   HcLALAHDHH   HA   #   H  H   H       H  H   H  HcHtp   tpH7        H=  H2  H   HD  1H  H   H  H         H6      3  H=u  H  H   H<D  H        H             A    HEHH   HA   x   HW  H   HJ  H   H	     H   H5  1H  H   H  H`5        H=8  H}  H   HB  H  H   H      Hj      HDD9AD9HLH4H   H4A     H      9A9HEH4H   H4A   &  H  H   H  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    H  H   H  H  H   H     H  H   H        H=  H  H   H@  Hz  H   Hm      H      HcLE8   D9AD9HLH4H   H4A      H      HcLcLI   Mi  MA   A   HDH4H   H4A   p   H4      9A9HEH4H   H4A   %   Hq  H   Hd  ?   HT  H   HG  HH  H   H;     H      @HOH4H   H4@   5     H  H   H  H0     H0      H         @   HLH4H   H4@   a         HE  H   H8  H~  H!  H   H     RH  H   H     U   H  H   H  2   H=t  H5  D=  H5  H   H5  Hn  H  H   H  H H;E   H(	  []   )v)hmyw     UHH0Ha  H   HT  }HuHF        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       H  H   H  E  }Hu  H5        =   A=   HLHH   HA       H  H   H  E*  HE   }M  H/        AM9A9ILLI   LA       H4  H   H'  E   1H  H   H  HE      }HuM`  Hu   }EM   M)Hu   Hu      H  H   H  H  H   H  H  H   H  E    H  H   H}  EH0]@ UHH  H   H  }HuHz  H   Hm  MMHEHEHcUHuD]UHH Hq  H   Hd  }      EEMHHHUHuh  H  HMHcHH=|  H  H   HG9  H  H   H  E    G  H=@  H  H   H9  H  H   H  E     H=  Hm  H   H8  H  H   Hs  E     H=  H1  H    H8  HL  H   H?  E     H=  H  H(   HW8  H  H   H  E    W  H=P  H  H0   H8  H  H   H  E     H=  H}  H8   H7  H  H   H  E     H=  HA  H@   H7  H|  H   Ho  E     H=  H  HH   Hg7  HH  H   H;  E   g  H=`  H  HP   H+7  H  H   H  E   +  H=$  H  HX   H6  H  H   H  E     H=  HQ  H`   H6  H  H   H  E     H=  H  Hh   Hw6  Hx  H   Hk  E   w  H=p  H  Hp   H;6  HD  H   H7  E   ;  H=4  H  Hx   H5  H  H   H  E     H=  Ha  H   H5  H  H   H  E     H=  H%  H   H5  H  H   H  E     H=  H  H   HK5  Ht  H   Hg  E   K  H=D  H  H   H5  H@  H   H3  E     H=  Hq  H   H4  H  H   H  E     H=  H5  H   H4  H  H   H  E     H=  H  H   H[4  H  H   H  E   [  H=T  H  H   H4  Hp  H   Hc  E     H=  H  H   H3  H<  H   H/  E      H=  HE  H   H3  H  H   H  E      H=  H	  H   Hk3  H  H   H  E   k   H=d  H  H   H/3  H  H   H  E   /   H=(  H5  2  H5u  H   H5g  EHa  H   HT  EH ] ]M=y-iYI9u@ UHH0HA  H   H4  UHu}MEEHMHMUUuu}HuH        A=   A=   ILLI   LA       H  H   H  E   H        M   @   HDH4H   H4@   d   Hz  H   Hm  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H{  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  H1  H   H$  H%  H   H  HcEHMTTE    H  H   H  EH0]fffff.     UHHH  H   H  H}H  H   H  HEHEH}   HcHM8   H]    UHHu  H   Hh  H}He  H   HX  HEHEHM   ]fff.     UHHU  H   HH  u}HUH?  H   H2  MMUUHEHEE    E    H        MHc}LEE?  D9AD9HLH4H   H4A      H        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       Hw  H   Hj  M   MH_  H   HR  HS  H   HF  M   MH6  H   H)  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H  H   H|  M   MHq  H   Hd  He  H   HX  M   MHH  H   H;  E    H        MHc}LEE^  D9AD9HLH4H   H4A      HQ        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   Hv  Hw  H   Hj  M   MHZ  H   HM  E]UHH0HQ  H   HD  H}HA  H   H4  HEHEH}EE    H
        MHc}LEE8   D9AD9HLH4H   H4A      H  H   H  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HHF  H   H9  M   MH        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   H  H   H  M   HE   "   H  H   H  HE       H  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    H        M   @   HLH4H   H4@   O   H  H   H  HE   HuEH  H   H  M   Mg1H  H   H  HE   Hu1EH0]@ UHHe  H   HX  H}HM        H}H}LEAH    A    HDH4H   H4A       H  H   H  E     H  H   H  E    E    H        M   @   HLH4H   H4@      Hj        Hc}LEAL    A    HDH4H   H4A       H^  H   HQ  M   MHF  H   H9  H:  H   H-  M   M	H        M   @   HMH4H   H4@       H  H   H  E      H  H   H  E    H  H   H  E]fD  UHH@H  H   H  }HuH  H   H  MMHEHEE    E    HV        MHc}LEE8   D9AD9HLH4H   H4A     H        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       H  H   H  M   MHz        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       HZ  H   HM  M   MH     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MHj        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MHZ        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMHj  H   H]  H^  H   HQ  M   M+HA  H   H4  E    Hf        MHc}LEE^  D9AD9HLH4H   H4A     H        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H"  H   H  M   MH  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MHz  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       HB  H   H5  M   MH  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MHj  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H`  H   HS  M}HUM
   MMH2  H   H%  H&  H   H  M   M+H	  H   H  E    Hv  1   0   MHc}LEE^  D9AD9HLH4H   H4A     H"  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       HZ  H   HM  M   MH  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MHz  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1H(  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  EH@]ff.     UHH0H  H   H  H}HuH  H   H  HEHEHMHME    Hj        M   @   HLH4H   H4@      H         MH}DD9AD9HMH4H   H4A   (   H  H   H  HcEHM+   H  H   H  }HuHcuHMH  H   H  H  H   H  M   MH  H   H  E    E    H'        M   @   HLH4H   H4@      H        Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH  H   H  H  H   H  M   M
H  H   H  HcEHMUH}-EE    H        M   @   HLH4H   H4@      H        Hc}LEADMD9AD9HDH4H   H4A   m   Ha        M}9A9HOH4H   H4A   (   H  H   H  HcEHM   H  H   H  H  H   H  M   MH  H   H  E    E    H        M   @   HLH4H   H4@      HO         Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH  H   H  H  H   H  M   M
H  H   H  HcEHMUE    Hz  &   %   M   @   HLH4H   H4@      H0  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   H'  H   H  HcEHM   #   H  H   H  HcEHM    H  H   H  H  H   H  M   M1H  H   H  H0]D  UHH   H  H HEHP  H   HC  HH7  H   H*  HHH       H           @   HLH4H   H4@     H        HcLA?     A   HLH4H   H4A   ,   Hj  H   H]  H[H#H=9{  HcH8      HcHcLI   Hi  IA x  H        A   A   IDLI   LA   HL  
   	      @   HDH4H   H4@M   H           @   HDH4H   H4@   +   H  H   H     \   H  H   H  Hc HcH8   8      H  H   H  3H  H   H  H               @    HMH4H   H4@      HH  H   H;     Hc HcH^     ^  HcHcLI?  Hi  IA   "1H  H   H  H.   HG  HH;U   1H   ]u  @ UHHU  H   HH  HUu}MH4        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   H  H   H  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  Hk        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   H  H   H  HcEHM8   8   \  H        Hc}LEA8      A   HDH4H   H4A   5   H  H   H  HcEHM8   8      Hz  H   Hm  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   H  H   H  1H  H   H  ]     UHH0HQ  H   HD  H}uH>  H   H1  HEHEMMH}REE    H        M   @   HLH4H   H4@   H   H  H   H  }HuEH  H   H  M   Mn1H  H   H  }uHU1EH0]@ UHH0Hi  H   H\  H}uHV  H   HI  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPHa  H   HT  MUuH}DEHEHEMMUUuu}}H}H=     A   AEE=   A=   MDNI   NA   7   H  H   H  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   Hu  H   Hh  HE      HE   <   1HH  H   H;  }uHU1}uHUEEH  H   H	     H  H   H  }uHUQ1EHP]@ UHHPH  H   H  UuH}MHEHEMMUUuuH}H=     A   AEE    E=   A=   MONI   NAJ   Hn        M    @    HLH4H   H4@       HL  H   H?  E  H        M}9A9HDH4H   H4A       H  H   H  E{  H  H   H  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  H0        M}9A9HEH4H   H4A      H        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MdH        M}9A9HLH4H   H4A       H[  H   HN  E_  HC  H   H6  MHcEHULLE    HU        MH}DD9AD9HLH4H   H4A      H
        M}9A9HEH4H   H4A   E   1H  H   H  HcEHcMHuH   Hi  H<HuM:EHp  H   Hc  Hd  H   HW  M   M1HE  H   H8  }uHUYE    EH  "   !   M}9A9HLH4H   H4A     H  H   H  E    H  %   $   MHc}LEE8   D9AD9HLH4H   H4A      Hd  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      H  H   H  }uHUE9   H  H   H  H  H   H  M   MH  H   H  H  H   H  M   M'H  H   H  E    H  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=i  H5Bj  VL  1H54j  /AVUMQ  	   H5  <V     H5j  [H1AVQ     H5  V     H5i  1AVQ     H5  U     H5i  VI1AVPQ  a   H5  U     H5i  ;|1AV!Q     H5e  U     H5ui  ] t1AVP     H5  QU     H5Oi  T1AVP     H57  "U     H5(i  w1AVP     H5  T     H5i  YAr1AVeP     H5a  T  	   H5h  j1AV6P     H5B  T  
   H5h  a'Hr1AVP     H5+  fT     H5h  @1AVO     H5  7T     H5wh  -1AVO     H5  T     H5Ph  "mw1AVzO     H5  S     H5,h  |1AVKO  G   H5_  S     H5h  b1AVO  .   H5p  {S     H5g  W71AVN     H5  LS     H5g  `1AVN  :   H5  S     H5g  eW1AVN    H5  R     H5qg  Qw1AV`N     H5t  R     H5Ng  :/T1AV1N     H5  R     H5(g  r%1AVN     H5  aR     H5g  Ba1AVM     H5W  2R     H5f  PR1AVM     H5  R     H5f  Ce&1AVuM     H5  Q     H5f  #e,1AVFM  /   H5  Q     H5f  Ql1AVM  
   H5  vQ  QU  |^  H]fD  UHH{      H{      H{      H{      H{      H{      Hz{      Hg{      HT{      H{      H{      H{      H{      H}      Hr}      H_}      HL}      H9}      H&}      H}      H }      H|      H|      H|      H|      H|      H|      H{|      Hh|      HU|      HB|      H/|      H|      H	|      H{      H{      H{      H{      H{      H{      H{      Hq{      H^{      HK{      H8{      H%{      H{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hzz      Hgz      HTz      HAz      H.z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hpy      H]y      HJy      H7y      H$y      Hy      Hx      Hx      Hx      H{      H{      H{      H{      H{      Hn{      H[{      HH{      H5{      H"{      H{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hwz      Hdz      HQz      H>z      H+z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hmy      H
{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hrz      H_z      HLz      H9z      H&z      Hz      H z      Hy      Hy      Hy      Hy      Hy      Hz      Hz      Hz      H}z      Hjz      HWz      HDz      H1z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      H{z      Hhz      HUz      HBz      H/z      Hz      H	z      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hqy      Hy      Hy      Hy      Hy      Hy      Hy      Hz      Hz      Hvz      Hcz      HPz      H=z      H*z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hly      HYy      HFy      H3y      H y      Hy      Hx      Hx      Hx      Hx      Hy      H{y      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hsy      H`y      HMy      H:y      H'y      Hy      Hy      Hx      Hx      Hy      Hy      Hy      Hy      Hy      Hqy      H^y      HKy      H8y      H%y      Hy      Hx      Hx      Hx      Hx      Hx      Hx      H{      H
{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hrz      H_z      HLz      H9z      H&z      Hz      H z      Hy      Hy      Hy      Hy      Hy      Hy      H{y      Hhy      HUy      HBy      H/y      Hy      H	y      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hqx      H^x      HKx      H8x      H%x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hzw      Hgw      HTw      HAw      H.w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hpv      Hx      Hx      Hox      H\x      HIx      H6x      H#x      Hy      Hy      Hy      Hy      Hty      Hay      HNy      H;y      H(y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      H}x      Hjx      HWx      HDx      H1x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hsw      H`w      HMw      H:w      H'w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      H|v      Hiv      H>x      H+x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hmw      HZw      HGw      H4w      Hqy      H^y      HKy      H8y      H%y      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hzx      Hgx      HTx      HAx      H.x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hpw      H]w      HJw      H7w      H$w      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hyv      Hfv      HSv      H@v      H-v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hou      H\u      HIu      H6u      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hnx      H[x      HHx      H5x      H"x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hww      Hdw      HQw      H>w      H+w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hmv      HZv      HGv      H4v      H!v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hvu      Hcu      HPu      H=u      H*u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hlt      HYt      HFt      H3x      H x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Huw      Hbw      HOw      H<w      H)w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      H~v      Hkv      HXv      HEv      H2v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Htu      Hau      HNu      H;u      H(u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      H}t      Hjt      HWt      HDt      H1t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hsw      H`w      HMw      H:w      H'w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      H|v      Hiv      HVv      HCv      H0v      Hv      H
v      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hru      H_u      HLu      H9u      H&u      Hu      H u      Ht      Ht      Ht      Ht      Ht      Ht      H{t      Hht      HUt      HBt      H/t      Ht      H	t      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hqs      H^s      HKs      H8s      H%s      Hs      Hr      Hr      Hr      Hr      Hv      Hv      Hv      Hzv      Hgv      HTv      HAv      H.v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hpu      H]u      HJu      H7u      H$u      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hyt      Hft      HSt      H@t      H-t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hos      H\s      HIs      H6s      H#s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hxr      Her      HRr      H?r      H,r      Hr      Hr      Ht      Ht      Ht      Ht      Ht      Ht      Hyt      Hft      HSt      H@t      H-t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hos      H\s      HIs      H6s      H#s      Hs      Hr      Hr      Hr      Hr      Hr      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hns      H[s      HHs      H5s      H"s      Hs      Hs      Hs      Hs      Hs      Hs      H}s      Hjs      HWs      HDs      H1s      Hs      Hs      Hr      Hs      Hs      Hs      Hs      Hs      Hs      Hss      H`s      HMs      H:s      H's      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hs      Hs      Hs      Hs      H{s      Hhs      HUs      HBs      H/s      Hs      H	s      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hqr      H^r      HKr      H s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      HMt      H:t      H't      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      H|s      His      HVs      HCs      H0s      Hs      H
s      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hrr      H_r      HLr      H9r      H&r      Hr      H r      Hq      Hq      Hq      Hq      Hq      Hq      H{q      Hhq      HUq      HBq      H/q      Hq      H	q      Hp      Hp      Hr      Hr      Hzr      Hgr      HTr      HAr      H.r      Hr      Hr      Hq      ] UHH=H5I=  ]UHH@g  HL  H HEH r  H   Hq  1E    >  v>  H=A  1f  HL?  (   ALUEJ  E   E    HLLHLH=  HHH=  H =     HHuU
DHEE  Hq        =AAAALcI    AI    HEH<H   H<A      H=@  H5@  7   H@  <  Hp  H   Hp  H  H=kp        =AAAALcI    AI    HEH4H   H4A      H=D@  H5B@  8   HX@  ;  H+p  H   Hp  H  H=o  
   	   =   AAAALcI    AI    HEH4H   H4A      H=?  H5?  9   H?  L;  Ho  H   Ho  H  H=+o        =   AAAALcI    AI    HEH4H   H4A      H=?  H5?  :   HC?  :  H+o  H   Ho  HR  H=n        =   AAAALcI    AI    HEH4H   H4A      H=d>  H5b>  ;   H>  :  Hn  H   Hn  H  H=m        =   AAAALcI    AI    HEH4H   H4A      H==  H5=  <   H3>  l9  H+n  H   Hn  H=.>  Hn  H   Hn   9  H=G  H?H;}   1H@g  ]9  fUHH0Hm  H   Hm  H}H==  HEHEHMA@     S9     1HuHM   EH5{m     A   AEE=A=MDNI   NA   *   H=z=  H?m  H   H2m   8  E%   H=_=  Hm  H   Hm   8  EHm  H   Hl  EH0]f     UHH0Hl  H   Hl  H}H==  HEHE >8     1HuHM   E}H5l     A   AEE=A=MDNI   NA   *   H=e<  HZl  H   HMl   7  E%   H=J<  H8l  H   H+l   7  EH"l  H   Hl  EH0]@ UHH0Hl  H   Hk  H}H=!<  HEHEE    HM   UHMA@
   HMQ@UU   U 6     1HuME?H5k     A   AMLUAR@9A9MDNI   NAE      HQk  H   HDk  E   Hk        M    @    HEH4H   H4@   4   H=?;  Hj  H   Hj  uHEP@ 6  E/   H=C;  Hj  H   Hj  uHEP@ 5  EHj  H   Hj  EH0]ff.     UHH0Hj  H   Hj  H}      HEHEHM   uHuMHcuLEA8      M}HuEXH5&j        A   A9A9MDNI   NA       Hi  H   Hi  E      Hi  H   Hi  E    Hi        M    @    HEH4H   H4@   2   H=9     Hi  H   Hzi  u <4  ED   Hii  H   H\i  u}HEuHWH=9     u 3  EH-i  H   H i  EH0]ffffff.     UHAVSH0Hh  H   Hh  H}      HEHEHM   uHuMH5h        A   ALcUL]C?     ULcULc]H]HH   Mi  LB9A9MDNI   NAE       HPh  H   HCh  E      H8h  H   H+h  E    Hg        M    @    HEH4H   H4@   2   H=h8     Hg  H   Hg  u D2  EN   H=j8     Hg  H   Hg  uHcEHcULEIH   Hi  IA 1  EH{g  H   Hng  EH0[A^]f.     UHAVSH0HNg  H   HAg  H}H>g  H   H1g  HEHEHM   UE    Hg        M   @   HLH4H   H4@   y   Hf  H   Hf  HcEHcMHUH?  Hi  H   HcEHM^     ^  Hf  H   Hf  M   M=   1HuMH50f        A   ALcUL]C^     ULcULc]H]H?  Mi  LB9A9MDNI   NAE       He  H   He  E      He  H   He  E    Hre     
   M    @    HEH4H   H4@   2   H=6     H|e  H   Hoe  u i/  EN   H=6     HRe  H   HEe  uHcEHcULEI?  Hi  IA /  EHe  H   He  EH0[A^]ffffff.     UHHH=5  H5"1  I  1H5q2  \yAIUM     H5b       H55  gBl1AI     H5b       H55  #;1AI_     H5b       H55  e1AI0  	   H5b       H5t5  s1AI  
   H5b  `     H5R5  
L1AI  
   H5b  1     H505  1AI     H5c      )  H]fUHwHa      Ha      Hna      H[a      HHa      H5a      H"a      Ha      H`      H`      H`      H`      H`      H`      H`      Hw`      Hd`      HQ`      H>`      H+`      H`      H`      H_      H_      H_      H_      H`      H`      H`      Hm`      HZ`      HG`      H`      H`      Hn`      H[`      HH`      H5`      H`      H`      Ht`      Ha`      HN`      H;`      H(`      H`      H`      H`      H|`      Hi`      HV`      HC`      H0`      H`      H
`      H_      H_      Hq`      H^`      HK`      H8`      H%`      H`      H_      H_      H_      H_      H{`      Hh`      HU`      HB`      H/`      H`      H	`      H_      H_      H_      H_      H_      H_      H_      Hq_      ]ffffff.     UHH=H5NI(  ]UHH_  H   H_  H_          LE:  HE  HEG  Lcn_  OHELHUHHHi  LcL_  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   H9  H_  H   H^  HMHc^  H2   Hu9  H^  H   H^  HMHHc^  H**  H;9  H^  H   H^  Hc_^  H*^(]UHH@H^  H   Ht^  H}1Ho^  H   Hb^  HEHEHEm HE  ]     ]  M  H}  M]  E   H
^        M   @   HLH4H   H4@   K  H]        m L$8  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   H7  H3]  H   H%]  HMHcUH/   H]7  H]  H   H ]  HMHHcUHH\  H   H\  H\  H   H\  M   MkH\  H   H\  H@]fUHHHq]  H   Hd]  }HZ]        MM}   =[  =[      A    HDH4H   H4A   n   H\        [      @    HEH4H   H4@   !   [H\  H   H\  H\  H   H\  H]    UHH0H[  H   H[  H}H[        H}H}E LEI    AI    HOH4H   H4A   )   HA[  H   H3[  HEHHHUH[        H}H    AH    HLH4H   H4A   .   1HZ  H   HZ  $  1HHUHZ        H}H    AH    HDH4H   H4A     HZ  H   HzZ  H+Z     
   } @@@HEH4H   H4@   "  H=*   !#  H=*  HuE #  1H5Y  1   A   ALUL9AL9MLJ<H   J<AEU   "   HY  H   HY  H}MEHGY        $EE< A< HEH<H   H<A%   H=**  HY  H   HtY   )"  EHkY  H   H^Y  HZY  H   HMY  H2  HGY  H   H9Y  HMHcW  HH0]@ UHHY  H   HY  H}H}2  HY  H   HX  HMHMHcW  HHUH]fff.     UHH0HY  H   HY  1HY  H   HX  E %   +HE    HX        H}H'  AH'  HLH4H   H4A   E   HX  H   HX  EHX  H   H|X  HEH   HEnH}   H}Z$EY   H}1H=W        M    A    HEH4H   H4AE   "   HW  H   HW  H}Y  MEHW  
   	   $EE< A< HEH<H   H<A   *   H='  HW  H   H~W   c  E%   H='  HiW  H   H\W   9  EHSW  H   HFW  H0]     UHHH='  H5R!  M_   1H5'  hnAM_UM     H5T  L     H5'  8I1AM_     H5T       H5l'   1AM_     H5#U       H5E'  r~61AM_`     H5U       H5'  XH1AM_1     H5U       H5&  
1AM_     H5U  a  <  g  H]UHHT      HS      HS      HS      HS      HS      HT      HT      HS      HS      HS      HS      HS      HS      HS      HoS      H\S      HQT      H>T      H+T      HT      HT      HS      HS      HS      HS      HS      HS      HS      HmS      HZS      HGS      H4S      H!S      HS      HR      HR      HR      HzS      HgS      HS      HS      H~S      HkS      HXS      HES      H2S      HS      HS      HS      HS      HS      HpS      H]S      HJS      H7S      H$S      HS      HR      HR      HR      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH=J%    HH=G%    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IHz  IK|&I  HHHL  AD./tB3/IHLLL  EL<$H)R  *R      1H  2  tL5"     Q  H=Q      1  2  L5"  uhH-Q  H]fffff.     Ht/u   HE  /H=Q      1@  2         =2  L  HRQ  HOQ      HLQ      HIQ      "Q  u&1     HHQ  HQ        1   Hl  H=P  f  H%Q  HtfDq1  1      E1Hf  HHP  H     8H`&  HH-~P  q  HH5"  1HH  cP  HhP      HeP      H-fP  1H  t)H H  1H  HH)P  H-*P  1   H  O  H-P  tbHEH;O  vrH  H  HH  HO  H-O  HO  O  adcgHO  HCHO  t?+adcgHO  HHO  1gHO  adcgH~O  HCHsO  HSH;^O  v8H  H  H=?O  H  H0O  H1O  H2O  O  HO  A74HO  HCHO  t?HKH;N  v2H  H  H=N  H  HN  HN  HN  HN  D,HN  H[A\A]A^A_]  8HI$  HH-gN  Z  HH5C  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=M   1  T$D$M  u?HM  HCH;M  v+H  H  H=M  H  HM  HM  HM  HM     HM  L{L=M  MtLY  Hl(UM  tfHCH;^M     H  H  H=;M  H  H,M  H-M  H.M  M  ,HM  HCHM  u\HL  B,8HL  HHL  HL  D$HL  HHL     HL  B,8HL  HCHL  HKH;L  vVH  H  H=}L  H=  HnL  HoL  HpL  IL  D$H^L  HCHSL  u^H5L  D$H:L  HCH/L  HKH;L  v2H  H  H=K  H  HK  HK  HK  HK  T$H-K  H]HK  EtjK  u?HEH;K  v2H  H  H=K  HM  H~K  H-K  HK  HiK  $HlK  HHaK  My  L&  HH K  uKHCAH;%K  v>H  H  H=K  H  HJ  HJ  D=J  HJ  E1HJ  ,H-J  HH-J  L  IAtALHH;J  v2H H  H=J  HL  H}J  H~J  H-J  H-hJ  HLL  H-cJ  LH-YJ  L'  H   H)J  u?L4+L;5&J  v2I I  H=J  L  HI  L5I  H-I  H-I  1HHn  HI  H[A\A]A^A_]     UAWAVAUATSPIAH=I      L%I  |I     L%I  ID$H;yI  }  I  I  H=VI  L  HGI  L%HI  HII  "I    H4I  HCH)I  C,6E1  ;  H[A\A]A^A_]HH  B#ID$HH  E1       BL#Il$H-H    D9  DH  IEtvAN1AtH+HH-H  I   tOHILAVp)f.     Ht+H-LH  HqH4+H}H=9H  H1HHHuL%H  B#  HH  HHH  C,6jHG  B   HG  HCHG  C,6HKE1H;G  v5H  H  H=G  Hd  HG  HG  E1HG  H}G  ,HG  HHxG  E  M   Lff.     I] H] I] %G  u@L%9G  ID$H;%G  v+I  I  H=G  L  HF  L%F  HF  HF  HHF  HIAu   fff.     Im F  u?HCH;F  v2H  H  H=F  HF  HwF  HxF  HyF  HbF  H,HgF  HH\F  IAuLH[A\A]A^A_]  H  H8HF  H5  H  H8HE  H58  1H[A\A]A^A_]N  fffff.     SH=E     HE  E  tzHE  HCH;E     H  H  H=E  HK  H|E  H}E  H~E  WE     HiE  HKH^E       oH7E  HCH9E        LHCHE  	l  DHKHE     HD     HD  HKHD  HCH;D    H  H  H=D  Hi  HD  HD  HD  uD  	   HD  HKH|D     uS       HXD     HJD  HH?D  H(D  
	   H*D  HHD  HD  
    H
D  HHC  HC  
    HC  HHC  HC  
HC  HHC  HC      HC  HHC  HC      HC  HHC  HlC      HnC  HHcC  HLC      HNC  HHCC  H,C      H.C  HH#C  HC      HC  HHC  HB     HB  HHB  HB      HB  [HB  	   HB  HKHB  HCH;B  vbH  H  H=yB  H9
  HjB  HkB  HlB  EB      HWB  HKHLB     ? H%B      H'B  HKHB  HCH;	B     H  H  H=A  H	  HA  HA  HA  A      HA  HKHA     ZHR  H8HpA  H5_  H8  H8HVA  H5  1[  HXA      HZA  HKHOA  HCH;<A  v]H  H  H=A  H  HA  HA  HA  @     H@  HCH@  $ H@     H@  HCH@  HKH;@  v[H  H  H=@  HS  H@  H@  H@  `@      Hr@  HCHg@   HF@      HH@  HCH=@  HKH;*@  v]H  H  H=@  H  H?  H?  H?  ?      H?  HCH?  R H?      H?  HCH?  HKH;?  v]H  H  H=?  HA  Hr?  Hs?  Ht?  M?      H_?  HCHT?   H2?      H4?  HCH)?  HKH;?  v]H  H  H=>  H  H>  H>  H>  >      H>  HCH>  ~ H>      H>  HCH>  HKH;>  v]H  H  H=m>  H-  H^>  H_>  H`>  9>      HK>  HCH@>   H>      H >  HCH>  HKH;>  vZH  H  H==  H  H=  H=  H=  =      H=  HCH=  u%H=      H=  HCH=  HKH;{=  v]H  H  H=\=  H  HM=  HN=  HO=  (=     H:=  HCH/=  C H=     H=  HCH=  HKH;<  H  H  H=<  H  H<  H<  H<  @ AVSPH=<   N  <  uIH<  HKH;~<  v5H  H  H=_<  H  HP<  HQ<  3<  1HH<  H1<  H
    H52<  HH5'<  H=<  tH;     {  H=;  ]  sH5&<       u4
  8H  L0H;    HH5  1LH  H=;  H5;  @  H;      H;      H=k;    =        HK;      HH;      H=);  H[A^  ffff.     SH     HH@    H=;   tH;  HAH;  [H
;  H:  [f     SH:  fD  1H[Hu[Pffff.     HGH:    H=:  HuH:      H:      Xfff.     SH     HH@    H=o:   tHn:  HAHc:  [HZ:  HK:  [f     SH8:  fD  1H[Hu[Pffff.     HGH:  F  H=9  HuH9      H9      Xfff.     AVSPIHHtA     HH@    H=9   tH9  HAH9  H9  Hp9  MtA      L0H@    H=^9   tH]9  HAHR9  HI9  H:9  D9  tH[A^19  H=1   H=.%   H=H[A^   %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %    L  AS%  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h~  h  h  h  h  h                    	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for: gainCard()
===================
 main unittest3.c exhausted(&state)==-1 outOfPlay(&state)==-1 decrement(&state)==1 transferHand(&state)==1 transferDeck(&state)==1 transferDiscard(&state)==1 All tests passed!

 	Testing attempt to gain a depleted card stock:
 	Test passed.
 	##TEST FAILED.##
 	Testing attempt to gain an unused card:
 	Testing: checking proper kingdom card decrement:
 	Test passed! Target supply: %d, Supply after gain: %d
 	##TEST FAILED! Target supply: %d, Supply after gain: %d##
 	Test passed. Card at hand position %d has enum %d
 	##TEST FAILED. Card at hand position %d has enum %d: target: %d
 	Test passed. Card at deck position %d has enum %d
 	##TEST FAILED. Card at deck position %d has enum %d: target: %d
 	Test passed. Card at discard position %d has enum %d
 	##TEST FAILED. Card at discard position %d has enum %d: target: %d
          /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest3.gcda           exhausted outOfPlay decrement transferHand transferDeck transferDiscard      
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           4       4          !      L   L   {     L        X         ` P     W             `       a           zR x         zR x         zR x         zR x  <              ABB B(B0A8A@         \                  <   |   h       ABB B(B0A8A@      <              ABB B(B0A8A@            ,	       A  $     s       BAA      D  G        A     d  8        A       8D        A         hG        A               A       D        A    $             BAA                                           L    V    `    j    t    ~                                                         
            (    2    <    F    P    Z    d    n    x        @     @                  x6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6     7    7    7    7     7    (7    07    87    @7    H7    P7    `8    h8    p8    x8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8     9                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `#A`1@___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time     _  _mh_execute_header c n kingdomCards i s d updateCoins play handCard buyCard g whoseTurn fullDeckCount e main outOfPlay transfer Random P SelectStream GetSeed TestRandom     ompare ardEffect  +  ewGame umHandCards  -  .  nitializeGame sGameOver  0  huffle upplyCount coreFor  M  rawCard iscardCard ecrement  W  _  Card A S GreatHall  e  k  l      et ainCard  Cost Winners            ndTurn xhausted          dventurer mbassador      mithy teward                  Hand D    eck iscard        lantSeeds utSeed              +P	mP`P	P
H 
 ` 	 P PP P     d           M   d           X   f W       .          $          $   P         N  P         .          $          $   P          N  P          .           $           $   @         N  @         .  `        $  `        $            N           .  &        $  &        $            N           .  +        $  +        $            N           .  /        $  /        $             N            .  2        $  2        $            N           .  5       $  5        $             N            .  P6       $  P6        $   6         N  6         .  0m       $  0m        $   p         N  p         .  o     &  $  o        $   P          N  P          .  o     3  $  o        $   p         N  p         .  `w     <  $  `w        $            N           .  @z     F  $  @z        $   `          N  `          .  z     T  $  z        $   P          N  P          .  z     _  $  z        $            N           .  ~     n  $  ~        $   p         N  p         .  @     w  $  @        $   P         N  P         .         $          $   0         N  0         .         $          $            N           .  @       $  @        $            N           .         $          $             N            .          $           $             N            .          $           $             N            .         $          $            N           .         $          $            N           .         $          $   P          N  P          .          $           $   0         N  0         .  0     ,  $  0        $   $         N  $         .  @     ?  $  @        $             N         Q  &  @!    i  &   "      &  "      &  "      &  *      &  8+      &  H+      &  `+    
  &  p.      &  /    .  &  /    @  &  0    R  &  (0    d  &  80    w  &  P0      &   1      &  01      &  1      &  @2      &  4      &  5      &  p6      &  @8    "  &  @A    5  &  A    H  &   B    [  &  B    n  &  `C      &  C      &  C      &  0E       d             d             d             f W       .  `       $  `        $            N           .  p     "  $  p        $             N            .       -  $          $            N           .       8  $          $            N           .  `     C  $  `        $            N           .  @     Q  $  @        $             N            .  @     _  $  @        $            N           .        p  $           $            N           .         $          $            N           .  @       $  @        $             N           &  E      &  PF      &  F      &  F      &   G      &  PG      &  G       d             d           .  d           5  f 
W       .  `       $  `        $   p         N  p         .         $          $   0         N  0         .          $           $            N           .         $          $   0         N  0         .  @       $  @        $   `          N  `          .         $          $   P         N  P         .         $          $   P         N  P         .  @       $  @        $            N           .         $          $             N           &  "      &   H      &  $H      &  0H    -  &  `H    ?  &  H    Q  &  hI    c  &  I    u  &  I       d                                 0         @                             @     %         ;    @     N         `         v                                 p                     	    p    ,	        P	        n	    0    |	    P    	        	    @!    	     "    	    "    	    "    
    "    %
    *    )
    *    :
    8+    L
    H+    ^
    `+    p
    p.    
    /    
    /    
    0    
    (0    
    80    
    P0    
     1        01        1    )    @2    <    4    O    5    b    p6    u    @8        @A        A         B        B        `C        C        C        0E         E    1    PF    D    F    W    F    j     G    }    PG        G         H        $H        0H        `H        H        hI        I        I    #    0J    -    8J    7    @J    D    HJ    R    PJ    c    XJ    l    `J    ~    hJ        pJ        xJ        J        J        @                           `                                  (    0m     1    P6     =         F         Q         ^    +     h    ~     q    p     |    z         `w         o                  5         `         @                   `                  @z                  @              &    2     0          ?          K         X         b    &     k    o     x    @         @         `         /         z                                                                                                                 "            )            0            9            ?            F            M            U            ]            e            m            u            |                                                                                                                                                                                                                                                 @                                                                  /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 unittest3.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest3.o _main _exhausted _outOfPlay _decrement _transferHand _transferDeck _transferDiscard ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _compare _decrement _discardCard _drawCard _endTurn _exhausted _fullDeckCount _gainCard _getCost _getWinners _handCard _initializeGame _isGameOver _kingdomCards _main _newGame _numHandCards _outOfPlay _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _transferDeck _transferDiscard _transferHand _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder   File 'dominion.c'
Lines executed:0.00% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
    #####:   12:    return -1;
    #####:   13:  return 0;
    #####:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
    #####:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    #####:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
    #####:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
    #####:  215:    card = floor(Random() * state->deckCount[player]);
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
    #####:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
    #####:  226:  }
        -:  227:
    #####:  228:  return 0;
    #####:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
    #####:  315:  int currentPlayer = whoseTurn(state);
    #####:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
    #####:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
    #####:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
    #####:  532:    for (i = 0; i < state->discardCount[player];i++){
    #####:  533:      state->deck[player][i] = state->discard[player][i];
    #####:  534:      state->discard[player][i] = -1;
    #####:  535:    }
        -:  536:
    #####:  537:    state->deckCount[player] = state->discardCount[player];
    #####:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
    #####:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
    #####:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
    #####:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
    #####:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
    #####:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
    #####:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  562:    state->deckCount[player]--;
    #####:  563:    state->handCount[player]++;//Increment hand count
    #####:  564:  }
        -:  565:
        -:  566:  else{
    #####:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
    #####:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  575:    state->deckCount[player]--;
    #####:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
    #####:  579:  return 0;
    #####:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
    #####:  652:  int currentPlayer = whoseTurn(state);
    #####:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
    #####:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
    #####:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
    #####:  659:  int z = 0;// this is the counter for the temp hand
    #####:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
    #####:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
    #####:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
    #####:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
    #####:  823:      discardCard(handPos, currentPlayer, state, 0);
    #####:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
    #####:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
    #####: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
    #####: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
    #####: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1124:      state->playedCardCount++;
    #####: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
    #####: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
    #####: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
    #####: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
    #####: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
    #####: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
    #####: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
    #####: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
    #####: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
    #####: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
    #####: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
    #####: 1203:	  state->coins += 1;
    #####: 1204:	}
    #####: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
    #####: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
    #####: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
    #####: 1216:  state->coins += bonus;
        -: 1217:
    #####: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
    #####: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
    #####: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
    #####: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
    #####: 1273:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                    __text          __TEXT                                                  __stubs         __TEXT                                             __stub_helper   __TEXT              P                                __const         __TEXT          0    @       0                            __cstring       __TEXT          p    c      p                           __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                 0                                 __got           __DATA                                                    __nl_symbol_ptr __DATA                                      "           __la_symbol_ptr __DATA                                        $           __mod_init_func __DATA           !            !            	               __const         __DATA          @!          @!                            __data          __DATA          "          "                            __bss           __DATA          *    p                                       H   __LINKEDIT       P     @       0     `0                    "  0    0    0 @           H0    2         5   O      P       J  J  '   q  #                           N D                             /usr/lib/dyld             r7;k|0Y$       
  
 *              (                      8         
   /usr/lib/libSystem.B.dylib      &      5 p   )      5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     UHH H   H H}HuH       H}H}LELELMA	LMED9AD9HOH4H   H4A       H H   Hu E      HJ       H}H}DD9AD9HLH4H   H4A       H, H   H E   H H   H E    H H   H E]ffffff.     UHHH H   H f  H H   H   HEHEH]D  UHAWAVSHXE(DU D]]L5 I   L5x ]DMDEMUuEDUD]}(   HP H   HB EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D}  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPHq H   Hd UHu}HM   EEHMHMUUHuHup  Hc}w  H        E=   A=   HOH<H   H<AJ   H       M   @   HLH4H   H4@       H H   H Ej  H H   H MHEE    HO       M
   @
   HLH4H   H4@     HM H   H@ E    H    
   M
   @
   HLH4H   H4@      H       M}9A9HEH4H   H4A   y   H[       Hc}LEAHc}LEED9AD9HDH4H   H4A       H H   Hu E  Hj H   H] H^ H   HQ M   MHA H   H4 H5 H   H( M   M!Hp       M   @   HDH4H   H4@   $   H H   H HE@
      H       M   @   HDH4H   H4@   $   H H   H{ HE@      Hl H   H_ HE@   HU H   HH Ha       M   @   HDH4H   H4@   :   H H   H HE@   HE@   HE@   5   H H   H HE@   HE@   HE@   <   H H   H iU   )HMAHMA(   HMA   E   Ha #   "   M   @   HNH4H   H4@     H7 H   H* E    H &   %   M
   @
   HLH4H   H4@   <  H (   '   Hc}LEADMD9AD9HDH4H   H4A     Ha *   )   Hc}LEA   A   HDH4H   H4AS   H ,   +   Hc}LEA
   A
   HDH4H   H4A      H .   -   M   @   HDH4H   H4@   )   H H   H HcEHMD   $   H H   H HcEHMD   H H   H $   H H   H HcEHMD
   H H   Hw ]   Hs H   Hf HcEHMDHW H   HJ HK H   H> M   MzH. H   H! H" H   H M   MH H   H E    H"
 ;   :   M}9A9HLH4H   H4A     H H   H HcEHM?      E    H	 >   =   M   @   HLH4H   H4@   y   H] H   HP HcEHcMHUHH   Hi  H   HcEHM?     ?  H H   H M   M=H
 H   H
 E   H C   B   M
   @
   HLH4H   H4@   y   H
 H   H
 HcEHcMHUHH   Hi  H   HcEHM?     ?  H[
 H   HN
 M   M=H>
 H   H1
 H2
 H   H%
 M   MH
 H   H
 E    H J   I   M}9A9HLH4H   H4A      }Hu  H5i L   K   =    A=    HLHH   HA       H	 H   H	 E  Ht	 H   Hg	 Hh	 H   H[	 M   MHK	 H   H>	 E    H R   Q   M}9A9HLH4H   H4A   _   H	 H   H HcEHM8       HcEHM^      H H   H M   M\H H   H E    H W   V   M   @   HNH4H   H4@   I   Hg H   HZ HcEHMDp    HK H   H> M   MmH. H   H! HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    H \   [   M   @   HLH4H   H4@   O   Hs H   Hf HE   Hu[  EHQ H   HD M   Mg1H2 H   H% HE   Hu	  E    EH	 H   H EHP] UHH  H~  H HEH H   H  HH        HH    LcLG?  A   AA   HLH4H   H4A   #   HT H   HG      HH5+ H   H5 HcHHH   Hi  HHcLIc?    H       HcLA?      A    HOH4H   H4A     H H   H   HcH*?  Y  ,HcHcHHH   Hi  HHc    H 	      HcLE?  A   D9AD9HLH4H   H4A      H H   H    HcHcHHH   Hi  HHcHcHHH   Hi  HHM H   H@    H* H   H HcH?  ?  H H   H     Hq       9A9HLH4H   H4A      H H   H Hc HcHcHHH   Hi  HHcH?     ?  HA H   H4    H H   H     H   H H   H H H;E   H  ]  fffff.     UHH@H	 H   H	 }HuHv	       MMH}H}LcELMG?  A    AA    HNH4H   H4A     H'	 H   H	 E    H       MHc}LEE^  D9AD9HLH4H   H4A      H H   H HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HH` H   HS M   MHcEHM^  HcEHM?  HcEHM^      }HuMH 	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H H   H El  Hv H   Hi M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      H H   H HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   H5 H   H( E    H" H   H EH@]fff.     UHH H   H Hu}UH H   H MMHEHEUUHu       E    HZ       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H H   H HE         Q  Ho       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   HO H   HB HE            H    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   H H   H HE         H H   H H H   H H H   H H H   H} M   M1Hk H   H] UHM      ]UHAVSHPH  H   H  MUu}LEHz        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H  H   H  E  H        H}      A   HLH4H   H4A       H  H   H  E  }Hu  H5`        EE=   A=   HLHH   HAJ   H  
   	   M   @   HOH4H   H4@       H(  H   H  E   HE}uUMLEDMH$V  L     A   A=    =    MLOI   O       H  H   H  EJ   H  H   H  HE      HE   HuUAE    EH`  H   HS  EHP[A^]    UHH H  H   H  }HuH  H   H  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL  MLULK I   L= HDL HHDDLLHC  H=     A   A   Le  L]        LA   99MONI   N      H0  H   H#            H|o4  H4  HHcHH=L  H  H   Hq  Hd  H   HW  H^  =4  H=  HD  H   HFq  H  H   H      H1           @   HLH4H   H4@   W   H  H   H  HxH  H   H     \H  H   Hx  H             HV  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   H  H   H  HtH  H   H  H  H   H     1H  H   Hx  HHa      p1  H=  H  H   Hn  H0  H   H#      H  *   )   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHH   Hi  H4HcHcHcHH   Hi  HH]  H   HP         H5  H   H(  H   lH  /   .      @   HDH4H   H4@   l  H3  H58  1   0   =    A=    HNHH   HA      H  H   Hv     H   h2  H  4   3   Ah9A9ILLI   LA   -   H=  H  H   H
     d>   1H  H   H  H9      `H  H   H  H  H   H  GH  H   H      H  ;   :   HcLE8   D9AD9HNH4H   H4A      HC  H   H6  HcHcHcHH   Hi  HHcH  H   H     H  H   H      -  H=L  H  H    Hj  H  H   H  K-  H=  HR  H(   HTj  H]  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   H  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   Hp  H   Hc  +  H-  F   E       @   HOH4H   H4@M   H  H   G        @    HLH4H   H4@   #   H  H   H  G+  HcHcHH   Hi  H<~.      \h.  H1  K   J   \9A9HOH4H   H4A   #   HL  H   H?  *     H,  H   H   H?5  1HXY      THh  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H'  H   H  HX  P?   H  H   H  H  H   H     H  H   H      (  H=  H  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5o  W   V   AL9A9IOLI   LA   #   H  H   H  '  1H  H   H   H2  1HHV      DH  [   Z   HcLE8   D9AD9HLH4H   H4A      HK  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HU  @?   H  H   H  H  H   H     Hi  H   H\      &  H=  H  H8   Hc  H2  H   H%  HCX  %  H=  H  H@   Hb  H  H   H  H1H      H   H<T      8,%  H=  H3  HH   H5b  H>  e   d   H             A    HOHH   HA     H  H   H         H  h   g       @    HEH4H   H4@     Hc  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  HJ  H   H=  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  HB  m   l   HcLE8   D9AD9HLH4H   H4A      HU  H   HH     HcHcHH   Hi  HHcHcHH   Hi  HH  H   H     
H  H   H  HcHHc8   HcHH   Hi  HHcH8   8         H  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5]  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5  v   Au   A=    A=    MDNI   NA   &   HF  H   H9  H5  0H(  H   H  H  H   H      &   H  H   H     H  H   H  H  H   H  .H  H   H  .     H"  H5     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5,     A   A=    A=    MDNI   NA   &   H  H   H  HL4  (H  H   H  H  H   H  H  H   H      F  H=  HM  HP   HO[  H  H   H{  HQ    H=  H   HX   H[  1H         HL  H     A   A    A    MENI   NA$   9   H  H   H  H      H     HJ             @    HEH4H   H4@   ^  H]  H   HP  Hd*  H=        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH  H   H      HA           @   HLH4H   H4@   W   H  H   H  HHh  H   H[     \HE  H   H8      H        HDD9AD9HLH4H   H4A   {  H.        9A9HEH4H   H4A     H        HcLA8      A   HOH4H   H4A     Hf  H   HY  Hr        HcLA8       A    HOH4H   H4A   9   1H  H   H  HI  jH  H   H      H           @   HLH4H   H4@   W   H  H   H|  HbHe  H   HX     \HB  H   H5  H6  H   H)  H*  H   H  H  H   H     4H  H   H  H  H   H  H  H   H      :  H=  HA  H`   HCU  H  H   H  H DL    H=  H  Hh   HT  H        HcLA^  HcLA?     A   HNHH   HA     Hy        HcLA?      A    HOH4H   H4A   ~   H  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?    H        HcLA^      A    HOH4H   H4A   ~   H  H   H  HcH^     HcHcHH?  Hi  HUHcH^  ^     Hk  H   H^  H_  H   HR  HS  H   HF  ~  H        HcLA?      A    HDH4H   H4A     H  H   H      H        HcLE^  D9AD9HLH4H   H4A     H  H   H  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  H  H   H     H  H   H  HH|  H   Ho  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   H  H   H  MHHcf  H^  Hf     f  EH  H   H      HN           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4AR   Hg        HcL   A   HDH4H   H4A   2   H}  H   Hp  H           H        HcL   A   HDH4H   H4A9  H        HcL   A   HDH4H   H4A   HI        HcL   A   HDH4H   H4A   H        HcL
   A
   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   I   H  H   H  HNH64   H  H   H  H      H   H  H   H  H  H   H  H  H   H     ?Hu  H   Hh      <  H=  HC  Hp   HEJ  H>  H   H1  H C    H=  H  Hx   HI     H  H   H  H    H        HDD9AD9HLH4H   H4A   2  Hi        9A9HEH4H   H4A     H>  H   H1      H         HcLE8   D9AD9HLH4H   H4A     H        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1Hx  H   Hk  H+:   o  H        HcLE8   D9AD9HDH4H   H4A      H  H   H      H~        HcLE8   D9AD9HLH4H   H4A   ?   H  H   H  H  H   H     dHj  H   H]  ?   HY  H   HL  HM  H   H@     H*  H   H  H  H   H  H  H   H     }1H  H   H  H08        H=  H  H   HE  H        H      H   HcLALAHDHH   HA   #   H.  H   H!       H  H   H  HcHtp   tpH7        H=m  H  H   HD  1H  H   H  H         H6      3  H=  H:  H   H<D  HE        H             A    HEHH   HA   x   H  H   H  H   H	     H   H5  1He  H   HX  H`5        H=  H  H   HB  H  H   H      H      HDD9AD9HLH4H   H4A     H      9A9HEH4H   H4A   &  H~  H   Hq  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    H`  H   HS  HT  H   HG     H1  H   H$        H=Z  H  H   H@  H  H   H      H      HcLE8   D9AD9HLH4H   H4A      H%      HcLcLI   Mi  MA   A   HDH4H   H4A   p   H      9A9HEH4H   H4A   %   H  H   H  ?   H  H   H  H  H   H     H      @HOH4H   H4@   5     Hc  H   HV  H0     H0      HT         @   HLH4H   H4@   a         H  H   H  H~  H  H   H     RH~  H   Hq     U   Hc  H   HV  2   H=  H59  D=  H55  H   H5'  H  H  H   H	  H H;E   H(	  []   )v)hmyw     UHH0H  H   H  }HuH        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       Hm  H   H`  E  }Hu  H5)        =   A=   HLHH   HA       H  H   H  E*  HE   }M  H        AM9A9ILLI   LA       H  H   H  E   1H  H   H  HE      }HuM`  Hu   }EM   M)Hu   Hu      H5  H   H(  H)  H   H  H  H   H  E    H
  H   H  EH0]@ UHH  H   H   }HuH  H   H  MMHEHEHcUHuD]UHH H  H   H  }7      EEMHHHUHuh  H  HMHcHH=  He  H   HG9  Hh  H   H[  E    G  H=  H)  H   H9  H4  H   H'  E     H=  H  H   H8  H   H   H  E     H=H  H  H    H8  H  H   H  E     H=  Hu  H(   HW8  H  H   H  E    W  H=  H9  H0   H8  Hd  H   HW  E     H=  H  H8   H7  H0  H   H#  E     H=X  H  H@   H7  H  H   H  E     H=  H  HH   Hg7  H  H   H  E   g  H=  HI  HP   H+7  H  H   H  E   +  H=  H  HX   H6  H`  H   HS  E     H=h  H  H`   H6  H,  H   H  E     H=,  H  Hh   Hw6  H  H   H  E   w  H=  HY  Hp   H;6  H  H   H  E   ;  H=  H  Hx   H5  H  H   H  E     H=x  H  H   H5  H\  H   HO  E     H=<  H  H   H5  H(  H   H  E     H=   Hi  H   HK5  H  H   H  E   K  H=  H-  H   H5  H  H   H  E     H=  H  H   H4  H  H   H  E     H=L  H  H   H4  HX  H   HK  E     H=  Hy  H   H[4  H$  H   H  E   [  H=  H=  H   H4  H  H   H  E     H=  H  H   H3  H  H   H  E      H=\  H  H   H3  H  H   H{  E      H=   H  H   Hk3  HT  H   HG  E   k   H=  HM  H   H/3  H   H   H  E   /   H=  H5  2  H5  H   H5  EH  H   H  EH ] ]M=y-iYI9u@ UHH0H  H   H  UHu}MEEHMHMUUuu}HuHz        A=   A=   ILLI   LA       HL  H   H?  E   H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  Hf        M   @   HDH4H   H4@   d   Hd  H   HW  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  H  H   H  H  H   H  HcEHMTTE    H|  H   Ho  EH0]fffff.     UHHHI  H   H<  H}H9  H   H,  HEHEH}   HcHM8   H]    UHH  H   H  H}H  H   H  HEHEHM   ]fff.     UHH  H   H  u}HUH  H   H  MMUUHEHEE    E    H        MHc}LEE?  D9AD9HLH4H   H4A      H-        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    HS     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H	  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    H%        MHc}LEE^  D9AD9HLH4H   H4A      H        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E]UHH0H  H   H  H}H  H   H  HEHEH}EE    H        MHc}LEE8   D9AD9HLH4H   H4A      HV  H   HI  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HH  H   H  M   MHy        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   HS  H   HF  M   HE   "   H/  H   H"  HE       H  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    H<        M   @   HLH4H   H4@   O   HZ  H   HM  HE   HuEH8  H   H+  M   Mg1H  H   H  HE   Hu1EH0]@ UHH  H   H  H}H        H}H}LEAH    A    HDH4H   H4A       H  H   H  E     Hv  H   Hi  E    E    H4        M   @   HLH4H   H4@      H        Hc}LEAL    A    HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   M	H=        M   @   HMH4H   H4@       Hc  H   HV  E      HK  H   H>  E    H8  H   H+  E]fD  UHH@H!  H   H  }HuH  H   H  MMHEHEE    E    H        MHc}LEE8   D9AD9HLH4H   H4A     H        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       HJ  H   H=  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MHr     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       Hj  H   H]  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MHb        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H}  M   MH        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A     H        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H  H   H  M   MH
        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H2  H   H%  M   MH  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MHr  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       HR  H   HE  M   MH  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H|  E    H  1   0   MHc}LEE^  D9AD9HLH4H   H4A     H  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       Hj  H   H]  M   MH  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH
  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H}  M   MH  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMHz  H   Hm  Hn  H   Ha  M   M+HQ  H   HD  EH@]ff.     UHH0H1  H   H$  H}HuH  H   H  HEHEHMHME    H        M   @   HLH4H   H4@      H        MH}DD9AD9HMH4H   H4A   (   H  H   Hx  HcEHM+   He  H   HX  }HuHcuHMHB  H   H5  H6  H   H)  M   MH  H   H  E    E    H        M   @   HLH4H   H4@      H]        Hc}LEAHc}LEED9AD9HOH4H   H4A      H|  H   Ho  MMHj  H   H]  H^  H   HQ  M   M
HA  H   H4  HcEHMUH}-EE    H|        M   @   HLH4H   H4@      H2        Hc}LEADMD9AD9HDH4H   H4A   m   H        M}9A9HOH4H   H4A   (   Hd  H   HW  HcEHM   HD  H   H7  H8  H   H+  M   MH  H   H  E    E    H        M   @   HLH4H   H4@      H         Hc}LEAHc}LEED9AD9HOH4H   H4A      H~  H   Hq  MMHl  H   H_  H`  H   HS  M   M
HC  H   H6  HcEHMUE    H  &   %   M   @   HLH4H   H4@      H  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   H  H   H  HcEHM   #   H  H   Hz  HcEHM    Hl  H   H_  H`  H   HS  M   M1HA  H   H3  H0]D  UHH   H.  H HEH  H   H  HH  H   H  HHH       Hd           @   HLH4H   H4@     H        HcLA?     A   HLH4H   H4A   ,   H  H   H  H[H#H=Y{  HcH8      HcHcLI   Hi  IA y  H        A   A   IDLI   LA   H  
   	      @   HDH4H   H4@M   H           @   HDH4H   H4@   +   H  H   H     \   H|  H   Ho  Hc HcH8   8      H(  H   H  3H  H   H
  H               @    HMH4H   H4@      H  H   H     Hc HcH^     ^  HcHcLI?  Hi  IA   "1HC  H   H6  H.   H  HH;U   1H   ]u  @ UHH  H   H  HUu}MH        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   Hc  H   HV  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  H        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   H  H   H  HcEHM8   8   \  H6        Hc}LEA8      A   HDH4H   H4A   5   H'  H   H  HcEHM8   8      H  H   H  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   HF  H   H9  1H8  H   H*  ]     UHH0H  H   H  H}uH  H   H  HEHEMMH}REE    H        M   @   HLH4H   H4@   H   HW  H   HJ  }HuEH<  H   H/  M   Mn1H  H   H  }uHU1EH0]@ UHH0H  H   H  H}uH  H   H  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPH  H   H  MUuH}DEHEHEMMUUuu}}H}H=     A   AEE=   A=   MDNI   NA   7   H^  H   HQ  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   H  H   H  HE      HE   <   1H  H   H  }uHU1}uHUEEH  H   H     H  H   Hx  }uHUQ1EHP]@ UHHPH  H   Ht  UuH}MHEHEMMUUuuH}H==     A   AEE    E=   A=   MONI   NAJ   H        M    @    HLH4H   H4@       H  H   H  E  H        M}9A9HDH4H   H4A       H  H   Hr  E{  Hg  H   HZ  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  H        M}9A9HEH4H   H4A      Hk        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       HQ  H   HD  M   MH9  H   H,  H-  H   H   M   MdHh        M}9A9HLH4H   H4A       H  H   H  E_  H  H   H  MHcEHULLE    H        MH}DD9AD9HLH4H   H4A      H        M}9A9HEH4H   H4A   E   1H+  H   H  HcEHcMHuH   Hi  H<HuM:EH  H   H  H  H   H  M   M1H  H   H  }uHUYE    EH  "   !   M}9A9HLH4H   H4A     Hk  H   H^  E    H8  %   $   MHc}LEE8   D9AD9HLH4H   H4A      H  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      H  H   H  }uHUE9   Hy  H   Hl  Hm  H   H`  M   MHP  H   HC  HD  H   H7  M   M'H'  H   H  E    H  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=j  H5bj  VM  1H5Tj  /AVUMQ  	   H5!  \V     H5%j  [H1AVQ     H5:  -V     H5i  1AVQ     H5  U     H5i  VI1AVpQ  a   H5  U     H5i  ;|1AVAQ     H5  U     H5i  ] t1AVQ     H5V  qU     H5oi  T1AVP     H5  BU     H5Hi  w1AVP     H5   U     H5&i  YAr1AVP     H5  T  	   H5 i  j1AVVP     H5  T  
   H5h  a'Hr1AV'P     H5  T     H5h  @1AVO     H5L  WT     H5h  -1AVO     H5-  (T     H5ph  "mw1AVO     H5~  S     H5Lh  |1AVkO  G   H5  S     H5&h  b1AV<O  .   H5  S     H5h  W71AVO     H51  lS     H5g  `1AVN  :   H5  =S     H5g  eW1AVN    H5#  S     H5g  Qw1AVN     H5  R     H5ng  :/T1AVQN     H55  R     H5Hg  r%1AV"N     H5v  R     H5%g  Ba1AVM     H5  RR     H5g  PR1AVM     H5X  #R     H5f  Ce&1AVM     H5a  Q     H5f  #e,1AVfM  /   H5J  Q     H5f  Ql1AV7M  
   H5  Q  qU  ^  H]fD  UHHl{      HY{      HF{      H3{      H {      H{      Hz      Hz      Hz      H{      H{      H{      H {      H}      H|      H|      H|      H|      H|      H|      H|      Hm|      HZ|      HG|      H4|      H!|      H|      H{      H{      H{      H{      H{      H{      H{      Hv{      Hc{      HP{      H={      H*{      H{      H{      Hz      Hz      Hz      Hz      Hz      Hz      Hz      Hlz      HYz      HFz      H3z      H z      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Huy      Hby      HOy      H<y      H)y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      H~x      Hkx      HXx      HM{      H:{      H'{      H{      H{      Hz      Hz      Hz      Hz      Hz      Hz      H|z      Hiz      HVz      HCz      H0z      Hz      H
z      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hry      H_y      HLy      H9y      H&y      Hy      H y      Hx      Hz      Hwz      Hdz      HQz      H>z      H+z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hmy      HZy      HGy      H4y      H!y      H6z      H#z      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hxy      Hey      HRy      H?y      H,y      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hvy      Hcy      HPy      H=y      H*y      Hy      Hy      Hx      Hfy      HSy      H`y      HMy      HZy      HGy      Hz      H	z      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hqy      H^y      HKy      H8y      H%y      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hzx      Hgx      HTx      HAx      Hy      Hx      Hxy      Hey      HRy      H?y      H,y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hnx      H[x      HPy      H=y      H*y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hlx      HYx      HFx      H3x      H x      Hz      Hz      Hwz      Hdz      HQz      H>z      H+z      Hz      Hz      Hy      Hy      Hy      Hy      Hy      Hy      Hy      Hmy      HZy      HGy      H4y      H!y      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hvx      Hcx      HPx      H=x      H*x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hlw      HYw      HFw      H3w      H w      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Huv      Hbv      HOv      H<v      H)v      Hv      Hv      Hu      Hx      Hx      Hw      Hw      Hw      Hw      Hw      H@y      H-y      Hy      Hy      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hox      H\x      HIx      H6x      H#x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Hxw      Hew      HRw      H?w      H,w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hnv      H[v      HHv      H5v      H"v      Hv      Hu      Hu      Hw      Hw      Hw      Hw      Hrw      H_w      HLw      H9w      H&w      Hw      H w      Hv      Hv      Hv      Hv      Hx      Hx      Hx      Hx      Hx      Hx      Hx      Hlx      HYx      HFx      H3x      H x      Hx      Hw      Hw      Hw      Hw      Hw      Hw      Hw      Huw      Hbw      HOw      H<w      H)w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      H~v      Hkv      HXv      HEv      H2v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Htu      Hau      HNu      H;u      H(u      Hu      Hu      Ht      Ht      Ht      Ht      Hsx      H`x      HMx      H:x      H'x      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      H|w      Hiw      HVw      HCw      H0w      Hw      H
w      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hrv      H_v      HLv      H9v      H&v      Hv      H v      Hu      Hu      Hu      Hu      Hu      Hu      H{u      Hhu      HUu      HBu      H/u      Hu      H	u      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hqt      H^t      HKt      H8t      H%t      Ht      Hs      Hs      Hs      Hs      Hw      Hw      Hw      Hzw      Hgw      HTw      HAw      H.w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hpv      H]v      HJv      H7v      H$v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hyu      Hfu      HSu      H@u      H-u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hot      H\t      HIt      H6t      H#t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hxs      Hes      HRs      H?s      H,s      Hs      Hs      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hnv      H[v      HHv      H5v      H"v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hwu      Hdu      HQu      H>u      H+u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hmt      HZt      HGt      H4t      H!t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hvs      Hcs      HPs      H=s      H*s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hlr      HYr      HFr      H3v      H v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Huu      Hbu      HOu      H<u      H)u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      H~t      Hkt      HXt      HEt      H2t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hts      Has      HNs      H;s      H(s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      H}r      Hjr      HWr      HDr      H1r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hkt      HXt      HEt      H2t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hts      Has      HNs      H;s      H(s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      H}r      Hjr      HWr      HDr      H1r      Hs      Hss      H`s      HMs      H:s      H's      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hos      H\s      HIs      H6s      H#s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hxr      Hes      HRs      H?s      H,s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hnr      H[r      HHr      H5r      H"r      HGs      H4s      H!s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hvr      Hcr      HPr      H=r      H*r      Hr      Hr      Hq      Hq      Hq      Hr      Hr      Hzr      Hgr      HTr      HAr      H.r      Hcr      HPr      Hs      Hs      Hs      Hs      Hs      Hns      H[s      HHs      H5s      H"s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hwr      Hdr      HQr      H>r      H+r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hmq      HZq      HGq      H4q      H!q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hvp      Hcp      H r      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Huq      ] UHH=H5i=  ]UHHg  HL  H HEHq  H   Hsq  1E    >  >  H=B  1f  HL?  (   ALUEJ  E   E    HLLHLH=  HHH=  H =     HHuU
DHEE  Hp        =   AAAALcI    AI    HEH<H   H<A      H=C  H5A  0   HA  <  H+p  H   Hp     HHu1f  ILHH<  UHH
CHE  Ho        =   AAAALcI    AI    HEH<H   H<A      H=C  H5@  3   H-@  ;  HTo  H   HGo     HHu1f  ILHH;  UHHBHE$	  Hn  
   	   =   AAAALcI    AI    HEH<H   H<A      H=
B  H5?  6   HR?  :  H}n  H   Hpn     HHu1f  ILHH:  UHHAHE]
  Hm        =   AAAALcI    AI    HEH<H   H<A      H=A  H5 >  9   Hp>  9  Hm  H   Hm  H=j>  Hm  H   Hm   :  H=pG  H?H;}   1Hg  ]s9  ffff.     UHSH8H@m  H   H3m  H}H0m  H   H#m  HEHEE    HM   UHcMHuH   Hi  HUE   Hl        MHc}LEE8   D9AD9HLH4H   H4A   y   Hl  H   Hl  HcEHcMHUH   Hi  HHcEHM8   8   HSl  H   HFl  M   M3H=<   8  1uHUE<Hk     A   ALUAf     LcL]C^  u99MDNI   NE      Hk  H   Hk  E   Hek  
   	   M    @    HEH4H   H4@   K   H=<  Hlk  H   H_k  uHEf     HcHU^   s7  E%   H=<  H)k  H   Hk   I7  EHk  H   Hk  EH8[]@ UHHpHqD  H HEHj  H   Hj  H}H=;  Hj  HHj  HEHEE   HM   UHcMHu8   UHcMHu8   HHuH   HHH)H Hux6  E    EHCj        MHc}LEE8   D9AD9HLH4H   H4A   d   Hj  H   Hj  HcEHcMHUH   Hi  H4HcEHM4Hi  H   Hi  M   MHHi  H   Hi  M   MHki        M    @    HMH4H   H4@   a   H=>:  Hbi  H   HUi  u '5  1}uHUEEH5i  H   H(i  MMUHi  H   Hi  E    Hh        M}9A9HLH4H   H4A     H`h        Hc}LEAH}Df  D+MA   IcLUE^  D9AD9HEH4H   H4A      Hnh  H   Hah  E    H=9  HTh  H   HGh  HEf  +M   HcHU^  HcEHU 3  EHh  H   Hh  M   MH]g        M    @    HEH4H   H4@   *   H=v8  Hg  H   Hg   3  E%   H=[8  Hg  H   Hg   2  EHD@  Hug  H   Hgg  UE   HMHH H;EU   EH]'2  UHSH8H0g  H   H#g  H}H=7  HEHEE    HM   UHcMHu8      UHMf  U 42  1   uHUEHf     A   AMLcUL]C8   99MDNI   NE   j   H^f        MH}Df  D9AD9HDH4H   H4A      H7f  H   H*f  E   He        M    @    HEH4H   H4@   *   H=6  He  H   He   0  E%   H=m6  He  H   He   0  EH=Y6  He  H   He  uHcEHM8   MHEDf   0  MEH8[]UHAVSH@H^e  H   HQe  H}H=,6     HMHME    HU   uHcULEA8   EuELcELMC8   -   E /  1}uLELEHd     A   AMLcUL]C8      LcLc]H]H   Mi  LB49A9MDNI   NAE      Hed  H   HXd  E   H2d        M    @    HEH4H   H4@   *   H=f4  Hd  H   Hd   .  E%   H=K4  Hc  H   Hc   .  EH=4  Hc  H   Hc  uHcEHM8      HcHcMLEI   Hi  IA J.  UEH@[A^]D  UHHH=q4  H5r0  U   1H54  wAUUM     H5`  l     H54  <1AU     H5"a  =     H54  ,1AU     H5ca       H5c4  =1AU     H5a       H5>4  1AUQ  	   H5%b      (  H]UHHd`      HQ`      H>`      H+`      H`      H`      H_      H_      H_      H_      H_      H_      H_      Hm_      HZ_      HG_      H4_      H!_      H`      H_      H_      H_      H_      H_      H_      H_      Hv_      Hc_      HP_      H=_      H*_      H_      H4`      H!`      H`      H_      H_      H_      H_      H_      H_      H_      Hv_      Hc_      HP_      H=_      H*_      H_      H_      H^      H^      H^      H^      H^      H^      H^      H_      Hq_      H^_      HK_      H8_      H%_      H_      H^      H^      H^      H^      H[_      HH_      H5_      H"_      H_      H^      H^      H^      H^      ]UHH=H5I(  ]UHH^  H   H^  H^          L9  HE  HEG  Lc^  OHELHUHHHi  Lc|^  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   H9  H6^  H   H(^  HMHc]  H2   H8  H^  H   H ^  HMHHc]  H**  H8  H]  H   H]  Hc]  H*^(]UHH@H]  H   H]  H}1H]  H   H]  HEHEHEm HE  ,]     "]  M  H}  M]  E   H:]        M   @   HLH4H   H4@   K  H\        m L7  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   H6  Hc\  H   HU\  HMHcUH/   H6  H>\  H   H0\  HMHHcUHH\  H   H\  H\  H   H\  M   MkH[  H   H[  H@]fUHHH\  H   H\  }H\        MM}   =[  =[      A    HDH4H   H4A   n   H(\        Z      @    HEH4H   H4@   !   [H[  H   H[  H[  H   H[  H]    UHH0HZ  H   HZ  H}HZ        H}H}E LEI    AI    HOH4H   H4A   )   HqZ  H   HcZ  HEHHHUH7Z        H}H    AH    HLH4H   H4A   .   1HZ  H   HZ  $  1HHUHY        H}H    AH    HDH4H   H4A     HY  H   HY  H[Y     
   } @@@HEH4H   H4@   "  H=4*   !#  H=\*  HuE #  1H5X  1   A   ALUL9AL9MLJ<H   J<AEU   "   HY  H   HX  H}MEHwX        $EE< A< HEH<H   H<A%   H=)  HX  H   HX   )"  EHX  H   HX  HX  H   H}X  H.2  HwX  H   HiX  HMHcW  HH0]@ UHHMX  H   H@X  H}H1  H6X  H   H(X  HMHMHcV  HHUH]fff.     UHH0HAX  H   H4X  1H3X  H   H&X  E %   +HE    HW        H}H'  AH'  HLH4H   H4A   E   HW  H   HW  EHW  H   HW  HEH   HEnH}   H}Z$EY   H}1H=)W        M    A    HEH4H   H4AE   "   HW  H   HW  H}Y  MEHV  
   	   $EE< A< HEH<H   H<A   *   H=&  HV  H   HV   c  E%   H=&  HV  H   HV   9  EHV  H   HvV  H0]     UHHH=&  H5R!  M_   1H5 '  hnAM_UM     H5!T  L     H5&  8I1AM_     H5"T       H5&   1AM_     H5ST       H5&  r~61AM_`     H5T       H5~&  XH1AM_1     H5T       H5\&  
1AM_     H5T  a  <  g  H]UHH4S      H!S      HS      HR      HR      HR      HJS      H7S      H$S      HS      HR      HR      HR      HR      HR      HR      HR      HS      HnS      H[S      HHS      H5S      H"S      HS      HR      HR      HR      HR      HR      HR      HR      HwR      HdR      HQR      H>R      H+R      HR      HR      HR      HR      HR      HR      HR      HR      HR      HuR      HbR      HR      HR      HR      HR      HR      HR      HR      HzR      HgR      HTR      HAR      H.R      HR      HR      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH=$    HH=$    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IHz  IK|&I  HHHL  AD./tB3/IHLLL  EL<$HYQ  ZQ      1H  2  tL5D"     -Q  H=Q      1  1  L5"  uhH-P  H]fffff.     Ht/u   HE  /H=P      1@  |1         =a1  L  HP  HP      H|P      HyP      RP  u&1     HHGP  HDP        1   Hl  H=P  f  HUP  HtfD0  1      E1Hf  HHO  H     8H%  HH-O  q  HH52"  1HH  O  HO      HO      H-O  1H  t)H H  1H  HHYO  H-ZO  1   H  -O  H-FO  tbHEH;/O  vrH  H  HH  HO  H-O  HO  N  adcgHN  HCHN  t?+adcgHN  HHN  1gHN  adcgHN  HCHN  HSH;N  v8H  H  H=oN  H  H`N  HaN  HbN  <N  HEN  A74HHN  HCH=N  t?HKH;%N  v2H  H  H=N  H  HM  HM  HM  HM  D,HM  H[A\A]A^A_]  8H#  HH-M  Z  HH5  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=.M   1  T$D$M  u?H"M  HCH;M  v+H  H  H=L  H  HL  HL  HL  HL     HL  L{L=L  MtLY  Hl(L  tfHCH;L     H  H  H=kL  H  H\L  H]L  H^L  7L  ,HML  HCHBL  u\H$L  B,8H)L  HHL  HL  D$HL  HHL     HK  B,8HK  HCHK  HKH;K  vVH  H  H=K  H=  HK  HK  HK  yK  D$HK  HCHK  u^HeK  D$HjK  HCH_K  HKH;LK  v2H  H  H=-K  H  HK  HK  H K  H	K  T$H-K  H]H K  EtjJ  u?HEH;J  v2H  H  H=J  HM  HJ  H-J  HJ  HJ  $HJ  HHJ  My  L&  HHPJ  uKHCAH;UJ  v>H  H  H=6J  H  H'J  H(J  D=	J  H"J  E1HJ  ,H-J  HH-J  L  IAtALHH;I  v2H H  H=I  HL  HI  HI  H-I  H-I  HLL  H-I  LH-I  L'  H   H)NI  u?L4+L;5VI  v2I I  H=7I  L  H(I  L5)I  H-*I  H-I  1HHn  HI  H[A\A]A^A_]     UAWAVAUATSPIAH=H      L%H  H     L%H  ID$H;H  }  I  I  H=H  L  HwH  L%xH  HyH  RH    HdH  HCHYH  C,6E1  ;  H[A\A]A^A_]HH  B#ID$HH  E1       BL#Il$H-G    D9  DH  IEtvAN1AtH+HH-G  I   tOHILAVp)f.     Ht+H-|G  HqH4+H}H=iG  H1HHHuL%NG  B#  H?G  HH4G  C,6jHG  B   HG  HCHG  C,6HKE1H;F  v5H  H  H=F  Hd  HF  HF  E1HF  HF  ,HF  HHF  E  M   Lff.     I] H] I] UF  u@L%iF  ID$H;UF  v+I  I  H=6F  L  H'F  L%(F  H)F  HF  HHF  HIAu   fff.     Im E  u?HCH;E  v2H  H  H=E  HF  HE  HE  HE  HE  H,HE  HHE  IAuLH[A\A]A^A_]  HF  H8H4E  H5h  H,  H8HE  H5  1H[A\A]A^A_]N  fffff.     SH=D     HE  D  tzHD  HCH;D     H  H  H=D  HK  HD  HD  HD  D     HD  HKHD       oHgD  HCHiD        LHCHND  	l  DHKH6D     HD     HD  HKHD  HCH;C    H  H  H=C  Hi  HC  HC  HC  C  	   HC  HKHC     uS       HC     HzC  HHoC  HXC  
	   HZC  HHOC  H8C  
    H:C  HH/C  HC  
    HC  HHC  HB  
HB  HHB  HB      HB  HHB  HB      HB  HHB  HB      HB  HHB  H|B      H~B  HHsB  H\B      H^B  HHSB  H<B      H>B  HH3B  HB     HB  HHB  HA      HA  [HA  	   HA  HKHA  HCH;A  vbH  H  H=A  H9
  HA  HA  HA  uA      HA  HKH|A     ? HUA      HWA  HKHLA  HCH;9A     H  H  H=A  H	  HA  HA  H	A  @      H@  HKH@     ZH  H8H@  H5  H  H8H@  H5X  1[  H@      H@  HKH@  HCH;l@  v]H  H  H=M@  H  H>@  H?@  H@@  @     H+@  HCH @  $ H?     H @  HCH?  HKH;?  v[H  H  H=?  HS  H?  H?  H?  ?      H?  HCH?   Hv?      Hx?  HCHm?  HKH;Z?  v]H  H  H=;?  H  H,?  H-?  H.?  ?      H?  HCH?  R H>      H>  HCH>  HKH;>  v]H  H  H=>  HA  H>  H>  H>  }>      H>  HCH>   Hb>      Hd>  HCHY>  HKH;F>  v]H  H  H='>  H  H>  H>  H>  =      H>  HCH=  ~ H=      H=  HCH=  HKH;=  v]H  H  H==  H-  H=  H=  H=  i=      H{=  HCHp=   HN=      HP=  HCHE=  HKH;2=  vZH  H  H==  H  H=  H=  H=  <      H<  HCH<  u%H<      H<  HCH<  HKH;<  v]H  H  H=<  H  H}<  H~<  H<  X<     Hj<  HCH_<  C H=<     H?<  HCH4<  HKH;!<  H  H  H=;  H  H;  H;  H;  @ AVSPH=;   N  ;  uIH;  HKH;;  v5H  H  H=;  H  H;  H;  c;  1Hx;  Ha;  H
    H5b;  HH5W;  H=@;  tH-;     {  H=$;  ]  sH5V;       u4
  8H  L0H:    HH5z  1LH  H=:  H5;  @  H:      H:      H=:    =`       H{:      Hx:      H=Y:  H[A^  ffff.     SH     HH@    H=O:   tHN:  HAHC:  [H::  H+:  [f     SH:  fD  1H[Hu[Pffff.     HGH9    H=9  HuH9      H9      Xfff.     SH     HH@    H=9   tH9  HAH9  [H9  H{9  [f     SHh9  fD  1H[Hu[Pffff.     HGH59  F  H=)9  HuH!9      H9      Xfff.     AVSPIHHtA     HH@    H=8   tH8  HAH8  H8  H8  MtA      L0H@    H=8   tH8  HAH8  Hy8  Hj8  t8  tH[A^a8  H=1   H=.%   H=H[A^   %   %  %  %  %  %
  %  %  %  %  %  %  %  %  %  %  %   %"  %$  %&  %(  %*  %,  %.  %0  %2  %4  %6  %8  %:  %<  %>    L5  AS%%  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h~  h  h  h  h  h                    	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for: discardCard()
===================
      unittest4.c discardSingleCard(&state) == 1 discardWholeHand(&state)==1 trashCard(&state)==1 checkHandOrder(&state)==1 All tests passed!

 	Testing discard of last card in hand:
 	Test passed. Target:%d, Last played card %d
 	##TEST FAILED. Target:%d, Last played card %d##
 	Testing discard of every card in hand:
 		Discarding card at hand index %d
 		Card in played: %d, Target: %d
 	Test passed.
 	##TEST FAILED.##
 	Testing trash discard:
 	Test passed.  	##TEST FAILED.  Target hand count: %d, Actual: %d; Target played count: %d, Actual: %d
 	Testing that hand is not re-ordered post discard:
 Target card: %d, Actual: %d; Order preserved.
        /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest4.gcda      main              discardSingleCard               discardWholeHand trashCard checkHandOrder       
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           8       8           !       P   P        P        d         ` P     W       0 p      @  0   @   a       zR x         zR x         zR x         zR x  <             ABB B(B0A8A@         \   h               <   |   hh       ABB B(B0A8A@      <             ABB B(B0A8A@            8,	       A  $     Hs       BAA      D  G        A     d          A       D        A          G        A       0        A       0D        A    $     `        BAA                                                
            (    2    <    F    P    Z    d    n    x                                                                    "                           x6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6     7    7    7    7     7    (7    07    87    @7    H7    P7    `8    h8    p8    x8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8     9                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `#A`1@___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time     _  _mh_execute_header c n kingdomCards i s d updateCoins play handCard buyCard g whoseTurn fullDeckCount endTurn main trashCard Random P SelectStream GetSeed TestRandom     ompare ardEffect heckHandOrder  ,  ewGame umHandCards  .  /  nitializeGame sGameOver  1  huffle upplyCount coreFor  N  rawCard iscard  X  `  Card A S GreatHall  f  l  m      et ainCard  Cost Winners                    dventurer mbassador    Card SingleCard WholeHand    mithy teward                      lantSeeds utSeed                ,P	mP`P	P
H 		 ` 	 P PP P         d           M   d           X   f W       .           $           $   P         N  P         .  P        $  P        $   P          N  P          .          $          $   @         N  @         .          $          $            N           .  p'        $  p'        $            N           .  P,        $  P,        $            N           .  `0        $  `0        $             N            .  `3        $  `3        $            N           .  P6       $  P6        $             N            .  6       $  6        $   6         N  6         .  m       $  m        $   p         N  p         .   p     &  $   p        $   P          N  P          .  pp     3  $  pp        $   p         N  p         .  w     <  $  w        $            N           .  z     F  $  z        $   `          N  `          .   {     T  $   {        $   P          N  P          .  p{     _  $  p{        $            N           .  P     n  $  P        $   p         N  p         .       w  $          $   P         N  P         .         $          $   0         N  0         .  @       $  @        $            N           .         $          $            N           .  `       $  `        $             N            .         $          $             N            .         $          $             N            .  @       $  @        $            N           .          $           $            N           .  0       $  0        $   P          N  P          .         $          $   0         N  0         .       ,  $          $   $         N  $         .       ?  $          $             N         Q  &  @!    i  &   "      &  "      &  "      &  *      &  8+      &  H+      &  `+    
  &  p.      &  /    .  &  /    @  &  0    R  &  (0    d  &  80    w  &  P0      &   1      &  01      &  1      &  @2      &  4      &  5      &  p6      &  @8    "  &  @A    5  &  A    H  &   B    [  &  B    n  &  `C      &  C      &  C      &  0E       d             d             d             f W       .         $          $            N           .       "  $          $            N           .       5  $          $            N           .        G  $           $   0         N  0         .  0     R  $  0        $   @         N  @         .  p     b  $  p        $             N            .       x  $          $   P         N  P         .         $          $             N           &  E      &  F      &  F      &  @G      &  G       d             d             d             f 
W       .        R  $           $   p         N  p         .  p     Z  $  p        $   0         N  0         .       f  $          $            N           .       t  $          $   0         N  0         .       }  $          $   `          N  `          .  @       $  @        $   P         N  P         .         $          $   P         N  P         .         $          $            N           .         $          $             N           &  "      &  G      &  G      &   H      &  0H      &  H      &  8I    /  &  PI    A  &  I       d          S    0     {                               p                                                  ,         B         h             0                @                        0    	        :	        H	        i	    @    y	    @!    	     "    	    "    	    "    	    "    	    *    	    *    
    8+    
    H+    *
    `+    <
    p.    N
    /    `
    /    r
    0    
    (0    
    80    
    P0    
     1    
    01    
    1    
    @2        4        5    .    p6    A    @8    T    @A    g    A    z     B        B        `C        C        C        0E        E        F        F    #    @G    6    G    I    G    Q    G    ^     H    o    0H        H        8I        PI        I         J        J        J        J         J    	    (J        0J    $    8J    6    @J    E    HJ    T    PJ    o    XJ    z             p                                     @                   m         6         0                   `     	                  .    P,     8    P     A    p{     P    w     Z    pp     c    @     o    P6     y                                        P         z                            `3                           @                  p'     %     p     2          =    `0     J     {     U            c            l            ~                                                                                                                                                                                                                                                !            )            /            7            >            G            N            U            ]            g            o            u            q  r  s  v  w  x  y  z  {  |  }  ~                                          t  u       @q  r  s  v  w  x  y  z  {  |  }  ~                                            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 unittest4.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/unittest4.o _main _discardSingleCard _discardWholeHand _trashCard _checkHandOrder ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr21 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr21 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _checkHandOrder _compare _discardCard _discardSingleCard _discardWholeHand _drawCard _endTurn _fullDeckCount _gainCard _getCost _getWinners _handCard _initializeGame _isGameOver _kingdomCards _main _newGame _numHandCards _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _trashCard _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder   File 'dominion.c'
Lines executed:0.00% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
    #####:   12:    return -1;
    #####:   13:  return 0;
    #####:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
    #####:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    #####:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
    #####:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
    #####:  215:    card = floor(Random() * state->deckCount[player]);
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
    #####:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
    #####:  226:  }
        -:  227:
    #####:  228:  return 0;
    #####:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
    #####:  315:  int currentPlayer = whoseTurn(state);
    #####:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
    #####:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
    #####:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
    #####:  532:    for (i = 0; i < state->discardCount[player];i++){
    #####:  533:      state->deck[player][i] = state->discard[player][i];
    #####:  534:      state->discard[player][i] = -1;
    #####:  535:    }
        -:  536:
    #####:  537:    state->deckCount[player] = state->discardCount[player];
    #####:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
    #####:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
    #####:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
    #####:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
    #####:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
    #####:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
    #####:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  562:    state->deckCount[player]--;
    #####:  563:    state->handCount[player]++;//Increment hand count
    #####:  564:  }
        -:  565:
        -:  566:  else{
    #####:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
    #####:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  575:    state->deckCount[player]--;
    #####:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
    #####:  579:  return 0;
    #####:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
    #####:  652:  int currentPlayer = whoseTurn(state);
    #####:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
    #####:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
    #####:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
    #####:  659:  int z = 0;// this is the counter for the temp hand
    #####:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
    #####:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
    #####:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
    #####:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
    #####:  823:      discardCard(handPos, currentPlayer, state, 0);
    #####:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
    #####:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
    #####: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
    #####: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
    #####: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1124:      state->playedCardCount++;
    #####: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
    #####: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
    #####: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
    #####: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
    #####: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
    #####: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
    #####: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
    #####: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
    #####: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
    #####: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
    #####: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
    #####: 1203:	  state->coins += 1;
    #####: 1204:	}
    #####: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
    #####: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
    #####: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
    #####: 1216:  state->coins += bonus;
        -: 1217:
    #####: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
    #####: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
    #####: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
    #####: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
    #####: 1273:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                  __text          __TEXT          0           0                           __stubs         __TEXT                                             __stub_helper   __TEXT              P                                __const         __TEXT              @                                   __cstring       __TEXT                                                 __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                0                                __got           __DATA                                                  __nl_symbol_ptr __DATA                                    "           __la_symbol_ptr __DATA                                      $           __mod_init_func __DATA                                   	               __const         __DATA          @          @                            __data          __DATA                                                __bss           __DATA                                                     H   __LINKEDIT       @     0             .                    "  0           @           H     "         X%   >      P       >  >  %   c  #                           = D                             /usr/lib/dyld             _ez;<hI$       
  
 *              (                      8         
   /usr/lib/libSystem.B.dylib      &      $ h   )      X%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     UHH H   H H}HuH       H}H}LELELMA	LMED9AD9HOH4H   H4A       HR H   HE E      H       H}H}DD9AD9HLH4H   H4A       H H   H E   H H   H E    H H   H E]ffffff.     UHHH H   H f  H H   H g  HEHEH]D  UHAWAVSHXE(DU D]]L5V I   L5H ]DMDEMUuEDUD]}(   H  H   H EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D}  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPHA H   H4 UHu}HM   EEHMHMUUHuHu  Hc}  H       E=   A=   HOH<H   H<AJ   H       M   @   HLH4H   H4@       H H   H~ Ej  Hs H   Hf MHEE    H       M
   @
   HLH4H   H4@     H H   H E    H    
   M
   @
   HLH4H   H4@      Hp       M}9A9HEH4H   H4A   y   H+       Hc}LEAHc}LEED9AD9HDH4H   H4A       HR H   HE E  H: H   H- H. H   H! M   MH H   H H H   H M   M!H@       M   @   HDH4H   H4@   $   H H   H HE@
      H       M   @   HDH4H   H4@   $   HX H   HK HE@      H< H   H/ HE@   H% H   H H1       M   @   HDH4H   H4@   :   H H   H HE@   HE@   HE@   5   H H   H HE@   HE@   HE@   <   H{ H   Hm iU   )HMAHMA(   HMA   E   H1 #   "   M   @   HNH4H   H4@     H H   H E    H  &   %   M
   @
   HLH4H   H4@   <  H  (   '   Hc}LEADMD9AD9HDH4H   H4A     H1  *   )   Hc}LEA   A   HDH4H   H4AS   H  ,   +   Hc}LEA
   A
   HDH4H   H4A      H  .   -   M   @   HDH4H   H4@   )   H  H   H  HcEHMD   $   H  H   H  HcEHMD   H  H   Ht  $   Hp  H   Hc  HcEHMD
   HT  H   HG  ]   HC  H   H6  HcEHMDH'  H   H  H  H   H  M   MzH  H   H  H  H   H  M   MH  H   H  E    H  ;   :   M}9A9HLH4H   H4A     H  H   H  HcEHM?      E    H  >   =   M   @   HLH4H   H4@   y   H-  H   H   HcEHcMHUHH   Hi  H   HcEHM?     ?  H  H   H  M   M=H  H   H  E   H  C   B   M
   @
   HLH4H   H4@   y   Hw  H   Hj  HcEHcMHUHH   Hi  H   HcEHM?     ?  H+  H   H  M   M=H  H   H  H  H   H  M   MH  H   H  E    H  J   I   M}9A9HLH4H   H4A      }Hu  H59  L   K   =    A=    HLHH   HA       H\  H   HO  E  HD  H   H7  H8  H   H+  M   MH  H   H  E    H  R   Q   M}9A9HLH4H   H4A   _   H  H   H  HcEHM8       HcEHM^      H  H   H  M   M\H  H   Hw  E    H  W   V   M   @   HNH4H   H4@   I   H7  H   H*  HcEHMDp    H  H   H  M   MmH  H   H  HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    H  \   [   M   @   HLH4H   H4@   O   HC  H   H6  HE   Hu[  EH!  H   H  M   Mg1H  H   H  HE   Hu	  E    EH  H   H  EHP] UHH  HN  H HEH  H   H   HH         HH    LcLG?  A   AA   HLH4H   H4A   #   H$  H   H       HH5  H   H5  HcHHH   Hi  HHcLIc?  }  H        HcLA?      A    HOH4H   H4A     Hg  H   HZ  ]  HcH*?  Y  ,HcHcHHH   Hi  HHc    H  	      HcLE?  A   D9AD9HLH4H   H4A      H  H   Hv     HcHcHHH   Hi  HHcHcHHH   Hi  HH  H   H     H  H   H  HcH?  ?  H  H   H      HA        9A9HLH4H   H4A      Hv  H   Hi  Hc HcHcHHH   Hi  HHcH?     ?  H  H   H     H  H   H      H  H  H   H  H H;E   H  ]d  fffff.     UHH@Ha  H   HT  }HuHF        MMH}H}LcELMG?  A    AA    HNH4H   H4A     H  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A      H  H   H  HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HH0  H   H#  M   MHcEHM^  HcEHM?  HcEHM^      }HuMH  	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H^  H   HQ  El  HF  H   H9  M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      H  H   H  HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   H  H   H  E    H  H   H  EH@]fff.     UHH H   Hx Hu}UHo H   Hb MMHEHEUUHu       E    H*       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H H   H HE         Q  H?       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H H   H HE            H    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   H H   H HE         H~ H   Hq Hr H   He Hf H   HY HZ H   HM M   M1H; H   H- UHM      ]UHAVSHPHn  H   Ha  MUu}LEHJ        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H  H   H  E  H        H}      A   HLH4H   H4A       H  H   H  E  }Hu  H50        EE=   A=   HLHH   HAJ   H  
   	   M   @   HOH4H   H4@       H  H   H  E   HE}uUMLEDMH$V  L_     A   A=    =    MLOI   O       H  H   H}  EJ   Hr  H   He  HE      HE   HuUAE    EH0  H   H#  EHP[A^]    UHH H  H   H  }HuH  H   Hy  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL  MLUL  I   L  HDL HHDDLLHC  H=s     A   A   L  L]        LA   99MONI   N      H   H   H      [      H|o4  H4  HHcHH=  Ha  H   Hq  H4  H   H'  H^  =4  H=  H  H   HFq  H  H   H      H           @   HLH4H   H4@   W   H  H   H  HxHx  H   Hk     \HU  H   HH  H             H&  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   H  H   H  HtH  H   Hy  Hz  H   Hm     1HU  H   HH  HHa      p1  H=p  H  H   Hn  H   H   H      H  *   )   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHH   Hi  H4HcHcHcHH   Hi  HH-  H   H          H  H   H  H   lHg  /   .      @   HDH4H   H4@   l  H3  H5  1   0   =    A=    HNHH   HA      HS  H   HF     H   h2  H  4   3   Ah9A9ILLI   LA   -   H=&  H  H   H   ?  d>   1H  H   H  H9      `H  H   H  H  H   Hz  GHv  H   Hi      H  ;   :   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHcHH   Hi  HHcH  H   H     H  H   H      -  H=  Ha  H    Hj  Hd  H   HW  K-  H=  H"  H(   HTj  H-  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   H  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   H@  H   H3  +  H  F   E       @   HOH4H   H4@M   H  H   G        @    HLH4H   H4@   #   H  H   H  G+  HcHcHH   Hi  H<~.      \h.  H  K   J   \9A9HOH4H   H4A   #   H  H   H  *     H  H   H   H?5  1HXY      TH8  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HX  P?   H  H   H  H  H   H     H  H   H      (  H=b  H  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5?  W   V   AL9A9IOLI   LA   #   H  H   H  '  1H  H   H   H2  1HHV      DHx  [   Z   HcLE8   D9AD9HLH4H   H4A      H  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HU  @?   Hh  H   H[  H\  H   HO     H9  H   H,      &  H=  H  H8   Hc  H  H   H  HCX  %  H=U  H  H@   Hb  H  H   H  H1H      H   H<T      8,%  H=  H  HH   H5b  H  e   d   H             A    HOHH   HA     H  H   H         H  h   g       @    HEH4H   H4@     H3  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  H  H   H  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  H  m   l   HcLE8   D9AD9HLH4H   H4A      H%  H   H     HcHcHH   Hi  HHcHcHH   Hi  HH  H   H     
H  H   H  HcHHc8   HcHH   Hi  HHcH8   8         H  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5-  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5  v   Au   A=    A=    MDNI   NA   &   H  H   H	  H5  0H  H   H  H  H   H      &   H  H   H     H  H   H  H  H   H  .H  H   H  .     H"  H5     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5     A   A=    A=    MDNI   NA   &   H  H   H  HL4  (H  H   H  H  H   H  H  H   H      F  H=  H  HP   HO[  HX  H   HK  HQ    H=  H  HX   H[  1H         HL  H     A   A    A    MENI   NA$   9   H  H   H  H      H     H             @    HEH4H   H4@   ^  H-  H   H   Hd*  H=        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH  H   H      H           @   HLH4H   H4@   W   H\  H   HO  HH8  H   H+     \H  H   H      HO        HDD9AD9HLH4H   H4A   {  H        9A9HEH4H   H4A     H        HcLA8      A   HOH4H   H4A     H6  H   H)  HB        HcLA8       A    HOH4H   H4A   9   1H  H   H  HI  jH  H   H      H           @   HLH4H   H4@   W   HY  H   HL  HbH5  H   H(     \H  H   H  H  H   H  H  H   H  H  H   H     4H  H   H  H  H   H  H  H   H      :  H=  H  H`   HCU  H|  H   Ho  H DL    H=l  H  Hh   HT  H        HcLA^  HcLA?     A   HNHH   HA     HI        HcLA?      A    HOH4H   H4A   ~   Ht  H   Hg  HcH?     HcHcHHH   Hi  HUHcH?  ?    Hn        HcLA^      A    HOH4H   H4A   ~   H  H   H  HcH^     HcHcHH?  Hi  HUHcH^  ^     H;  H   H.  H/  H   H"  H#  H   H  ~  HR        HcLA?      A    HDH4H   H4A     H  H   H      H        HcLE^  D9AD9HLH4H   H4A     Hb  H   HU  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  H  H   H     Hp  H   Hc  HHL  H   H?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   H  H   H  MHHcf  H^  Hf     f  EH\  H   HO      H           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4AR   H7        HcL   A   HDH4H   H4A   2   HM  H   H@  H           H        HcL   A   HDH4H   H4A9  Hf        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4A   H        HcL
   A
   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   I   H  H   H  HNH64   H  H   H  H      H   H  H   Hs  Ht  H   Hg  Hh  H   H[     ?HE  H   H8      <  H=  H  Hp   HEJ  H  H   H  H C    H=u  H  Hx   HI     H  H   H  H    H        HDD9AD9HLH4H   H4A   2  H9        9A9HEH4H   H4A     H  H   H      H        HcLE8   D9AD9HLH4H   H4A     Hs        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1HH  H   H;  H+:   o  H        HcLE8   D9AD9HDH4H   H4A      H  H   H      HN        HcLE8   D9AD9HLH4H   H4A   ?   Hi  H   H\  H]  H   HP     dH:  H   H-  ?   H)  H   H  H  H   H     H  H   H  H  H   H  H  H   H     }1H  H   H  H08        H=X  H  H   HE  H        H      H   HcLALAHDHH   HA   #   H  H   H       H  H   H  HcHtp   tpH7        H==  H  H   HD  1Hk  H   H^  H         H6      3  H=  H
  H   H<D  H        H             A    HEHH   HA   x   H  H   H  H   H	     H   H5  1H5  H   H(  H`5        H=  H  H   HB  H  H   H      H      HDD9AD9HLH4H   H4A     Hi      9A9HEH4H   H4A   &  HN  H   HA  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    H0  H   H#  H$  H   H     H  H   H        H=*  Ho  H   H@  H  H   H      HR      HcLE8   D9AD9HLH4H   H4A      H      HcLcLI   Mi  MA   A   HDH4H   H4A   p   H      9A9HEH4H   H4A   %   H  H   H  ?   H  H   H  H  H   H     H      @HOH4H   H4@   5     H3  H   H&  H0     H0      H$         @   HLH4H   H4@   a         H  H   H  H~  Hq  H   Hd     RHN  H   HA     U   H3  H   H&  2   H=  H5	  D=  H5  H   H5  H  H  H   H  H H;E   H(	  []Q   )v)hmyw     UHH0H  H   H  }HuH        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       H=  H   H0  E  }Hu  H5        =   A=   HLHH   HA       H  H   H  E*  HE   }M  H        AM9A9ILLI   LA       H  H   Hw  E   1Hj  H   H]  HE      }HuM`  Hu   }EM   M)Hu   Hu      H  H   H  H  H   H  H  H   H  E    H  H   H  EH0]@ UHH  H   H  }HuH  H   H  MMHEHEHcUHuD]UHH H  H   H  }      EEMHHHUHuh  H  HMHcHH=  H5  H   HG9  H8  H   H+  E    G  H=  H  H   H9  H  H   H  E     H=T  H  H   H8  H  H   H  E     H=  H  H    H8  H  H   H  E     H=  HE  H(   HW8  Hh  H   H[  E    W  H=  H	  H0   H8  H4  H   H'  E     H=d  H  H8   H7  H   H   H  E     H=(  H  H@   H7  H  H   H  E     H=  HU  HH   Hg7  H  H   H  E   g  H=  H  HP   H+7  Hd  H   HW  E   +  H=t  H  HX   H6  H0  H   H#  E     H=8  H  H`   H6  H  H   H  E     H=  He  Hh   Hw6  H  H   H  E   w  H=  H)  Hp   H;6  H  H   H  E   ;  H=  H  Hx   H5  H`  H   HS  E     H=H  H  H   H5  H,  H   H  E     H=  Hu  H   H5  H  H   H  E     H=  H9  H   HK5  H  H   H  E   K  H=  H  H   H5  H  H   H  E     H=X  H  H   H4  H\  H   HO  E     H=  H  H   H4  H(  H   H  E     H=  HI  H   H[4  H  H   H  E   [  H=  H  H   H4  H  H   H  E     H=h  H  H   H3  H  H   H  E      H=,  H  H   H3  HX  H   HK  E      H=  HY  H   Hk3  H$  H   H  E   k   H=  H  H   H/3  H  H   H  E   /   H=x  H5  2  H5  H   H5  EH  H   H  EH ] ]M=y-iYI9u@ UHH0H  H   H  UHu}MEEHMHMUUuu}HuHJ        A=   A=   ILLI   LA       H  H   H  E   H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  H6        M   @   HDH4H   H4@   d   H4  H   H'  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  H  H   Ht  Hu  H   Hh  HcEHMTTE    HL  H   H?  EH0]fffff.     UHHH  H   H  H}H	  H   H  HEHEH}   HcHM8   H]    UHH  H   H  H}H  H   H  HEHEHM   ]fff.     UHH  H   H  u}HUH  H   H  MMUUHEHEE    E    HQ        MHc}LEE?  D9AD9HLH4H   H4A      H        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   Hy  E    H#     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A      H        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E]UHH0H  H   H  H}H  H   H  HEHEH}EE    HZ        MHc}LEE8   D9AD9HLH4H   H4A      H&  H   H  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HH  H   H  M   MHI        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   H#  H   H  M   HE   "   H  H   H  HE       H  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    H        M   @   HLH4H   H4@   O   H*  H   H  HE   HuEH  H   H  M   Mg1H  H   H  HE   Hu1EH0]@ UHH  H   H  H}H        H}H}LEAH    A    HDH4H   H4A       H^  H   HQ  E     HF  H   H9  E    E    H        M   @   HLH4H   H4@      H        Hc}LEAL    A    HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H}  M   M	H        M   @   HMH4H   H4@       H3  H   H&  E      H  H   H  E    H  H   H  E]fD  UHH@H  H   H  }HuH  H   H  MMHEHEE    E    H        MHc}LEE8   D9AD9HLH4H   H4A     HR        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MHB     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H:  H   H-  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH2        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       HZ  H   HM  M   MH        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A     Hb        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       Hr  H   He  M   MHR  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MHB  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H"  H   H  M   MH  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   Hu  Hv  H   Hi  M   M+HY  H   HL  E    H  1   0   MHc}LEE^  D9AD9HLH4H   H4A     Hr  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H:  H   H-  M   MHb  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       HZ  H   HM  M   MHR  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1Hx  H   Hk  M}HUM
   MMHJ  H   H=  H>  H   H1  M   M+H!  H   H  EH@]ff.     UHH0H  H   H  H}HuH  H   H  HEHEHMHME    H        M   @   HLH4H   H4@      Hp        MH}DD9AD9HMH4H   H4A   (   HU  H   HH  HcEHM+   H5  H   H(  }HuHcuHMH  H   H  H  H   H  M   MH  H   H  E    E    Hw        M   @   HLH4H   H4@      H-        Hc}LEAHc}LEED9AD9HOH4H   H4A      HL  H   H?  MMH:  H   H-  H.  H   H!  M   M
H  H   H  HcEHMUH}-EE    HL        M   @   HLH4H   H4@      H        Hc}LEADMD9AD9HDH4H   H4A   m   H        M}9A9HOH4H   H4A   (   H4  H   H'  HcEHM   H  H   H  H  H   H  M   MH  H   H  E    E    H        M   @   HLH4H   H4@      H         Hc}LEAHc}LEED9AD9HOH4H   H4A      HN  H   HA  MMH<  H   H/  H0  H   H#  M   M
H  H   H  HcEHMUE    H  &   %   M   @   HLH4H   H4@      H  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   Hw  H   Hj  HcEHM   #   HW  H   HJ  HcEHM    H<  H   H/  H0  H   H#  M   M1H  H   H  H0]D  UHH   H{  H HEH  H   H  HH  H   Hz  HHH       H4           @   HLH4H   H4@     H        HcLA?     A   HLH4H   H4A   ,   H  H   H  H[H#H=p  HcH8      HcHcLI   Hi  IA n  H        A   A   IDLI   LA   H  
   	      @   HDH4H   H4@M   HT           @   HDH4H   H4@   +   Ho  H   Hb     \   HL  H   H?  Hc HcH8   8      H  H   H  3H  H   H  HS               @    HMH4H   H4@      H  H   H     Hc HcH^     ^  HcHcLI?  Hi  IA   "1H  H   H  H.   Hw  HH;U   1H   ]Jk  @ UHH  H   H  HUu}MH        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   H3  H   H&  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  H        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   Hk  H   H^  HcEHM8   8   \  H        Hc}LEA8      A   HDH4H   H4A   5   H  H   H  HcEHM8   8      H  H   H  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   H  H   H	  1H  H   H  ]     UHH0H  H   H  H}uH  H   H  HEHEMMH}REE    HQ        M   @   HLH4H   H4@   H   H'  H   H  }HuEH  H   H  M   Mn1H  H   H  }uHU1EH0]@ UHH0H  H   H  H}uH  H   H  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPH  H   H  MUuH}DEHEHEMMUUuu}}H}H=c     A   AEE=   A=   MDNI   NA   7   H.  H   H!  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   H  H   H  HE      HE   <   1H  H   H  }uHU1}uHUEEHf  H   HY     HU  H   HH  }uHUQ1EHP]@ UHHPHQ  H   HD  UuH}MHEHEMMUUuuH}H=     A   AEE    E=   A=   MONI   NAJ   H        M    @    HLH4H   H4@       H  H   H  E  HT        M}9A9HDH4H   H4A       HO  H   HB  E{  H7  H   H*  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  H        M}9A9HEH4H   H4A      H;        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       H!  H   H  M   MH	  H   H  H  H   H  M   MdH8        M}9A9HLH4H   H4A       H  H   H  E_  H  H   H  MHcEHULLE    H        MH}DD9AD9HLH4H   H4A      HZ        M}9A9HEH4H   H4A   E   1H  H   H  HcEHcMHuH   Hi  H<HuM:EH  H   H  H  H   H  M   M1H  H   H  }uHUYE    EHh  "   !   M}9A9HLH4H   H4A     H;  H   H.  E    H  %   $   MHc}LEE8   D9AD9HLH4H   H4A      H  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      Hl  H   H_  }uHUE9   HI  H   H<  H=  H   H0  M   MH   H   H  H  H   H  M   M'H  H   H  E    H  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=_  H5_  VB  1H5_  /AVUM}G  	   H5s  K     H5_  [H1AVNG     H5
t  K     H5~_  1AVG     H5s  ~K     H5\_  VI1AVF  a   H5s  OK     H5<_  ;|1AVF     H5v   K     H5_  ] t1AVF     H5&w  J     H5^  T1AVcF     H5w  J     H5^  w1AV4F     H5w  J     H5^  YAr1AVF     H5w  dJ  	   H5^  j1AVE     H5w  5J  
   H5]^  a'Hr1AVE     H5{w  J     H5<^  @1AVxE     H5x  I     H5^  -1AVIE     H5w  I     H5]  "mw1AVE     H5Nx  yI     H5]  |1AVD  G   H5x  JI     H5]  b1AVD  .   H5z  I     H5]  W71AVD     H5|  H     H5\]  `1AV^D  :   H5R|  H     H55]  eW1AV/D    H5}  H     H5]  Qw1AV D     H5  _H     H5\  :/T1AVC     H5  0H     H5\  r%1AVC     H5F  H     H5\  Ba1AVsC     H5  G     H5\  PR1AVDC     H5(  G     H5a\  Ce&1AVC     H51  tG     H5@\  #e,1AVB  /   H5  EG     H5 \  Ql1AVB  
   H5k  G  J  T  H]fD  UHH<o      H)o      Ho      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hp      Hp      Hp      Hp      Hp      Hvp      Hcp      HPp      H=p      H*p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hlo      HYo      HFo      H3o      H o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hun      Hbn      HOn      H<n      H)n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H~m      Hkm      HXm      HEm      H2m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Htl      Hal      HNl      H;l      H(l      Ho      H
o      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hrn      H_n      HLn      H9n      H&n      Hn      H n      Hm      Hm      Hm      Hm      Hm      Hm      H{m      Hhm      HUm      HBm      H/m      Hm      H	m      Hl      Hl      Hl      Hl      HZn      HGn      H4n      H!n      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hvm      Hcm      HPm      H=m      H*m      Hm      Hm      Hl      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hnm      H[m      HHm      H5m      H"m      Hm      Hl      Hl      Hl      Hm      Hm      Hm      Hm      Hm      Hlm      HYm      HFm      H3m      H m      Hm      Hl      Hl      Hl      Hl      H6m      H#m      H0m      Hm      H*m      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hzm      Hgm      HTm      HAm      H.m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hpl      H]l      HJl      H7l      H$l      Hl      Hl      Hl      HHm      H5m      H"m      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hwl      Hdl      HQl      H>l      H+l      H m      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hul      Hbl      HOl      H<l      H)l      Hl      Hl      Hk      Hmn      HZn      HGn      H4n      H!n      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hvm      Hcm      HPm      H=m      H*m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hll      HYl      HFl      H3l      H l      Hl      Hk      Hk      Hk      Hk      Hk      Hk      Hk      Huk      Hbk      HOk      H<k      H)k      Hk      Hk      Hj      Hj      Hj      Hj      Hj      Hj      H~j      Hkj      HXj      HEj      H2j      Hj      Hj      Hi      Hi      Hi      Hi      Hk      Hk      Hk      Hk      Hk      Hk      Hsk      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hxl      Hel      HRl      H?l      H,l      Hl      Hl      Hk      Hk      Hk      Hk      Hk      Hk      Hk      Hnk      H[k      HHk      H5k      H"k      Hk      Hj      Hj      Hj      Hj      Hj      Hj      Hj      Hwj      Hdj      HQj      H>j      H+j      Hj      Hj      Hi      Hi      Hi      Hi      Hk      H{k      Hhk      HUk      HBk      H/k      Hk      H	k      Hj      Hj      Hj      Hj      Hj      Hj      Hj      Hl      Hl      Hl      Hl      Hul      Hbl      HOl      H<l      H)l      Hl      Hl      Hk      Hk      Hk      Hk      Hk      Hk      H~k      Hkk      HXk      HEk      H2k      Hk      Hk      Hj      Hj      Hj      Hj      Hj      Hj      Hj      Htj      Haj      HNj      H;j      H(j      Hj      Hj      Hi      Hi      Hi      Hi      Hi      Hi      H}i      Hji      HWi      HDi      H1i      Hi      Hi      Hh      Hh      Hh      Hh      Hh      Hh      Hh      HCl      H0l      Hl      H
l      Hk      Hk      Hk      Hk      Hk      Hk      Hk      Hrk      H_k      HLk      H9k      H&k      Hk      H k      Hj      Hj      Hj      Hj      Hj      Hj      H{j      Hhj      HUj      HBj      H/j      Hj      H	j      Hi      Hi      Hi      Hi      Hi      Hi      Hi      Hqi      H^i      HKi      H8i      H%i      Hi      Hh      Hh      Hh      Hh      Hh      Hh      Hh      Hzh      Hgh      HTh      HAh      H.h      Hh      Hh      Hg      Hg      Hg      Hg      Hg      Hg      Hk      Hpk      H]k      HJk      H7k      H$k      Hk      Hj      Hj      Hj      Hj      Hj      Hj      Hj      Hyj      Hfj      HSj      H@j      H-j      Hj      Hj      Hi      Hi      Hi      Hi      Hi      Hi      Hi      Hoi      H\i      HIi      H6i      H#i      Hi      Hh      Hh      Hh      Hh      Hh      Hh      Hh      Hxh      Heh      HRh      H?h      H,h      Hh      Hh      Hg      Hg      Hg      Hg      Hg      Hg      Hg      Hng      H[g      HHg      H5g      H"g      Hg      Hf      Hf      Hf      Hj      Hj      Hj      Hj      Hwj      Hdj      HQj      H>j      H+j      Hj      Hj      Hi      Hi      Hi      Hi      Hi      Hi      Hi      Hmi      HZi      HGi      H4i      H!i      Hi      Hh      Hh      Hh      Hh      Hh      Hh      Hh      Hvh      Hch      HPh      H=h      H*h      Hh      Hh      Hg      Hg      Hg      Hg      Hg      Hg      Hg      Hlg      HYg      HFg      H3g      H g      Hg      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Huf      Hbf      HOf      H<f      H)f      Hf      Hj      Hi      Hi      Hi      Hi      Hi      Hi      H~i      Hki      HXi      HEi      H2i      Hi      Hi      Hh      Hh      Hh      Hh      Hh      Hh      Hh      Hth      Hah      HNh      H;h      H(h      Hh      Hh      Hg      Hg      Hg      Hg      Hg      Hg      H}g      Hjg      HWg      HDg      H1g      Hg      Hg      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Hsf      H`f      HMf      H:f      H'f      Hf      Hf      He      He      He      He      He      He      H|e      Hie      HVe      H;h      H(h      Hh      Hh      Hg      Hg      Hg      Hg      Hg      Hg      H}g      Hjg      HWg      HDg      H1g      Hg      Hg      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Hsf      H`f      HMf      H:f      H'f      Hf      Hf      HVg      HCg      H0g      Hg      H
g      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Hrf      H?g      H,g      Hg      Hg      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Hnf      H[f      HHf      H5g      H"g      Hg      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Hwf      Hdf      HQf      H>f      H+f      Hf      Hf      He      Hg      Hg      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Hlf      HYf      HFf      H3f      H f      Hf      He      He      He      He      He      He      Hpf      H]f      HJf      H7f      H$f      Hf      He      H3f      H f      Hg      Hg      Hwg      Hdg      HQg      H>g      H+g      Hg      Hg      Hf      Hf      Hf      Hf      Hf      Hf      Hf      Hmf      HZf      HGf      H4f      H!f      Hf      He      He      He      He      He      He      He      Hve      Hce      HPe      H=e      H*e      He      He      Hd      Hd      Hd      Hd      Hd      Hd      Hd      Hld      HYd      HFd      H3d      He      He      He      He      He      He      H~e      Hke      HXe      HEe      ] UHH=H52  ]UHHPg  H?  H HEHPe  H   HCe  1E    74  4  H=7  H5  (   HuEJ  E   E    HHH3  H 3  HHu1Af  DIHLHLHLD3  }UHHDHEE  H\d        =   AAAALcI    AI    HEH<H   H<A      H=	8  H56  (   H6  -2  Hc  H   Hc  HHu1f  HHHU2  }UHHCHEE  Hmc        =   AAAALcI    AI    HEH<H   H<A      H=7  H55  ,   H5  >1  H-c  H   H c  H=5  Hc  H   Hc   1  H=7=  H?H;}   1HPg  ]0  @ UHAVSH@Hb  H   Hb  H}H=M5  HEHEE    HM   U 1  1HcMH}8      uHcMH}H   Hi  H   LEUME\L=b     A   ALc]H]B8   U9A9MDOI   OAE      Ha  H   Ha  E   Ha        M    @    HEH4H   H4@   *   H=>4  Ha  H   Ha   /  E%   H=#4  Ha  H   H{a   /  EH=4  Hka  H   H^a  uHcEHM8    /  UEH@[A^]@ UHAVSHPH.a  H   H!a  H}H=3  Ha  H   H
a  HEHEE    HM   U /  HcMH}8      UHcMH}?  UHcMH}?     UEH`        M    @    HMH4H   H4@      Hi`  H   H\`  HcEHcMHUHH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHM?  ?  H_  H   H_  MMH=w2  HcEHM^  HcEHM?   -  1HcMH}H   Hi  H   LEUMEXL1_     A   ALc]H]B8   U9A9MDOI   OAE      H_  H   H_  E   H^  
   	   M    @    HEH4H   H4@   *   H=0  H^  H   H^   ,  E%   H=0  H^  H   H^   d,  EH=0  H^  H   Hz^  uHcEHM8    -,  UEHP[A^]     UHHH=0  H5R.  v   1H5%1  9AvUM  
   H5\  L     H50  >1Av  	   H5]       H50  1Av     H53]      &  H]fffff.     UH'H\      H\      H~\      Hk\      HX\      HE\      H2\      H\      H\      H[      H~\      Hk\      HX\      HE\      H2\      H\      H\      H[      H[      H\      H\      Hm\      HZ\      HG\      H4\      H!\      H\      H[      H[      H[      H[      H[      H[      ]f.     UHH=H5nI(  ]UHH[  H   H[  H[          L7  HE  HEG  Lc[  OHELHUHHHi  Lcl[  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   HU7  H&[  H   H[  HMHcZ  H2   H%7  HZ  H   HZ  HMHHcZ  H**  H6  HZ  H   HZ  HcZ  H*^(]UHH@HZ  H   HZ  H}1HZ  H   HZ  HEHEHEm HE  Z     Z  M  H}  MY  E   H*Z        M   @   HLH4H   H4@   K  HY        m L5  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   H:5  HSY  H   HEY  HMHcUH/   H5  H.Y  H   H Y  HMHHcUHHY  H   HY  HY  H   HX  M   MkHX  H   HX  H@]fUHHHY  H   HY  }HzY        MM}   =W  =W      A    HDH4H   H4A   n   HY        W      @    HEH4H   H4@   !   [HX  H   HX  HX  H   HX  H]    UHH0HW  H   HW  H}HW        H}H}E LEI    AI    HOH4H   H4A   )   HaW  H   HSW  HEHHHUH'W        H}H    AH    HLH4H   H4A   .   1HW  H   HV  $  1HHUHV        H}H    AH    HDH4H   H4A     HV  H   HV  HKV     
   } @@@HEH4H   H4@   "  H=(   !#  H=(  HuE #  1H5U  1   A   ALUL9AL9MLJ<H   J<AEU   "   HU  H   HU  H}MEHgU        $EE< A< HEH<H   H<A%   H='  HU  H   HU   )"  EHU  H   H~U  HzU  H   HmU  H~0  HgU  H   HYU  HMHcT  HH0]@ UHH=U  H   H0U  H}H-0  H&U  H   HU  HMHMHcS  HHUH]fff.     UHH0H1U  H   H$U  1H#U  H   HU  E %   +HE    HT        H}H'  AH'  HLH4H   H4A   E   HT  H   HT  EHT  H   HT  HEH   HEnH}   H}Z$EY   H}1H=T        M    A    HEH4H   H4AE   "   HT  H   HS  H}Y  MEHS  
   	   $EE< A< HEH<H   H<A   *   H=7%  HS  H   HS   c  E%   H=:%  HS  H   H|S   9  EHsS  H   HfS  H0]     UHHH=1%  H5R!  M_   1H5p%  hnAM_UM     H5Q  L     H5@%  8I1AM_     H5Q       H5%   1AM_     H5CQ       H5$  r~61AM_`     H5Q       H5$  XH1AM_1     H5Q       H5$  
1AM_     H5Q  a  <  g  H]UHH$P      HP      HO      HO      HO      HO      H:P      H'P      HP      HP      HO      HO      HO      HO      HO      HO      H|O      HqP      H^P      HKP      H8P      H%P      HP      HO      HO      HO      HO      HO      HO      HO      HzO      HgO      HTO      HAO      H.O      HO      HO      HN      HO      HO      HO      HO      HO      HO      HxO      HeO      HRO      HO      HO      HO      HO      HO      HO      H}O      HjO      HWO      HDO      H1O      HO      HO      HN      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH="    HH="    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IHz  IK|&I  HHHL  AD./tB3/IHLLL  EL<$HIN  JN      1H  m0  tL5      N  H=N      1  70  L5g   uhH-M  H]fffff.     Ht/u   HE  /H=M      1@  /         =/  L  HrM  HoM      HlM      HiM      BM  u&1     HH7M  H4M        1   Hl  H=	M  f  HEM  HtfD!/  1      E1Hf  HHL  H     8H$  HH-L  q  HH5   1HH  L  HL      HL      H-L  1H  t)H H  1H  HHIL  H-JL  1   H  L  H-6L  tbHEH;L  vrH  H  HH  HK  H-K  HK  K  adcgHK  HCHK  t?+adcgHK  HHK  1gHK  adcgHK  HCHK  HSH;~K  v8H  H  H=_K  H  HPK  HQK  HRK  ,K  H5K  A74H8K  HCH-K  t?HKH;K  v2H  H  H=J  H  HJ  HJ  HJ  HJ  D,HJ  H[A\A]A^A_]  8H!  HH-J  Z  HH5  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=J   1  T$D$I  u?HJ  HCH;I  v+H  H  H=I  H  HI  HI  HI  HI     HI  L{L=I  MtLY  Hl(uI  tfHCH;~I     H  H  H=[I  H  HLI  HMI  HNI  'I  ,H=I  HCH2I  u\HI  B,8HI  HHI  HH  D$HH  HHH     HH  B,8HH  HCHH  HKH;H  vVH  H  H=H  H=  HH  HH  HH  iH  D$H~H  HCHsH  u^HUH  D$HZH  HCHOH  HKH;<H  v2H  H  H=H  H  HH  HH  HH  HG  T$H-G  H]HG  EtjG  u?HEH;G  v2H  H  H=G  HM  HG  H-G  HG  HG  $HG  HHG  My  L&  HH@G  uKHCAH;EG  v>H  H  H=&G  H  HG  HG  D=F  HG  E1HF  ,H-F  HH-F  L  IAtALHH;F  v2H H  H=F  HL  HF  HF  H-F  H-F  HLL  H-F  LH-yF  L'  H   H)>F  u?L4+L;5FF  v2I I  H='F  L  HF  L5F  H-F  H-F  1HHn  HE  H[A\A]A^A_]     UAWAVAUATSPIAH=E      L%E  E     L%E  ID$H;E  }  I  I  H=vE  L  HgE  L%hE  HiE  BE    HTE  HCHIE  C,6E1  ;  H[A\A]A^A_]HE  B#ID$HE  E1       BL#Il$H-D    D9  DH  IEtvAN1AtH+HH-D  I   tOHILAVp)f.     Ht+H-lD  HqH4+H}H=YD  H1HHHuL%>D  B#  H/D  HH$D  C,6jHD  B   HD  HCHC  C,6HKE1H;C  v5H  H  H=C  Hd  HC  HC  E1HC  HC  ,HC  HHC  E  M   Lff.     I] H] I] EC  u@L%YC  ID$H;EC  v+I  I  H=&C  L  HC  L%C  HC  HC  HHC  HIAu   fff.     Im B  u?HCH;B  v2H  H  H=B  HF  HB  HB  HB  HB  H,HB  HH|B  IAuLH[A\A]A^A_]  H  H8H$B  H5  H|  H8H
B  H5  1H[A\A]A^A_]N  fffff.     SH=A     HA  A  tzHA  HCH;A     H  H  H=A  HK  HA  HA  HA  wA     HA  HKH~A       oHWA  HCHYA        LHCH>A  	l  DHKH&A     HA     H
A  HKH@  HCH;@    H  H  H=@  Hi  H@  H@  H@  @  	   H@  HKH@     uS       Hx@     Hj@  HH_@  HH@  
	   HJ@  HH?@  H(@  
    H*@  HH@  H@  
    H
@  HH?  H?  
H?  HH?  H?      H?  HH?  H?      H?  HH?  H?      H?  HH?  Hl?      Hn?  HHc?  HL?      HN?  HHC?  H,?      H.?  HH#?  H?     H?  HH?  H>      H>  [H>  	   H>  HKH>  HCH;>  vbH  H  H=>  H9
  H>  H>  H>  e>      Hw>  HKHl>     ? HE>      HG>  HKH<>  HCH;)>     H  H  H=>  H	  H=  H=  H=  =      H=  HKH=     ZH  H8H=  H5  H  H8Hv=  H5  1[  Hx=      Hz=  HKHo=  HCH;\=  v]H  H  H===  H  H.=  H/=  H0=  	=     H=  HCH=  $ H<     H<  HCH<  HKH;<  v[H  H  H=<  HS  H<  H<  H<  <      H<  HCH<   Hf<      Hh<  HCH]<  HKH;J<  v]H  H  H=+<  H  H<  H<  H<  ;      H	<  HCH;  R H;      H;  HCH;  HKH;;  v]H  H  H=;  HA  H;  H;  H;  m;      H;  HCHt;   HR;      HT;  HCHI;  HKH;6;  v]H  H  H=;  H  H;  H	;  H
;  :      H:  HCH:  ~ H:      H:  HCH:  HKH;:  v]H  H  H=:  H-  H~:  H:  H:  Y:      Hk:  HCH`:   H>:      H@:  HCH5:  HKH;":  vZH  H  H=:  H  H9  H9  H9  9      H9  HCH9  u%H9      H9  HCH9  HKH;9  v]H  H  H=|9  H  Hm9  Hn9  Ho9  H9     HZ9  HCHO9  C H-9     H/9  HCH$9  HKH;9  H  H  H=8  H  H8  H8  H8  @ AVSPH=8   N  8  uIH8  HKH;8  v5H  H  H=8  H  Hp8  Hq8  S8  1Hh8  HQ8  H
    H5R8  HH5G8  H=08  tH8     {  H=8  ]  sH5F8       u4
  8H9  L0H7    HH5  1LH  H=7  H57  @  H7      H7      H=7    =       Hk7      Hh7      H=I7  H[A^  ffff.     SH     HH@    H=?7   tH>7  HAH37  [H*7  H7  [f     SH7  fD  1H[Hu[Pffff.     HGH6    H=6  HuH6      H6      Xfff.     SH     HH@    H=6   tH6  HAH6  [Hz6  Hk6  [f     SHX6  fD  1H[Hu[Pffff.     HGH%6  F  H=6  HuH6      H5      Xfff.     AVSPIHHtA     HH@    H=5   tH5  HAH5  H5  H5  MtA      L0H@    H=~5   tH}5  HAHr5  Hi5  HZ5  d5  tH[A^Q5  H=1   H=.%   H=H[A^   %P  %R  %T  %V  %X  %Z  %\  %^  %`  %b  %d  %f  %h  %j  %l  %n  %p  %r  %t  %v  %x  %z  %|  %~  %  %  %  %  %  %  %  %    L  AS%u  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h~  h  h  h  h  h                    	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for smithy card effect
===================
      cardtest1.c handIncrease(&state)==1 emptyDeck(&state)==1 All tests successful!

 	Test that hand increase is correct.
 	Test passed.  	##TEST FAILED##.  Target handcount: %d, Actual: %d
 	Test that empty deck will reshuffle for smithy.
 	Discard count: %d, Deck count: %d           /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest1.gcda      main handIncrease emptyDeck       
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           4       4          !    0  L   L        L        X         ` P     W     0   @   @    p     a           zR x         zR x         zR x         zR x  <      p       ABB B(B0A8A@         \                   <   |    h       ABB B(B0A8A@      <      P       ABB B(B0A8A@            ,	       A  $      s       BAA      D  XG        A     d          A       D        A         G        A               A       D        A    $             BAA                                                                                        
            (    2    <    F    P    Z    d    n    x                                                  @             x&    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &     '    '    '    '     '    ('    0'    8'    @'    H'    P'    `(    h(    p(    x(    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (     )                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `#A`1@___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time     _  _mh_execute_header c n kingdomCards i s d updateCoins play hand buyCard g whoseTurn fullDeckCount e main Random P SelectStream GetSeed TestRandom     ompare ardEffect  $  ewGame umHandCards  '  '  nitializeGame sGameOver  *  huffle upplyCount coreFor  G  rawCard iscardCard  Q  Y  Card A S GreatHall  _  Card Increase  e  f      et ainCard  Cost Winners            ndTurn mptyDeck          dventurer mbassador      mithy teward                  lantSeeds utSeed              $P	mP`P	P
H  ` 	 P PP P     d           M   d           X   f W       .  0        $  0        $   P         N  P         .          $          $   P          N  P          .          $          $   @         N  @         .          $          $            N           .  #        $  #        $            N           .  (        $  (        $            N           .  ,        $  ,        $             N            .  /        $  /        $            N           .  2       $  2        $             N            .   3       $   3        $   6         N  6         .  i       $  i        $   p         N  p         .  Pl     &  $  Pl        $   P          N  P          .  l     3  $  l        $   p         N  p         .  t     <  $  t        $            N           .  v     F  $  v        $   `          N  `          .  Pw     T  $  Pw        $   P          N  P          .  w     _  $  w        $            N           .  {     n  $  {        $   p         N  p         .  ~     w  $  ~        $   P         N  P         .  @       $  @        $   0         N  0         .  p       $  p        $            N           .         $          $            N           .         $          $             N            .         $          $             N            .         $          $             N            .  p       $  p        $            N           .  P       $  P        $            N           .  `       $  `        $   P          N  P          .         $          $   0         N  0         .       ,  $          $   $         N  $         .       ?  $          $             N         Q  &  @    i  &         &        &        &        &  8      &  H      &  `    
  &  p      &      .  &      @  &       R  &  (     d  &  8     w  &  P       &   !      &  0!      &  !      &  @"      &  $      &  %      &  p&      &  @(    "  &  @1    5  &  1    H  &   2    [  &  2    n  &  `3      &  3      &  3      &  05       d             d             d             f W       .         $          $            N           .       "  $          $            N           .       0  $          $   `         N  `         .  @     ;  $  @        $             N            .       Q  $          $            N           .       d  $          $             N         v  &  5      &  5      &   6       d             d             d             f 
W       .         $          $   p         N  p         .          $           $   0         N  0         .  P       $  P        $            N           .  `     '  $  `        $   0         N  0         .       0  $          $   `          N  `          .       9  $          $   P         N  P         .  @     E  $  @        $   P         N  P         .       [  $          $            N           .  @     n  $  @        $             N           &        &  6      &  6      &  6      &  6      &  07      &  7      &  7      &  08       d              `     .         D         W         i    @                           @                  @         `         P         p     4         I         a         u    p                        0                    	        ,	    @    D	         ^	        }	        	        	        	        	    8    	    H    	    `    	    p    
        
        %
         7
    (     I
    8     \
    P     o
     !    
    0!    
    !    
    @"    
    $    
    %    
    p&    
    @(        @1        1    -     2    @    2    S    `3    f    3    y    3        05        5        5         6        6        6        6        6        07         7    2    7    D    08    V    8    `    8    j    8    w    8        8        8        8        8        8        8        8        8                           `     %         -    P     ;         G          [    i     d     3     p    0     y             (                  {         w         t         l         p         2                           ~                                #    v     1         A    P     Q    /     [         j         v    p         @         #         Pl         ,         Pw                                                                             
                                                 '            .            7            =            D            K            S            [            c            k            s            z                                                                                                                                                                        c  d  e  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~              f  g       @c  d  e  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~                /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 cardtest1.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest1.o _main _handIncrease _emptyDeck ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _compare _discardCard _drawCard _emptyDeck _endTurn _fullDeckCount _gainCard _getCost _getWinners _handCard _handIncrease _initializeGame _isGameOver _kingdomCards _main _newGame _numHandCards _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder     File 'dominion.c'
Lines executed:0.00% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
    #####:   12:    return -1;
    #####:   13:  return 0;
    #####:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
    #####:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    #####:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
    #####:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
    #####:  215:    card = floor(Random() * state->deckCount[player]);
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
    #####:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
    #####:  226:  }
        -:  227:
    #####:  228:  return 0;
    #####:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
    #####:  315:  int currentPlayer = whoseTurn(state);
    #####:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
    #####:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
    #####:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
    #####:  532:    for (i = 0; i < state->discardCount[player];i++){
    #####:  533:      state->deck[player][i] = state->discard[player][i];
    #####:  534:      state->discard[player][i] = -1;
    #####:  535:    }
        -:  536:
    #####:  537:    state->deckCount[player] = state->discardCount[player];
    #####:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
    #####:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
    #####:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
    #####:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
    #####:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
    #####:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
    #####:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  562:    state->deckCount[player]--;
    #####:  563:    state->handCount[player]++;//Increment hand count
    #####:  564:  }
        -:  565:
        -:  566:  else{
    #####:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
    #####:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  575:    state->deckCount[player]--;
    #####:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
    #####:  579:  return 0;
    #####:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
    #####:  652:  int currentPlayer = whoseTurn(state);
    #####:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
    #####:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
    #####:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
    #####:  659:  int z = 0;// this is the counter for the temp hand
    #####:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
    #####:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
    #####:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
    #####:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
    #####:  823:      discardCard(handPos, currentPlayer, state, 0);
    #####:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
    #####:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
    #####: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
    #####: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
    #####: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1124:      state->playedCardCount++;
    #####: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
    #####: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
    #####: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
    #####: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
    #####: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
    #####: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
    #####: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
    #####: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
    #####: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
    #####: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
    #####: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
    #####: 1203:	  state->coins += 1;
    #####: 1204:	}
    #####: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
    #####: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
    #####: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
    #####: 1216:  state->coins += bonus;
        -: 1217:
    #####: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
    #####: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
    #####: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
    #####: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
    #####: 1273:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                  __text          __TEXT          
     :      
                           __stubs         __TEXT          *           *                        __stub_helper   __TEXT              P                                __const         __TEXT          @    @       @                            __cstring       __TEXT              S                                 __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                0                                __got           __DATA                                                  __nl_symbol_ptr __DATA                                    "           __la_symbol_ptr __DATA                                      $           __mod_init_func __DATA                                   	               __const         __DATA          @          @                            __data          __DATA                                                __bss           __DATA              0                                       H   __LINKEDIT       @     0             .                    "  0           @           H     "         P%   >      P       >  >  %   c  #                           = D                             /usr/lib/dyld             e%8S#Z^$       
  
 *              (                      8         
   /usr/lib/libSystem.B.dylib      &      $ h   )      P%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     UHH H   H H}HuH       H}H}LELELMA	LMED9AD9HOH4H   H4A       H H   H E      HZ       H}H}DD9AD9HLH4H   H4A       H< H   H/ E   H$ H   H E    H H   H E]ffffff.     UHHH H   H f  H H   H   HEHEH]D  UHAWAVSHXE(DU D]]L5 I   L5 ]DMDEMUuEDUD]}(   H` H   HR EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D}9  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPH H   Ht UHu}HM   EEHMHMUUHuHu  Hc}  H0       E=   A=   HOH<H   H<AJ   H       M   @   HLH4H   H4@       H H   H Ej  H H   H MHEE    H_       M
   @
   HLH4H   H4@     H] H   HP E    H    
   M
   @
   HLH4H   H4@      H       M}9A9HEH4H   H4A   y   Hk       Hc}LEAHc}LEED9AD9HDH4H   H4A       H H   H E  Hz H   Hm Hn H   Ha M   MHQ H   HD HE H   H8 M   M!H
       M   @   HDH4H   H4@   $   H
 H   H
 HE@
      H
       M   @   HDH4H   H4@   $   H
 H   H
 HE@      H|
 H   Ho
 HE@   He
 H   HX
 Hq	       M   @   HDH4H   H4@   :   H
 H   H
 HE@   HE@   HE@   5   H	 H   H	 HE@   HE@   HE@   <   H	 H   H	 iU   )HMAHMA(   HMA   E   Hq #   "   M   @   HNH4H   H4@     HG	 H   H:	 E    H &   %   M
   @
   HLH4H   H4@   <  H (   '   Hc}LEADMD9AD9HDH4H   H4A     Hq *   )   Hc}LEA   A   HDH4H   H4AS   H# ,   +   Hc}LEA
   A
   HDH4H   H4A      H .   -   M   @   HDH4H   H4@   )   H H   H HcEHMD   $   H H   H HcEHMD   H H   H $   H H   H HcEHMD
   H H   H ]   H H   Hv HcEHMDHg H   HZ H[ H   HN M   MzH> H   H1 H2 H   H% M   MH H   H E    H2 ;   :   M}9A9HLH4H   H4A     H H   H HcEHM?      E    H >   =   M   @   HLH4H   H4@   y   Hm H   H` HcEHcMHUHH   Hi  H   HcEHM?     ?  H! H   H M   M=H H   H E   H C   B   M
   @
   HLH4H   H4@   y   H H   H HcEHcMHUHH   Hi  H   HcEHM?     ?  Hk H   H^ M   M=HN H   HA HB H   H5 M   MH% H   H E    H J   I   M}9A9HLH4H   H4A      }Hu  H5y L   K   =    A=    HLHH   HA       H H   H E  H H   Hw Hx H   Hk M   MH[ H   HN E    H R   Q   M}9A9HLH4H   H4A   _   H H   H HcEHM8       HcEHM^      H H   H M   M\H H   H E    H W   V   M   @   HNH4H   H4@   I   Hw H   Hj HcEHMDp    H[ H   HN M   MmH> H   H1 HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    H  \   [   M   @   HLH4H   H4@   O   H H   Hv HE   Hu[  EHa H   HT M   Mg1HB H   H5 HE   Hu	  E    EH H   H EHP] UHH  H  H HEH H   H  HH        HH    LcLG?  A   AA   HLH4H   H4A   #   Hd H   HW      HH5; H   H5- HcHHH   Hi  HHcLIc?    H        HcLA?      A    HOH4H   H4A     H  H   H    HcH*?  Y'  ,HcHcHHH   Hi  HHc    H  	      HcLE?  A   D9AD9HLH4H   H4A      H  H   H     HcHcHHH   Hi  HHcHcHHH   Hi  HH]  H   HP     H:  H   H-  HcH?  ?  H  H   H      H        9A9HLH4H   H4A      H  H   H  Hc HcHcHHH   Hi  HHcH?     ?  HQ  H   HD     H.  H   H!      H  H  H   H  H H;E   H  ]  fffff.     UHH@H H   H }HuH       MMH}H}LcELMG?  A    AA    HNH4H   H4A     H7 H   H* E    H       MHc}LEE^  D9AD9HLH4H   H4A      H H   H HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HHp H   Hc M   MHcEHM^  HcEHM?  HcEHM^      }HuMH 	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H H   H El  H H   Hy M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      H H   H HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   HE H   H8 E    H2 H   H% EH@]fff.     UHH H   H Hu}UH H   H MMHEHEUUHu       E    Hj       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H H   H HE         Q  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H_ H   HR HE            H
    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   H
 H   H
 HE         H
 H   H
 H
 H   H
 H
 H   H
 H
 H   H
 M   M1H{
 H   Hm
 UHM      ]UHAVSHPH  H   H  MUu}LEH        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H%  H   H  E  H        H}      A   HLH4H   H4A       H  H   H  E  }Hu  H5p        EE=   A=   HLHH   HAJ   H*  
   	   M   @   HOH4H   H4@       H8  H   H+  E   HE}uUMLEDMH$V  L     A   A=    =    MLOI   O       H  H   H  EJ   H  H   H  HE      HE   HuUAE    EHp  H   Hc  EHP[A^]    UHH H  H   H  }HuH  H   H  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL)  MLUL[  I   LM  HDL HHDDLLHC  H=     A   A   L  L]        LA   99MONI   N      H@  H   H3            H|o4  H4  HHcHH=\  H  H   Hq  Ht  H   Hg  H^  =4  H=  HT  H   HFq  H/  H   H"      HA           @   HLH4H   H4@   W   H  H   H  HxH  H   H     \H  H   H  H             Hf  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   H  H   H  HtH  H   H  H  H   H     1H  H   H  HHa      p1  H=  H  H   Hn  H@  H   H3      H  *   )   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHH   Hi  H4HcHcHcHH   Hi  HHm  H   H`         HE  H   H8  H   lH  /   .      @   HDH4H   H4@   l  H3  H5H  1   0   =    A=    HNHH   HA      H  H   H     H   h2  H  4   3   Ah9A9ILLI   LA   -   H=  H'  H   H     d>   1H  H   H  H9      `H  H   H  H  H   H  GH  H   H      H  ;   :   HcLE8   D9AD9HNH4H   H4A      HS  H   HF  HcHcHcHH   Hi  HHcH  H   H     H  H   H      -  H=\  H  H    Hj  H  H   H  K-  H=  Hb  H(   HTj  Hm  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   H  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   H  H   Hs  +  H=  F   E       @   HOH4H   H4@M   H  H   G        @    HLH4H   H4@   #   H  H   H  G+  HcHcHH   Hi  H<~.      \h.  HA  K   J   \9A9HOH4H   H4A   #   H\  H   HO  *     H<  H   H/   H?5  1HXY      THx  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H7  H   H*  HX  P?   H  H   H  H  H   H     H  H   H      (  H=  H  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5  W   V   AL9A9IOLI   LA   #   H  H   H  '  1H  H   H   H2  1HHV      DH  [   Z   HcLE8   D9AD9HLH4H   H4A      H[  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HU  @?   H  H   H  H  H   H     Hy  H   Hl      &  H=  H'  H8   Hc  HB  H   H5  HCX  %  H=  H  H@   Hb  H  H   H  H1H      H   H<T      8,%  H=  HC  HH   H5b  HN  e   d   H             A    HOHH   HA     H  H   H         H  h   g       @    HEH4H   H4@     Hs  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  HZ  H   HM  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  HR  m   l   HcLE8   D9AD9HLH4H   H4A      He  H   HX     HcHcHH   Hi  HHcHcHH   Hi  HH  H   H     
H  H   H  HcHHc8   HcHH   Hi  HHcH8   8         H  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5m  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5  v   Au   A=    A=    MDNI   NA   &   HV  H   HI  H5  0H8  H   H+  H,  H   H      &   H  H   H     H  H   H  H  H   H  .H  H   H  .     H"  H5     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5<     A   A=    A=    MDNI   NA   &   H  H   H  HL4  (H  H   H  H  H   H  H  H   H      F  H=  H]  HP   HO[  H  H   H  HQ    H=  H  HX   H[  1H         HL  H     A   A    A    MENI   NA$   9   H  H   H  H      H     HZ             @    HEH4H   H4@   ^  Hm  H   H`  Hd*  H=        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH  H   H      HQ           @   HLH4H   H4@   W   H  H   H  HHx  H   Hk     \HU  H   HH      H        HDD9AD9HLH4H   H4A   {  H>        9A9HEH4H   H4A     H        HcLA8      A   HOH4H   H4A     Hv  H   Hi  H        HcLA8       A    HOH4H   H4A   9   1H  H   H  HI  jH  H   H      H           @   HLH4H   H4@   W   H  H   H  HbHu  H   Hh     \HR  H   HE  HF  H   H9  H:  H   H-  H.  H   H!     4H  H   H  H  H   H  H  H   H      :  H=  HQ  H`   HCU  H  H   H  H DL    H=  H  Hh   HT  H        HcLA^  HcLA?     A   HNHH   HA     H        HcLA?      A    HOH4H   H4A   ~   H  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?    H        HcLA^      A    HOH4H   H4A   ~   H  H   H  HcH^     HcHcHH?  Hi  HUHcH^  ^     H{  H   Hn  Ho  H   Hb  Hc  H   HV  ~  H        HcLA?      A    HDH4H   H4A     H  H   H      H        HcLE^  D9AD9HLH4H   H4A     H  H   H  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  H  H   H     H  H   H  HH  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   H  H   H  MHHcf  H^  Hf     f  EH  H   H      H^           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4AR   Hw        HcL   A   HDH4H   H4A   2   H  H   H  H           H        HcL   A   HDH4H   H4A9  H        HcL   A   HDH4H   H4A   HY        HcL   A   HDH4H   H4A   H        HcL
   A
   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   I   H-  H   H   HNH64   H  H   H  H      H   H  H   H  H  H   H  H  H   H     ?H  H   Hx      <  H=  HS  Hp   HEJ  HN  H   HA  H C    H=  H  Hx   HI     H  H   H  H    H        HDD9AD9HLH4H   H4A   2  Hy        9A9HEH4H   H4A     HN  H   HA      H        HcLE8   D9AD9HLH4H   H4A     H        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1H  H   H{  H+:   o  H	        HcLE8   D9AD9HDH4H   H4A      H  H   H      H        HcLE8   D9AD9HLH4H   H4A   ?   H  H   H  H  H   H     dHz  H   Hm  ?   Hi  H   H\  H]  H   HP     H:  H   H-  H.  H   H!  H"  H   H     }1H  H   H  H08        H=  H  H   HE  H        H      H   HcLALAHDHH   HA   #   H>  H   H1       H  H   H  HcHtp   tpH7        H=}  H  H   HD  1H  H   H  H         H6      3  H=  HJ  H   H<D  HU        H             A    HEHH   HA   x   H  H   H  H   H	     H   H5  1Hu  H   Hh  H`5        H=  H  H   HB  H   H   H      H      HDD9AD9HLH4H   H4A     H      9A9HEH4H   H4A   &  H  H   H  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    Hp  H   Hc  Hd  H   HW     HA  H   H4        H=j  H  H   H@  H
  H   H      H      HcLE8   D9AD9HLH4H   H4A      H5      HcLcLI   Mi  MA   A   HDH4H   H4A   p   H      9A9HEH4H   H4A   %   H  H   H  ?   H  H   H  H  H   H     H      @HOH4H   H4@   5     Hs  H   Hf  H0     H0      Hd         @   HLH4H   H4@   a         H  H   H  H~  H  H   H     RH  H   H     U   Hs  H   Hf  2   H=  H5I  D=  H5E  H   H57  H  H'  H   H  H H;E   H(	  []   )v)hmyw     UHH0H  H   H  }HuH        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       H}  H   Hp  E  }Hu  H59        =   A=   HLHH   HA       H$  H   H  E*  HE   }M  H        AM9A9ILLI   LA       H  H   H  E   1H  H   H  HE      }HuM`  Hu   }EM   M)Hu   Hu      HE  H   H8  H9  H   H,  H-  H   H   E    H  H   H  EH0]@ UHH  H   H  }HuH
  H   H  MMHEHEHcUHuD]UHH H  H   H  }G      EEMHHHUHuh  H  HMHcHH=  Hu  H   HG9  Hx  H   Hk  E    G  H=  H9  H   H9  HD  H   H7  E     H=  H  H   H8  H  H   H  E     H=X  H  H    H8  H  H   H  E     H=  H  H(   HW8  H  H   H  E    W  H=  HI  H0   H8  Ht  H   Hg  E     H=  H  H8   H7  H@  H   H3  E     H=h  H  H@   H7  H  H   H  E     H=,  H  HH   Hg7  H  H   H  E   g  H=  HY  HP   H+7  H  H   H  E   +  H=  H  HX   H6  Hp  H   Hc  E     H=x  H  H`   H6  H<  H   H/  E     H=<  H  Hh   Hw6  H  H   H  E   w  H=   Hi  Hp   H;6  H  H   H  E   ;  H=  H-  Hx   H5  H  H   H  E     H=  H  H   H5  Hl  H   H_  E     H=L  H  H   H5  H8  H   H+  E     H=  Hy  H   HK5  H  H   H  E   K  H=  H=  H   H5  H  H   H  E     H=  H  H   H4  H  H   H  E     H=\  H  H   H4  Hh  H   H[  E     H=   H  H   H[4  H4  H   H'  E   [  H=  HM  H   H4  H   H   H  E     H=  H  H   H3  H  H   H  E      H=l  H  H   H3  H  H   H  E      H=0  H  H   Hk3  Hd  H   HW  E   k   H=  H]  H   H/3  H0  H   H#  E   /   H=  H5!  2  H5  H   H5  EH  H   H  EH ] ]M=y-iYI9u@ UHH0H  H   H  UHu}MEEHMHMUUuu}HuH        A=   A=   ILLI   LA       H\  H   HO  E   H$        M   @   HDH4H   H4@   d   H
  H   H  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  Hv        M   @   HDH4H   H4@   d   Ht  H   Hg  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  H  H   H  H  H   H  HcEHMTTE    H  H   H  EH0]fffff.     UHHHY  H   HL  H}HI  H   H<  HEHEH}   HcHM8   H]    UHH  H   H  H}H  H   H  HEHEHM   ]fff.     UHH  H   H  u}HUH  H   H  MMUUHEHEE    E    H        MHc}LEE?  D9AD9HLH4H   H4A      H=        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    Hc     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E    H5        MHc}LEE^  D9AD9HLH4H   H4A      H        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H+  H   H  M   MH  H   H  H  H   H  M   MH  H   H  E]UHH0H  H   H  H}H  H   H  HEHEH}EE    H        MHc}LEE8   D9AD9HLH4H   H4A      Hf  H   HY  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HH  H   H  M   MH        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   Hc  H   HV  M   HE   "   H?  H   H2  HE       H%  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    HL        M   @   HLH4H   H4@   O   Hj  H   H]  HE   HuEHH  H   H;  M   Mg1H)  H   H  HE   Hu1EH0]@ UHH  H   H  H}H        H}H}LEAH    A    HDH4H   H4A       H  H   H  E     H  H   Hy  E    E    HD        M   @   HLH4H   H4@      H        Hc}LEAL    A    HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   M	HM        M   @   HMH4H   H4@       Hs  H   Hf  E      H[  H   HN  E    HH  H   H;  E]fD  UHH@H1  H   H$  }HuH  H   H  MMHEHEE    E    H        MHc}LEE8   D9AD9HLH4H   H4A     H        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       HZ  H   HM  M   MH
        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MHr        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H(  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  E    H        MHc}LEE^  D9AD9HLH4H   H4A     H        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H"  H   H  M   MH        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       HB  H   H5  M   MH
  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       Hb  H   HU  M   MH  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  E    H  1   0   MHc}LEE^  D9AD9HLH4H   H4A     H  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH*  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H*  H   H  M   MH
  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H}  H~  H   Hq  M   M+Ha  H   HT  EH@]ff.     UHH0HA  H   H4  H}HuH-  H   H   HEHEHMHME    H        M   @   HLH4H   H4@      H        MH}DD9AD9HMH4H   H4A   (   H  H   H  HcEHM+   Hu  H   Hh  }HuHcuHMHR  H   HE  HF  H   H9  M   MH)  H   H  E    E    H        M   @   HLH4H   H4@      Hm        Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMHz  H   Hm  Hn  H   Ha  M   M
HQ  H   HD  HcEHMUH}-EE    H        M   @   HLH4H   H4@      HB        Hc}LEADMD9AD9HDH4H   H4A   m   H        M}9A9HOH4H   H4A   (   Ht  H   Hg  HcEHM   HT  H   HG  HH  H   H;  M   MH+  H   H  E    E    H)        M   @   HLH4H   H4@      H         Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH|  H   Ho  Hp  H   Hc  M   M
HS  H   HF  HcEHMUE    H
  &   %   M   @   HLH4H   H4@      H  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   H  H   H  HcEHM   #   H  H   H  HcEHM    H|  H   Ho  Hp  H   Hc  M   M1HQ  H   HC  H0]D  UHH   H>  H HEH  H   H  HH  H   H  HHH       Ht           @   HLH4H   H4@     H'        HcLA?     A   HLH4H   H4A   ,   H  H   H  H[H#H=yw  HcH8      HcHcLI   Hi  IA 6u  H+        A   A   IDLI   LA   H  
   	      @   HDH4H   H4@M   H           @   HDH4H   H4@   +   H  H   H     \   H  H   H  Hc HcH8   8      H8  H   H+  3H'  H   H  H               @    HMH4H   H4@      H  H   H     Hc HcH^     ^  HcHcLI?  Hi  IA   "1HS  H   HF  H.   H~  HH;U   1H   ]q  @ UHH  H   H  HUu}MH        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   Hs  H   Hf  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  H        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   H  H   H  HcEHM8   8   \  HF        Hc}LEA8      A   HDH4H   H4A   5   H7  H   H*  HcEHM8   8      H
  H   H  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   HV  H   HI  1HH  H   H:  ]     UHH0H  H   H  H}uH  H   H  HEHEMMH}REE    H        M   @   HLH4H   H4@   H   Hg  H   HZ  }HuEHL  H   H?  M   Mn1H-  H   H   }uHU1EH0]@ UHH0H  H   H  H}uH  H   H  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPH  H   H  MUuH}DEHEHEMMUUuu}}H}H=     A   AEE=   A=   MDNI   NA   7   Hn  H   Ha  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   H  H   H  HE      HE   <   1H  H   H  }uHU1}uHUEEH  H   H     H  H   H  }uHUQ1EHP]@ UHHPH  H   H  UuH}MHEHEMMUUuuH}H=M     A   AEE    E=   A=   MONI   NAJ   H        M    @    HLH4H   H4@       H  H   H  E  H        M}9A9HDH4H   H4A       H  H   H  E{  Hw  H   Hj  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  H        M}9A9HEH4H   H4A      H{        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       Ha  H   HT  M   MHI  H   H<  H=  H   H0  M   MdHx        M}9A9HLH4H   H4A       H  H   H  E_  H  H   H  MHcEHULLE    H        MH}DD9AD9HLH4H   H4A      H        M}9A9HEH4H   H4A   E   1H;  H   H.  HcEHcMHuH   Hi  H<HuM:EH   H   H  H  H   H  M   M1H  H   H  }uHUYE    EH  "   !   M}9A9HLH4H   H4A     H{  H   Hn  E    HH  %   $   MHc}LEE8   D9AD9HLH4H   H4A      H  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      H  H   H  }uHUE9   H  H   H|  H}  H   Hp  M   MH`  H   HS  HT  H   HG  M   M'H7  H   H*  E    H$  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=1f  H5f  V0I  1H5tf  /AVUMN  	   H51{  |R     H5Ef  [H1AVM     H5J{  MR     H5f  1AVM     H5+{  R     H5e  VI1AVM  a   H5{  Q     H5e  ;|1AVaM     H5}  Q     H5e  ] t1AV2M     H5f~  Q     H5e  T1AVM     H5~  bQ     H5he  w1AVL     H5  3Q     H5Fe  YAr1AVL     H5~  Q  	   H5 e  j1AVvL     H5~  P  
   H5d  a'Hr1AVGL     H5~  P     H5d  @1AVL     H5\  wP     H5d  -1AVK     H5=  HP     H5d  "mw1AVK     H5  P     H5ld  |1AVK  G   H5  O     H5Fd  b1AV\K  .   H5   O     H5"d  W71AV-K     H5A  O     H5c  `1AVJ  :   H5  ]O     H5c  eW1AVJ    H53  .O     H5c  Qw1AVJ     H5  N     H5c  :/T1AVqJ     H5E  N     H5hc  r%1AVBJ     H5  N     H5Ec  Ba1AVJ     H5  rN     H5%c  PR1AVI     H5h  CN     H5c  Ce&1AVI     H5q  N     H5b  #e,1AVI  /   H5Z  M     H5b  Ql1AVWI  
   H5  M  Q  Z  H]fD  UHH|v      Hiv      HVv      HCv      H0v      Hv      H
v      Hu      Hu      H)v      Hv      H#v      Hv      Hx      Hx      Hw      Hw      Hw      Hw      Hw      Hw      H}w      Hjw      HWw      HDw      H1w      Hw      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Hsv      H`v      HMv      H:v      H'v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      H|u      Hiu      HVu      HCu      H0u      Hu      H
u      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hrt      H_t      HLt      H9t      H&t      Ht      H t      Hs      Hs      Hs      Hs      Hs      Hs      H{s      Hhs      H]v      HJv      H7v      H$v      Hv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Hyu      Hfu      HSu      H@u      H-u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hot      H\t      HIt      H6t      H#t      Ht      Hs      Hu      Hu      Htu      Hau      HNu      H;u      H(u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      H}t      Hjt      HWt      HDt      H1t      HFu      H3u      H u      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hut      Hbt      HOt      H<t      H)t      Ht      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hst      H`t      HMt      H:t      H't      Ht      Ht      Hvt      Hct      Hpt      H]t      Hjt      HWt      H,u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hnt      H[t      HHt      H5t      H"t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hws      Hds      HQs      Ht      Ht      Ht      Hut      Hbt      HOt      H<t      H)t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      H~s      Hks      H`t      HMt      H:t      H't      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      H|s      His      HVs      HCs      H0s      Hu      Hu      Hu      Htu      Hau      HNu      H;u      H(u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      H}t      Hjt      HWt      HDt      H1t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hss      H`s      HMs      H:s      H's      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      H|r      Hir      HVr      HCr      H0r      Hr      H
r      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hrq      H_q      HLq      H9q      H&q      Hq      H q      H%s      Hs      Hr      Hr      Hr      Hr      Hr      HPt      H=t      H*t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hls      HYs      HFs      H3s      H s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hur      Hbr      HOr      H<r      H)r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      H~q      Hkq      HXq      HEq      H2q      Hq      Hq      Hp      Hr      Hr      Hr      Hr      Hr      Hor      H\r      HIr      H6r      H#r      Hr      Hq      Hq      Hq      Hq      Ht      Hs      Hs      Hs      Hs      Hs      Hs      H|s      His      HVs      HCs      H0s      Hs      H
s      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hrr      H_r      HLr      H9r      H&r      Hr      H r      Hq      Hq      Hq      Hq      Hq      Hq      H{q      Hhq      HUq      HBq      H/q      Hq      H	q      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hqp      H^p      HKp      H8p      H%p      Hp      Ho      Ho      Ho      Ho      Hs      Hps      H]s      HJs      H7s      H$s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hyr      Hfr      HSr      H@r      H-r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hoq      H\q      HIq      H6q      H#q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hxp      Hep      HRp      H?p      H,p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hno      H[o      HHo      H5o      H"o      Ho      Hn      Hn      Hn      Hr      Hr      Hr      Hr      Hwr      Hdr      HQr      H>r      H+r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hmq      HZq      HGq      H4q      H!q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hvp      Hcp      HPp      H=p      H*p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hlo      HYo      HFo      H3o      H o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hun      Hbn      HOn      H<n      H)n      Hn      Hr      Hq      Hq      Hq      Hq      Hq      Hq      H~q      Hkq      HXq      HEq      H2q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Htp      Hap      HNp      H;p      H(p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      H}o      Hjo      HWo      HDo      H1o      Ho      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hsn      H`n      HMn      H:n      H'n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H|m      Him      HVm      HCq      H0q      Hq      H
q      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hrp      H_p      HLp      H9p      H&p      Hp      H p      Ho      Ho      Ho      Ho      Ho      Ho      H{o      Hho      HUo      HBo      H/o      Ho      H	o      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hqn      H^n      HKn      H8n      H%n      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hzm      Hgm      HTm      HAm      H.m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      H{o      Hho      HUo      HBo      H/o      Ho      H	o      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hqn      H^n      HKn      H8n      H%n      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hzm      Hgm      HTm      HAm      Hn      Hn      Hpn      H]n      HJn      H7n      H$n      Hn      Hm      Hm      Hm      Hm      Hm      Hn      Hln      HYn      HFn      H3n      H n      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hun      Hbn      HOn      H<n      H)n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H~m      Hkm      HXm      HEm      H2m      HWn      HDn      H1n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hsm      H`m      HMm      H:m      H'm      Hm      Hm      Hl      Hl      Hm      Hm      Hm      Hwm      Hdm      HQm      H>m      Hsm      H`m      Hn      Hn      Hn      Hn      Hn      H~n      Hkn      HXn      HEn      H2n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Htm      Ham      HNm      H;m      H(m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      H}l      Hjl      HWl      HDl      H1l      Hl      Hl      Hk      Hk      Hk      Hk      Hk      Hk      Hk      Hsk      H0m      Hm      H
m      Hl      Hl      Hl      Hl      Hl      Hl      Hl      ] UHH=H59  ]UHHPg  HG  H HEHl  H   Hl  1E    :  :  H=#>  H,<  (   HuEJ  E   E    HHH4:  H P:  HHu1Af  DIHLHLHL9  }UHHDHEE  Hk        =   AAAALcI    AI    HEH<H   H<A      H=I?  H5.=  '   H.=  8  H<k  H   H/k  HHu1f  HHH8  }UHHCHEE  Hj        =   AAAALcI    AI    HEH<H   H<A      H=Z>  H5?<  +   HR<  7  Hmj  H   H`j  H=K<  HZj  H   HMj   28  H=wD  H?H;}   1HPg  ]7  @ UHH0Hj  H   Hj  H}H=;  Hi  H   Hi  HEHEE    HM   U 7  E    EHi        M   @   HLH4H   H4@   z   Hi  H   Hzi  HcEHM^     ^  HcHcMH}H?  Hi  H   H:i  H   H-i  M   M<Hi  H   Hi  E    Hh        MHc}LEE?  D9AD9HLH4H   H4A   ]   Hh  H   Hh  HcEHcMHUHH   Hi  H   Hh  H   Hh  M   MO1Hwh  H   Hih  HcMHUH   Hi  H   LEaZE    EHg        MH}Df  D9AD9HLH4H   H4A      Hg        Hc}LEA^     A   HDH4H   H4A      Hg  H   Hg  E   Hg  H   Hg  Hg  H   H~g  M   MHf        M    @    HEH4H   H4@   *   H=8  H-g  H   H g   U4  E%   H=8  Hg  H   Hf   +4  EHf  H   Hf  EH0]    UHAWAVSH8Hf  H   Hf  H}H=8  Hf  H   Hf  HEHEE    HM   U 3  E    EHlf        M   @   HLH4H   H4@   z   HBf  H   H5f  HcEHM^     ^  HcHcMH}H?  Hi  H   He  H   He  M   M<He  H   He  E    He        MHc}LEE?  D9AD9HLH4H   H4A   ]   He  H   Hte  HcEHcMHUHH   Hi  H   HQe  H   HDe  M   MOH4e  H   H'e  HcEHMH   Hi  H   E    Hd        MHc}LEE8   D9AD9HLH4H   H4A   j   H=[6  Hd  H   Hd  HcEHcMHUH   Hi  H4 71  EHd  H   Htd  M   MB1LEULc     A   ALc]H]B8      MLc]Hc]LuI   Hi  IC   A   MDOI   OAE   HPc        Hc}LcELMI   Mi  MA   A   HDH4H   H4Ah   Hb        Hc}LcELMI   Mi  MA   A   HDH4H   H4A   N  Hb        Hc}LEI   Hi  IA   A   HDH4H   H4A   H'b        Hc}LEI   Hi  IA   A   HDH4H   H4Ac   Ha        Hc}LEI   Hi  IA   A   HDH4H   H4A      HFb  H   H9b  E   H3b  H   H&b  H7a        M    @    HEH4H   H4@   *   H=2  Ha  H   Ha   -  E%   H=3  Ha  H   Ha   -  EHa  H   Ha  EH8[A^A_] UHHH=3  H5/  tf  1H5U3  3WAtfUM}  
   H5!_       H5#3  K1AtfN     H5B_       H52  1Atf  #   H5_  ~  Y  (  H]fffff.     UH'H^      H^      H^      H^      H^      Hu^      Hb^      HO^      H<^      H)^      H&_      H_      H _      H^      H^      H^      H^      H^      H^      H{^      Hh^      HU^      HB^      H/^      H^      H	^      H]      H]      H]      H]      H]      H]      H]      Hq]      H6_      H#_      H_      H^      H^      H^      H^      H^      H^      H^      Hx^      He^      HR^      H?^      H,^      H^      H^      H]      H]      H]      H]      H]      H]      H]      Hn]      H[]      HH]      H5]      H"]      H]      H\      H\      H\      H\      H\      ]fffff.     UHH=H5I(  ]UHH]  H   H]  H]          L8  HE  HEG  LcN]  OHELHUHHHi  Lc,]  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   H7  H\  H   H\  HMHc\  H2   H7  H\  H   H\  HMHHcn\  H**  H7  H\  H   H~\  Hc?\  H*^(]UHH@Ha\  H   HT\  H}1HO\  H   HB\  HEHEHEm HE  [     [  M  H}  M[  E   H[        M   @   HLH4H   H4@   K  H[        m Lt6  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   H5  H[  H   H[  HMHcUH/   H5  HZ  H   HZ  HMHHcUHHZ  H   HZ  HZ  H   HZ  M   MkHZ  H   HZ  H@]fUHHHQ[  H   HD[  }H:[        MM}   =Y  =Y      A    HDH4H   H4A   n   HZ        dY      @    HEH4H   H4@   !   [HZ  H   HZ  HZ  H   HZ  H]    UHH0HY  H   HtY  H}HiY        H}H}E LEI    AI    HOH4H   H4A   )   H!Y  H   HY  HEHHHUHX        H}H    AH    HLH4H   H4A   .   1HX  H   HX  $  1HHUHlX        H}H    AH    HDH4H   H4A     HgX  H   HZX  HX     
   } @@@HEH4H   H4@   "  H=$)   !#  H=L)  HuE #  1H5W  1   A   ALUL9AL9MLJ<H   J<AEU   "   HW  H   HW  H}MEH'W        $EE< A< HEH<H   H<A%   H=z(  HaW  H   HTW   )"  EHKW  H   H>W  H:W  H   H-W  H1  H'W  H   HW  HMHcU  HH0]@ UHHV  H   HV  H}H0  HV  H   HV  HMHMHcyU  HHUH]fff.     UHH0HV  H   HV  1HV  H   HV  E %   +HE    HV        H}H'  AH'  HLH4H   H4A   E   HV  H   HrV  EHiV  H   H\V  HEH   HEnH}   H}Z$EY   H}1H=U        M    A    HEH4H   H4AE   "   HU  H   HU  H}Y  MEHfU  
   	   $EE< A< HEH<H   H<A   *   H=%  HkU  H   H^U   c  E%   H=%  HIU  H   H<U   9  EH3U  H   H&U  H0]     UHHH=%  H5R!  M_   1H5&  hnAM_UM     H5R  L     H5%  8I1AM_     H5R       H5%   1AM_     H5S       H5%  r~61AM_`     H5|S       H5n%  XH1AM_1     H5eS       H5L%  
1AM_     H5vS  a  <  g  H]UHHQ      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HuQ      HbQ      HOQ      H<Q      H1R      HR      HR      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HsQ      H`Q      HMQ      H:Q      H'Q      HQ      HQ      HP      HP      HP      HP      HZQ      HGQ      HQ      HqQ      H^Q      HKQ      H8Q      H%Q      HQ      HQ      HQ      HQ      HvQ      HcQ      HPQ      H=Q      H*Q      HQ      HQ      HP      HP      HP      HP      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH=#    HH=#    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IHz  IK|&I  HHHL  AD./tB3/IHLLL  EL<$H	P  
P      1H  1  tL54!     O  H=O      1  0  L5!  uhH-O  H]fffff.     Ht/u   HE  /H=cO      1@  l0         =Q0  L  H2O  H/O      H,O      H)O      O  u&1     HHN  HN        1   Hl  H=N  f  HO  HtfD/  1      E1Hf  HHN  H     8H$  HH-^N  q  HH5"!  1HH  CN  HHN      HEN      H-FN  1H  t)H H  1H  HH	N  H-
N  1   H  M  H-M  tbHEH;M  vrH  H  HH  HM  H-M  HM  M  adcgHM  HCHM  t?+adcgHM  HHwM  1gHlM  adcgH^M  HCHSM  HSH;>M  v8H  H  H=M  H  HM  HM  HM  L  HL  A74HL  HCHL  t?HKH;L  v2H  H  H=L  H  HL  HL  HL  HL  D,HL  H[A\A]A^A_]  8H"  HH-GL  Z  HH5  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=K   1  T$D$K  u?HK  HCH;K  v+H  H  H=K  H  HK  HK  HK  HyK     H{K  L{L=pK  MtLY  Hl(5K  tfHCH;>K     H  H  H=K  H  HK  HK  HK  J  ,HJ  HCHJ  u\HJ  B,8HJ  HHJ  HJ  D$HJ  HHJ     HJ  B,8HJ  HCHJ  HKH;|J  vVH  H  H=]J  H=  HNJ  HOJ  HPJ  )J  D$H>J  HCH3J  u^HJ  D$HJ  HCHJ  HKH;I  v2H  H  H=I  H  HI  HI  HI  HI  T$H-I  H]HI  EtjI  u?HEH;I  v2H  H  H=mI  HM  H^I  H-_I  H`I  HII  $HLI  HHAI  My  L&  HH I  uKHCAH;I  v>H  H  H=H  H  HH  HH  D=H  HH  E1HH  ,H-H  HH-H  L  IAtALHH;H  v2H H  H=lH  HL  H]H  H^H  H-_H  H-HH  HLL  H-CH  LH-9H  L'  H   H)G  u?L4+L;5H  v2I I  H=G  L  HG  L5G  H-G  H-G  1HHn  HG  H[A\A]A^A_]     UAWAVAUATSPIAH=wG      L%G  \G     L%mG  ID$H;YG  }  I  I  H=6G  L  H'G  L%(G  H)G  G    HG  HCH	G  C,6E1  ;  H[A\A]A^A_]HF  B#ID$HF  E1       BL#Il$H-F    D9  DH  IEtvAN1AtH+HH-`F  I   tOHILAVp)f.     Ht+H-,F  HqH4+H}H=F  H1HHHuL%E  B#  HE  HHE  C,6jHE  B   HE  HCHE  C,6HKE1H;E  v5H  H  H=E  Hd  HuE  HvE  E1HtE  H]E  ,HcE  HHXE  E  M   Lff.     I] H] I] E  u@L%E  ID$H;E  v+I  I  H=D  L  HD  L%D  HD  HD  HHD  HIAu   fff.     Im }D  u?HCH;D  v2H  H  H=fD  HF  HWD  HXD  HYD  HBD  H,HGD  HH<D  IAuLH[A\A]A^A_]  H6  H8HC  H5X  H  H8HC  H5  1H[A\A]A^A_]N  fffff.     SH=C     HC  C  tzHC  HCH;C     H  H  H=kC  HK  H\C  H]C  H^C  7C     HIC  HKH>C       oHC  HCHC        LHCHB  	l  DHKHB     HB     HB  HKHB  HCH;B    H  H  H=B  Hi  HzB  H{B  H|B  UB  	   HgB  HKH\B     uS       H8B     H*B  HHB  HB  
	   H
B  HHA  HA  
    HA  HHA  HA  
    HA  HHA  HA  
HA  HHA  HA      HA  HHA  HlA      HnA  HHcA  HLA      HNA  HHCA  H,A      H.A  HH#A  HA      HA  HHA  H@      H@  HH@  H@     H@  HH@  H@      H@  [H@  	   H@  HKH@  HCH;x@  vbH  H  H=Y@  H9
  HJ@  HK@  HL@  %@      H7@  HKH,@     ? H@      H@  HKH?  HCH;?     H  H  H=?  H	  H?  H?  H?  ?      H?  HKH?     ZH  H8HP?  H5  H  H8H6?  H5H  1[  H8?      H:?  HKH/?  HCH;?  v]H  H  H=>  H  H>  H>  H>  >     H>  HCH>  $ H>     H>  HCH>  HKH;>  v[H  H  H=s>  HS  Hd>  He>  Hf>  @>      HR>  HCHG>   H&>      H(>  HCH>  HKH;
>  v]H  H  H==  H  H=  H=  H=  =      H=  HCH=  R H=      H=  HCH=  HKH;=  v]H  H  H=a=  HA  HR=  HS=  HT=  -=      H?=  HCH4=   H=      H=  HCH	=  HKH;<  v]H  H  H=<  H  H<  H<  H<  <      H<  HCH<  ~ H<      H<  HCH<  HKH;l<  v]H  H  H=M<  H-  H><  H?<  H@<  <      H+<  HCH <   H;      H <  HCH;  HKH;;  vZH  H  H=;  H  H;  H;  H;  ;      H;  HCH;  u%Hw;      Hy;  HCHn;  HKH;[;  v]H  H  H=<;  H  H-;  H.;  H/;  ;     H;  HCH;  C H:     H:  HCH:  HKH;:  H  H  H=:  H  H:  H:  H:  @ AVSPH=t:   N  _:  uIHs:  HKH;^:  v5H  H  H=?:  H  H0:  H1:  :  1H(:  H:  H
    H5:  HH5:  H=9  tH9     {  H=9  ]  sH5:       u4
  8H  L0H9    HH5j  1LH  H=|9  H59  @  He9      H9      H=K9    =P       H+9      H(9      H=	9  H[A^  ffff.     SH     HH@    H=8   tH8  HAH8  [H8  H8  [f     SH8  fD  1H[Hu[Pffff.     HGH8    H=8  HuH8      Hn8      Xfff.     SH     HH@    H=O8   tHN8  HAHC8  [H:8  H+8  [f     SH8  fD  1H[Hu[Pffff.     HGH7  F  H=7  HuH7      H7      Xfff.     AVSPIHHtA     HH@    H=t7   tHs7  HAHh7  H_7  HP7  MtA      L0H@    H=>7   tH=7  HAH27  H)7  H7  $7  tH[A^7  H=1   H=.%   H=H[A^   %  %  %  %  %  %  %  %  %   %  %  %  %  %
  %  %  %  %  %  %  %  %  %  %  %   %"  %$  %&  %(  %*  %,  %.    L%  AS%  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h~  h  h  h  h  h                    	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for adventurer card effect
===================
      cardtest2.c discard(&state)==1 handTreasures(&state)==1 All tests successful!

 	Test that Adventurer card discard is correct.
 	Test succeeds. Adventurer present in discard.
 	##TEST FAIL## Adventurer not present in final discard.
 	Test that Adventurer gets 2 new treasure cards in hand.
 %d  	Test succeeds. Newest cards in hand are treasure.
 	##TEST FAIL## Adventurer postcondition not met. Cards other than treasure in hand.
       /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest2.gcda      main discard handTreasures        
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           4       4          a   
  L   L   +     L        X         ` P     W         0 `  P   `    !            zR x         zR x         zR x         zR x  <             ABB B(B0A8A@         \                  <   |   h       ABB B(B0A8A@      <             ABB B(B0A8A@            P,	       A  $     `s       BAA      D  G        A     d          A       D        A         G        A       H        A       HD        A    $     x        BAA                                                           $    .    8    B    L    V    `    j    t    ~                                                         
            (    2                           x&    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &     '    '    '    '     '    ('    0'    8'    @'    H'    P'    `(    h(    p(    x(    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (     )                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `#A`1@___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time     _  _mh_execute_header c n kingdomCards i s d updateCoins play hand buyCard g whoseTurn fullDeckCount endTurn main Random P SelectStream GetSeed TestRandom     ompare ardEffect    ewGame umHandCards      nitializeGame sGameOver    huffle upplyCount coreFor  8  rawCard iscard  B  J  Card A S GreatHall  P  Card Treasures  V  W      et ainCard  Cost Winners                    dventurer mbassador    Card     mithy teward                  lantSeeds utSeed             P	mP`P	P
H  ` 	 P PP P     d           M   d           X   f W       .  
        $  
        $   P         N  P         .  @        $  @        $   P          N  P          .          $          $   @         N  @         .          $          $            N           .  `        $  `        $            N           .  @!        $  @!        $            N           .  P%        $  P%        $             N            .  P(        $  P(        $            N           .  @+       $  @+        $             N            .  +       $  +        $   6         N  6         .  b       $  b        $   p         N  p         .  e     &  $  e        $   P          N  P          .  `e     3  $  `e        $   p         N  p         .  l     <  $  l        $            N           .  o     F  $  o        $   `          N  `          .  p     T  $  p        $   P          N  P          .  `p     _  $  `p        $            N           .  @t     n  $  @t        $   p         N  p         .  w     w  $  w        $   P         N  P         .   z       $   z        $   0         N  0         .  0       $  0        $            N           .         $          $            N           .  P       $  P        $             N            .  p       $  p        $             N            .         $          $             N            .  0       $  0        $            N           .         $          $            N           .          $           $   P          N  P          .  p       $  p        $   0         N  0         .       ,  $          $   $         N  $         .       ?  $          $             N         Q  &  @    i  &         &        &        &        &  8      &  H      &  `    
  &  p      &      .  &      @  &       R  &  (     d  &  8     w  &  P       &   !      &  0!      &  !      &  @"      &  $      &  %      &  p&      &  @(    "  &  @1    5  &  1    H  &   2    [  &  2    n  &  `3      &  3      &  3      &  05       d             d             d             f W       .         $          $            N           .       "  $          $             N            .       +  $          $   `         N  `         .       :  $          $             N            .       P  $          $            N           .       c  $          $             N         u  &  5      &  5      &  6       d             d             d             f 
W       .         $          $   p         N  p         .         $          $   0         N  0         .         $          $            N           .       &  $          $   0         N  0         .       /  $          $   `          N  `          .  P     8  $  P        $   P         N  P         .       D  $          $   P         N  P         .       Z  $          $            N           .       m  $          $             N           &        &  7      &  7      &  7      &  7      &  P8      &  8      &  9      &  P9       d                    -    p     C         V         h         ~                                                                        3    @     H          `    P     t                      @                             	    P    +	    @    C	         ]	        |	        	        	        	        	    8    	    H    	    `    	    p     
        
        $
         6
    (     H
    8     [
    P     n
     !    
    0!    
    !    
    @"    
    $    
    %    
    p&    
    @(        @1        1    ,     2    ?    2    R    `3    e    3    x    3        05        5        5        6        7        7        7        7        P8        8    1    9    C    P9    U    9    _    9    i    9    v    9        9        9        9        9         :        :        :        :                               $         ,         :    P     F          Z    b     c    +     o    
     x             P         @!         @t         `p         l         `e         0         @+                           w                           @     !    o     /         ?         O    P(     Y         h    p     t    0          z         `         e         P%         p                                                                                                                              %            ,            5            ;            B            I            Q            Y            a            i            q            x            ~                                                                                                                                                            c  d  e  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~              f  g       @c  d  e  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~                /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 cardtest2.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest2.o _main _discard _handTreasures ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _compare _discard _discardCard _drawCard _endTurn _fullDeckCount _gainCard _getCost _getWinners _handCard _handTreasures _initializeGame _isGameOver _kingdomCards _main _newGame _numHandCards _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder       File 'dominion.c'
Lines executed:0.00% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
    #####:   12:    return -1;
    #####:   13:  return 0;
    #####:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
    #####:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    #####:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
    #####:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
    #####:  215:    card = floor(Random() * state->deckCount[player]);
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
    #####:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
    #####:  226:  }
        -:  227:
    #####:  228:  return 0;
    #####:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
    #####:  315:  int currentPlayer = whoseTurn(state);
    #####:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
    #####:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
    #####:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
    #####:  532:    for (i = 0; i < state->discardCount[player];i++){
    #####:  533:      state->deck[player][i] = state->discard[player][i];
    #####:  534:      state->discard[player][i] = -1;
    #####:  535:    }
        -:  536:
    #####:  537:    state->deckCount[player] = state->discardCount[player];
    #####:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
    #####:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
    #####:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
    #####:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
    #####:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
    #####:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
    #####:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  562:    state->deckCount[player]--;
    #####:  563:    state->handCount[player]++;//Increment hand count
    #####:  564:  }
        -:  565:
        -:  566:  else{
    #####:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
    #####:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  575:    state->deckCount[player]--;
    #####:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
    #####:  579:  return 0;
    #####:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
    #####:  652:  int currentPlayer = whoseTurn(state);
    #####:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
    #####:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
    #####:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
    #####:  659:  int z = 0;// this is the counter for the temp hand
    #####:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
    #####:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
    #####:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
    #####:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
    #####:  823:      discardCard(handPos, currentPlayer, state, 0);
    #####:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
    #####:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
    #####: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
    #####: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
    #####: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1124:      state->playedCardCount++;
    #####: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
    #####: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
    #####: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
    #####: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
    #####: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
    #####: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
    #####: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
    #####: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
    #####: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
    #####: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
    #####: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
    #####: 1203:	  state->coins += 1;
    #####: 1204:	}
    #####: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
    #####: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
    #####: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
    #####: 1216:  state->coins += bonus;
        -: 1217:
    #####: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
    #####: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
    #####: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
    #####: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
    #####: 1273:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                  __text          __TEXT          `     Z      `                           __stubs         __TEXT                                             __stub_helper   __TEXT          |    P      |                          __const         __TEXT              @                                   __cstring       __TEXT                                               __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                0                                __got           __DATA                                                  __nl_symbol_ptr __DATA                                    "           __la_symbol_ptr __DATA                                      $           __mod_init_func __DATA                                   	               __const         __DATA          @          @                            __data          __DATA                                                __bss           __DATA                                                     H   __LINKEDIT       @     0             /                    "  0           @           H     "         x%   X? 0     P       D  D  &   j  #                           H> D                             /usr/lib/dyld             Es5rG0&$       
  
 *              (     @                 8         
   /usr/lib/libSystem.B.dylib      &      % p   )      x%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     UHH H   Hx H}HuHi       H}H}LELELMA	LMED9AD9HOH4H   H4A       H" H   H E      H       H}H}DD9AD9HLH4H   H4A       H H   H E   H H   H E    H H   H E]ffffff.     UHHHy H   Hl f  Hf H   HX '  HEHEH]D  UHAWAVSHXE(DU D]]L5& I   L5 ]DMDEMUuEDUD]}(   H H   H EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D}Y  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPH H   H UHu}HM   EEHMHMUUHuHu  Hc}  H       E=   A=   HOH<H   H<AJ   H}       M   @   HLH4H   H4@       H[ H   HN Ej  HC H   H6 MHEE    H       M
   @
   HLH4H   H4@     H H   H E    H    
   M
   @
   HLH4H   H4@      H@       M}9A9HEH4H   H4A   y   H
       Hc}LEAHc}LEED9AD9HDH4H   H4A       H" H   H E  H
 H   H
 H
 H   H
 M   MH
 H   H
 H
 H   H
 M   M!H
       M   @   HDH4H   H4@   $   H~
 H   Hq
 HE@
      H	       M   @   HDH4H   H4@   $   H(
 H   H
 HE@      H
 H   H	 HE@   H	 H   H	 H	       M   @   HDH4H   H4@   :   H	 H   H	 HE@   HE@   HE@   5   H}	 H   Hp	 HE@   HE@   HE@   <   HK	 H   H=	 iU   )HMAHMA(   HMA   E   H #   "   M   @   HNH4H   H4@     H H   H E    H &   %   M
   @
   HLH4H   H4@   <  HR (   '   Hc}LEADMD9AD9HDH4H   H4A     H *   )   Hc}LEA   A   HDH4H   H4AS   H ,   +   Hc}LEA
   A
   HDH4H   H4A      H` .   -   M   @   HDH4H   H4@   )   H H   H HcEHMD   $   Hm H   H` HcEHMD   HQ H   HD $   H@ H   H3 HcEHMD
   H$ H   H ]   H H   H HcEHMDH H   H H H   H M   MzH H   H H H   H M   MH H   H E    H ;   :   M}9A9HLH4H   H4A     H] H   HP HcEHM?      E    HO >   =   M   @   HLH4H   H4@   y   H H   H HcEHcMHUHH   Hi  H   HcEHM?     ?  H H   H M   M=H H   H E   Hq C   B   M
   @
   HLH4H   H4@   y   HG H   H: HcEHcMHUHH   Hi  H   HcEHM?     ?  H H   H M   M=H H   H H H   H M   MH H   H E    HZ J   I   M}9A9HLH4H   H4A      }Hu  H5	 L   K   =    A=    HLHH   HA       H, H   H E  H H   H H H   H M   MH H   H E    HP R   Q   M}9A9HLH4H   H4A   _   H H   H HcEHM8       HcEHM^      Hq H   Hd M   M\HT H   HG E    H  W   V   M   @   HNH4H   H4@   I   H H   H HcEHMDp    H H   H M   MmH H   H HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    Hu  \   [   M   @   HLH4H   H4@   O   H H   H HE   Hu[  EH H   H M   Mg1H H   H HE   Hu	  E    EH H   H EHP] UHH  H  H HEH H   Hs  HH_        HH    LcLG?  A   AA   HLH4H   H4A   #   H  H   H       HH5  H   H5  HcHHH   Hi  HHcLIc?  =  H\        HcLA?      A    HOH4H   H4A     H7  H   H*    HcH*?  YG  ,HcHcHHH   Hi  HHc    Hg  	      HcLE?  A   D9AD9HLH4H   H4A      HS  H   HF     HcHcHHH   Hi  HHcHcHHH   Hi  HH  H   H     H  H   H  HcH?  ?  H  H   H      H        9A9HLH4H   H4A      HF  H   H9  Hc HcHcHHH   Hi  HHcH?     ?  H  H   H     H  H   H      H  H  H   H  H H;E   H  ]$  fffff.     UHH@H1 H   H$ }HuH       MMH}H}LcELMG?  A    AA    HNH4H   H4A     H H   H E    H       MHc}LEE^  D9AD9HLH4H   H4A      Hp H   Hc HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HH  H   H M   MHcEHM^  HcEHM?  HcEHM^      }HuMHf 	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H. H   H! El  H H   H	 M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      H H   Hx HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   H  H   H  E    H  H   H  EH@]fff.     UHHU H   HH Hu}UH? H   H2 MMHEHEUUHu       E    H       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   Hn H   Ha HE         Q  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H
 H   H
 HE            Hx
    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   Hp
 H   Hc
 HE         HN
 H   HA
 HB
 H   H5
 H6
 H   H)
 H*
 H   H
 M   M1H
 H   H	 UHM      ]UHAVSHPH>  H   H1  MUu}LEH        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H  H   H  E  H}        H}      A   HLH4H   H4A       H\  H   HO  E  }Hu  H5         EE=   A=   HLHH   HAJ   H  
   	   M   @   HOH4H   H4@       H  H   H  E   HE}uUMLEDMH$V  L/     A   A=    =    MLOI   O       HZ  H   HM  EJ   HB  H   H5  HE      HE   HuUAE    EH   H   H  EHP[A^]    UHH Hi  H   H\  }HuHV  H   HI  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL  MLUL  I   L  HDL HHDDLLHC  H=C     A   A   L  L]        LA   99MONI   N      H  H   H      +      H|o4  H4  HHcHH=  H1  H   Hq  H  H   H  H^  =4  H=  H  H   HFq  H  H   H      H           @   HLH4H   H4@   W   Hl  H   H_  HxHH  H   H;     \H%  H   H  H             H  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   Hz  H   Hm  HtHV  H   HI  HJ  H   H=     1H%  H   H  HHa      p1  H=@  H  H   Hn  H  H   H      Hr  *   )   HcLE8   D9AD9HNH4H   H4A      Hm  H   H`  HcHcHH   Hi  H4HcHcHcHH   Hi  HH  H   H         H  H   H  H   lH7  /   .      @   HDH4H   H4@   l  H3  H5  1   0   =    A=    HNHH   HA      H#  H   H     H   h2  H\  4   3   Ah9A9ILLI   LA   -   H=  H  H   H     d>   1H  H   H  H9      `Hc  H   HV  HW  H   HJ  GHF  H   H9      H`  ;   :   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHcHH   Hi  HHcH  H   H     Hk  H   H^      -  H=  H1  H    Hj  H4  H   H'  K-  H=  H  H(   HTj  H  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   Ha  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   H  H   H  +  H  F   E       @   HOH4H   H4@M   H  H   G        @    HLH4H   H4@   #   H  H   Hs  G+  HcHcHH   Hi  H<~.      \h.  H  K   J   \9A9HOH4H   H4A   #   H  H   H  *     H  H   H   H?5  1HXY      TH  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HX  P?   H  H   H  H  H   H     Hi  H   H\      (  H=2  Hw  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5  W   V   AL9A9IOLI   LA   #   H  H   H|  '  1Hl  H   H_   H2  1HHV      DHH  [   Z   HcLE8   D9AD9HLH4H   H4A      H  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1Hg  H   HZ  HU  @?   H8  H   H+  H,  H   H     H	  H   H      &  H=r  H  H8   Hc  H  H   H  HCX  %  H=%  Hj  H@   Hb  H  H   H  H1H      H   H<T      8,%  H=  H  HH   H5b  H  e   d   H             A    HOHH   HA     H  H   H         HP  h   g       @    HEH4H   H4@     H  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  H  H   H  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  H  m   l   HcLE8   D9AD9HLH4H   H4A      H  H   H     HcHcHH   Hi  HHcHcHH   Hi  HH  H   H     
Hl  H   H_  HcHHc8   HcHH   Hi  HHcH8   8         Hk  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5u  v   Au   A=    A=    MDNI   NA   &   H  H   H  H5  0H  H   H  H  H   H      &   H  H   H     H  H   Hv  Hw  H   Hj  .Hf  H   HY  .     H"  H5T     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5     A   A=    A=    MDNI   NA   &   H  H   H  HL4  (Hw  H   Hj  Hk  H   H^  H_  H   HR      F  H=  H  HP   HO[  H(  H   H  HQ    H=[  H  HX   H[  1H         HL  Hx     A   A    A    MENI   NA$   9   Hk  H   H^  H      H     H             @    HEH4H   H4@   ^  H  H   H  Hd*  H=}        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH  H   Hr      H           @   HLH4H   H4@   W   H,  H   H  HH  H   H     \H  H   H      H        HDD9AD9HLH4H   H4A   {  H        9A9HEH4H   H4A     H        HcLA8      A   HOH4H   H4A     H  H   H  H        HcLA8       A    HOH4H   H4A   9   1H  H   H  HI  jH|  H   Ho      H^           @   HLH4H   H4@   W   H)  H   H  HbH  H   H     \H  H   H  H  H   H  H  H   H  H  H   H     4H  H   H  H  H   H  H  H   Hv      :  H=  H  H`   HCU  HL  H   H?  H DL    H=<  H  Hh   HT  H        HcLA^  HcLA?     A   HNHH   HA     H        HcLA?      A    HOH4H   H4A   ~   HD  H   H7  HcH?     HcHcHHH   Hi  HUHcH?  ?    H>        HcLA^      A    HOH4H   H4A   ~   H  H   Ht  HcH^     HcHcHH?  Hi  HUHcH^  ^     H  H   H  H  H   H  H  H   H  ~  H"        HcLA?      A    HDH4H   H4A     H  H   H      H        HcLE^  D9AD9HLH4H   H4A     H2  H   H%  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  Hc  H   HV     H@  H   H3  HH  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   Hw  H   Hj  MHHcf  H^  Hf     f  EH,  H   H      H           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   HT        HcL   A   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   2   H  H   H  H           H        HcL   A   HDH4H   H4A9  H6        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4A   H        HcL
   A
   HDH4H   H4AR   HO        HcL   A   HDH4H   H4A   I   H  H   H  HNH64   H|  H   Ho  H      H   HP  H   HC  HD  H   H7  H8  H   H+     ?H  H   H      <  H=  H  Hp   HEJ  H  H   H  H C    H=E  H  Hx   HI     H  H   H{  H    HZ        HDD9AD9HLH4H   H4A   2  H	        9A9HEH4H   H4A     H  H   H      H        HcLE8   D9AD9HLH4H   H4A     HC        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1H  H   H  H+:   o  H        HcLE8   D9AD9HDH4H   H4A      H  H   H      H        HcLE8   D9AD9HLH4H   H4A   ?   H9  H   H,  H-  H   H      dH
  H   H  ?   H  H   H  H  H   H     H  H   H  H  H   H  H  H   H     }1H  H   H  H08        H=(  Hm  H   HE  Hx        H      H   HcLALAHDHH   HA   #   H  H   H       H  H   H  HcHtp   tpH7        H=  HR  H   HD  1H;  H   H.  H         H6      3  H=  H  H   H<D  H        H             A    HEHH   HA   x   Hw  H   Hj  H   H	     H   H5  1H  H   H  H`5        H=X  H  H   HB  H  H   H      H      HDD9AD9HLH4H   H4A     H9      9A9HEH4H   H4A   &  H  H   H  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    H   H   H  H  H   H     H  H   H        H=  H?  H   H@  H  H   H      H"      HcLE8   D9AD9HLH4H   H4A      H      HcLcLI   Mi  MA   A   HDH4H   H4A   p   HT      9A9HEH4H   H4A   %   H  H   H  ?   Ht  H   Hg  Hh  H   H[     H      @HOH4H   H4@   5     H  H   H  H0     H0      H         @   HLH4H   H4@   a         He  H   HX  H~  HA  H   H4     RH  H   H     U   H  H   H  2   H=  H5  D=  H5  H   H5  H  H  H   H  H H;E   H(	  []   )v)hmyw     UHH0H  H   Ht  }HuHf        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       H  H   H   E  }Hu  H5        =   A=   HLHH   HA       H  H   H  E*  HE   }M  HO        AM9A9ILLI   LA       HT  H   HG  E   1H:  H   H-  HE      }HuM`  Hu   }EM   M)Hu   Hu      H  H   H  H  H   H  H  H   H  E    H  H   H  EH0]@ UHH  H   H  }HuH  H   H  MMHEHEHcUHuD]UHH H  H   H  }      EEMHHHUHuh  H  HMHcHH=  H  H   HG9  H  H   H  E    G  H=`  H  H   H9  H  H   H  E     H=$  H  H   H8  H  H   H  E     H=  HQ  H    H8  Hl  H   H_  E     H=  H  H(   HW8  H8  H   H+  E    W  H=p  H  H0   H8  H  H   H  E     H=4  H  H8   H7  H  H   H  E     H=  Ha  H@   H7  H  H   H  E     H=  H%  HH   Hg7  Hh  H   H[  E   g  H=  H  HP   H+7  H4  H   H'  E   +  H=D  H  HX   H6  H   H   H  E     H=  Hq  H`   H6  H  H   H  E     H=  H5  Hh   Hw6  H  H   H  E   w  H=  H  Hp   H;6  Hd  H   HW  E   ;  H=T  H  Hx   H5  H0  H   H#  E     H=  H  H   H5  H  H   H  E     H=  HE  H   H5  H  H   H  E     H=  H	  H   HK5  H  H   H  E   K  H=d  H  H   H5  H`  H   HS  E     H=(  H  H   H4  H,  H   H  E     H=  HU  H   H4  H  H   H  E     H=  H  H   H[4  H  H   H  E   [  H=t  H  H   H4  H  H   H  E     H=8  H  H   H3  H\  H   HO  E      H=  He  H   H3  H(  H   H  E      H=  H)  H   Hk3  H  H   H  E   k   H=  H  H   H/3  H  H   H  E   /   H=H  H5  2  H5  H   H5  EH  H   Ht  EH ] ]M=y-iYI9u@ UHH0Ha  H   HT  UHu}MEEHMHMUUuu}HuH        A=   A=   ILLI   LA       H  H   H  E   H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  HQ  H   HD  HE  H   H8  HcEHMTTE    H  H   H  EH0]fffff.     UHHH  H   H  H}H  H   H  HEHEH}   HcHM8   H]    UHH  H   H  H}H  H   Hx  HEHEHM   ]fff.     UHHu  H   Hh  u}HUH_  H   HR  MMUUHEHEE    E    H!        MHc}LEE?  D9AD9HLH4H   H4A      H        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   Hr  Hs  H   Hf  M   MHV  H   HI  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   Hx  M   MHh  H   H[  E    H        MHc}LEE^  D9AD9HLH4H   H4A      Hq        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MHz  H   Hm  E]UHH0Hq  H   Hd  H}Ha  H   HT  HEHEH}EE    H*        MHc}LEE8   D9AD9HLH4H   H4A      H  H   H  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HHf  H   HY  M   MH        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   H  H   H  M   HE   "   H  H   H  HE       H  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    H        M   @   HLH4H   H4@   O   H  H   H  HE   HuEH  H   H  M   Mg1H  H   H  HE   Hu1EH0]@ UHH  H   Hx  H}Hm        H}H}LEAH    A    HDH4H   H4A       H.  H   H!  E     H  H   H	  E    E    H        M   @   HLH4H   H4@      H        Hc}LEAL    A    HDH4H   H4A       H~  H   Hq  M   MHf  H   HY  HZ  H   HM  M   M	H        M   @   HMH4H   H4@       H  H   H  E      H  H   H  E    H  H   H  E]fD  UHH@H  H   H  }HuH  H   H  MMHEHEE    E    Hv        MHc}LEE8   D9AD9HLH4H   H4A     H"        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H*  H   H  M   MHz        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H}  H~  H   Hq  M   M+Ha  H   HT  E    H        MHc}LEE^  D9AD9HLH4H   H4A     H2        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       HB  H   H5  M   MH"  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       Hb  H   HU  M   MH  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H  H   Hs  M}HUM
   MMHR  H   HE  HF  H   H9  M   M+H)  H   H  E    H  1   0   MHc}LEE^  D9AD9HLH4H   H4A     HB  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       Hz  H   Hm  M   MH  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH2  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H*  H   H  M   MH"  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1HH  H   H;  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  EH@]ff.     UHH0H  H   H  H}HuH  H   H  HEHEHMHME    H        M   @   HLH4H   H4@      H@        MH}DD9AD9HMH4H   H4A   (   H%  H   H  HcEHM+   H  H   H  }HuHcuHMH  H   H  H  H   H  M   MH  H   H  E    E    HG        M   @   HLH4H   H4@      H        Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH
  H   H  H  H   H  M   M
H  H   H  HcEHMUH}-EE    H        M   @   HLH4H   H4@      H        Hc}LEADMD9AD9HDH4H   H4A   m   H        M}9A9HOH4H   H4A   (   H  H   H  HcEHM   H  H   H  H  H   H  M   MH  H   H  E    E    H        M   @   HLH4H   H4@      Ho         Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH  H   H  H   H   H  M   M
H  H   H  HcEHMUE    H  &   %   M   @   HLH4H   H4@      HP  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   HG  H   H:  HcEHM   #   H'  H   H  HcEHM    H  H   H  H   H   H  M   M1H  H   H  H0]D  UHH   H  H HEHp  H   Hc  HHW  H   HJ  HHH       H           @   HLH4H   H4@     H        HcLA?     A   HLH4H   H4A   ,   H  H   H}  H[H#H=v  HcH8      HcHcLI   Hi  IA Vt  H        A   A   IDLI   LA   Hl  
   	      @   HDH4H   H4@M   H$           @   HDH4H   H4@   +   H?  H   H2     \   H  H   H  Hc HcH8   8      H  H   H  3H  H   H  H#               @    HMH4H   H4@      Hh  H   H[     Hc HcH^     ^  HcHcLI?  Hi  IA   "1H  H   H  H.   Hg~  HH;U   1H   ]
q  @ UHHu  H   Hh  HUu}MHT        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   H  H   H  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  H        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   H;  H   H.  HcEHM8   8   \  H        Hc}LEA8      A   HDH4H   H4A   5   H  H   H  HcEHM8   8      H  H   H  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   H  H   H  1H  H   H  ]     UHH0Hq  H   Hd  H}uH^  H   HQ  HEHEMMH}REE    H!        M   @   HLH4H   H4@   H   H  H   H  }HuEH  H   H  M   Mn1H  H   H  }uHU1EH0]@ UHH0H  H   H|  H}uHv  H   Hi  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPH  H   Ht  MUuH}DEHEHEMMUUuu}}H}H=3     A   AEE=   A=   MDNI   NA   7   H  H   H  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   H  H   H  HE      HE   <   1Hh  H   H[  }uHU1}uHUEEH6  H   H)     H%  H   H  }uHUQ1EHP]@ UHHPH!  H   H  UuH}MHEHEMMUUuuH}H=     A   AEE    E=   A=   MONI   NAJ   H        M    @    HLH4H   H4@       Hl  H   H_  E  H$        M}9A9HDH4H   H4A       H  H   H  E{  H  H   H  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  HP        M}9A9HEH4H   H4A      H        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MdH        M}9A9HLH4H   H4A       H{  H   Hn  E_  Hc  H   HV  MHcEHULLE    Hu        MH}DD9AD9HLH4H   H4A      H*        M}9A9HEH4H   H4A   E   1H  H   H  HcEHcMHuH   Hi  H<HuM:EH  H   H  H  H   Hw  M   M1He  H   HX  }uHUYE    EH8  "   !   M}9A9HLH4H   H4A     H  H   H  E    H  %   $   MHc}LEE8   D9AD9HLH4H   H4A      H  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      H<  H   H/  }uHUE9   H  H   H  H  H   H   M   MH  H   H  H  H   H  M   M'H  H   H  E    H  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=Qe  H5e  VPH  1H5e  /AVUM=M  	   H5z  Q     H5ee  [H1AVM     H5z  mQ     H5>e  1AVL     H5z  >Q     H5e  VI1AVL  a   H5z  Q     H5d  ;|1AVL     H5}  P     H5d  ] t1AVRL     H5}  P     H5d  T1AV#L     H5W~  P     H5d  w1AVK     H5~  SP     H5fd  YAr1AVK     H5~  $P  	   H5@d  j1AVK     H5b~  O  
   H5d  a'Hr1AVgK     H5K~  O     H5c  @1AV8K     H5~  O     H5c  -1AV	K     H5~  hO     H5c  "mw1AVJ     H5  9O     H5c  |1AVJ  G   H5  
O     H5fc  b1AV|J  .   H5  N     H5Bc  W71AVMJ     H5  N     H5c  `1AVJ  :   H5"  }N     H5b  eW1AVI    H5  NN     H5b  Qw1AVI     H5  N     H5b  :/T1AVI     H5  M     H5b  r%1AVbI     H5  M     H5eb  Ba1AV3I     H5w  M     H5Eb  PR1AVI     H5  cM     H5!b  Ce&1AVH     H5  4M     H5 b  #e,1AVH  /   H5  M     H5a  Ql1AVwH  
   H5;  L  P  Y  H]fD  UHHv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Htu      Hu      Hu      Hu      Hu      Hw      Hw      Hw      Hlw      HYw      HFw      H3w      H w      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Huv      Hbv      HOv      H<v      H)v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      H~u      Hku      HXu      HEu      H2u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Htt      Hat      HNt      H;t      H(t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      H}s      Hjs      HWs      HDs      H1s      Hs      Hs      Hr      Hu      Hu      Hu      Hu      Hu      Hu      H{u      Hhu      HUu      HBu      H/u      Hu      H	u      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hqt      H^t      HKt      H8t      H%t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      H*u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hlt      HYt      HFt      H3t      H t      Ht      Hs      Hs      Hs      Hs      Ht      Ht      Ht      Ht      Ht      Hwt      Hdt      HQt      H>t      H+t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Ht      Ht      Hut      Hbt      HOt      H<t      H)t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Ht      Hs      H t      Hs      Hs      Hs      Ht      Ht      Ht      Ht      Hpt      H]t      HJt      H7t      H$t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hys      Hfs      HSs      H@s      H-s      Hs      Hs      Hr      Hr      Hs      Hs      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hms      HZs      HGs      H4s      H!s      Hs      Hr      Hs      Hs      Hs      Hs      Hs      Hs      H~s      Hks      HXs      HEs      H2s      Hs      Hs      Hr      Hr      Hr      Hr      H=u      H*u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hlt      HYt      HFt      H3t      H t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hus      Hbs      HOs      H<s      H)s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      H~r      Hkr      HXr      HEr      H2r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Htq      Haq      HNq      H;q      H(q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hr      Hr      Hr      H|r      Hir      HVr      HCr      Hs      Hs      Hs      Hs      Hs      Hs      Hns      H[s      HHs      H5s      H"s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hwr      Hdr      HQr      H>r      H+r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hmq      HZq      HGq      H4q      H!q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      H^r      HKr      H8r      H%r      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hzq      Hgq      HTq      Hs      H~s      Hks      HXs      HEs      H2s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Htr      Har      HNr      H;r      H(r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      H}q      Hjq      HWq      HDq      H1q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hsp      H`p      HMp      H:p      H'p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      H|o      Hio      HVo      Hs      H s      Hr      Hr      Hr      Hr      Hr      Hr      H{r      Hhr      HUr      HBr      H/r      Hr      H	r      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hqq      H^q      HKq      H8q      H%q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hzp      Hgp      HTp      HAp      H.p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hpo      H]o      HJo      H7o      H$o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hyn      Hfn      HSr      H@r      H-r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hoq      H\q      HIq      H6q      H#q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hxp      Hep      HRp      H?p      H,p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hno      H[o      HHo      H5o      H"o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hwn      Hdn      HQn      H>n      H+n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hq      Hq      Hmq      HZq      HGq      H4q      H!q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hvp      Hcp      HPp      H=p      H*p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hlo      HYo      HFo      H3o      H o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hun      Hbn      HOn      H<n      H)n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H~m      Hkm      HXm      HEm      H2m      Hm      Hm      Hl      Hl      Hp      Hp      Hp      Hp      Hp      Htp      Hap      HNp      H;p      H(p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      H}o      Hjo      HWo      HDo      H1o      Ho      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hsn      H`n      HMn      H:n      H'n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H|m      Him      HVm      HCm      H0m      Hm      H
m      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hrl      H_l      HLl      H9l      H&l      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hsn      H`n      HMn      H:n      H'n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H|m      Him      HVm      HCm      H0m      Hm      H
m      Hl      Hl      Hl      H&n      Hn      H n      Hm      Hm      Hm      Hm      Hm      Hm      H{m      Hhm      HUm      HBm      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hwm      Hdm      HQm      H>m      H+m      Hm      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hmm      HZm      HGm      H4m      H!m      Hm      Hl      Hl      Hl      Hl      Hm      Hm      Hm      Hm      Hm      Hm      Hum      Hbm      HOm      H<m      H)m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      H~l      Hkl      H@m      H-m      Hm      Hm      Hl      Hl      Hl      Hm      Hl      Hmn      HZn      HGn      H4n      H!n      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hvm      Hcm      HPm      H=m      H*m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hll      HYl      HFl      H3l      H l      Hl      Hk      Hk      Hk      Hk      Hk      Hk      Hk      Huk      Hbk      HOk      H<k      H)k      Hk      Hk      Hl      Hl      Hl      Hl      Htl      Hal      HNl      H;l      H(l      Hl      ] UHH=H58  ]UHH`g  HF  H HEH l  H   Hl  1E    9  9  H=C=  HL;  (   HuEJ  E   E    HHHT9  H p9  HHu1Af  DIHLHLHL9  }UHHDHEE  H,k        =   AAAALcI    AI    HEH<H   H<A      H=>  H5N<  )   HN<  7  Hj  H   Hj  HHu1f  HHH8  }UHHCHEE$  H=j        =   AAAALcI    AI    HEH<H   H<A      H==  H5_;  -   H};  6  Hi  H   Hi  HHu1f  HHH&7  }UHH-BHEE  HNi  
   	   =   AAAALcI    AI    HEH<H   H<A      H=<  H5p:  1   H:  6  H.i  H   H!i  H=:  Hi  H   Hi   c6  H=C  H?H;}   1H`g  ]5  D  UHAVSH@Hni  H   Hai  H}H=:  HEHEE    HM   U 5  1HcMH}8   uHM   uHcMH}H   Hi  H   LEUME[Lh     A   ALc]H]B8   U9A9MDOI   OAE   j   Hh        H}   DED9AD9HDH4H   H4A      HXh  H   HKh  E   Hh        M    @    HEH4H   H4@   *   H=n9  Hh  H   Hg   d4  E%   H=S9  Hg  H   Hg   :4  EH=A9  Hg  H   Hg  uHcEHM8   MHED    3  MEH@[A^]UHAVSHPH~g  H   Hqg  H}H=9  Hgg  H   HZg  HEHEE    HM   U 3  HcMH}8   UHcMH}?  UHcMH}?     UEHf        M    @    HMH4H   H4@      Hf  H   Hf  HcEHcMHUHH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHM?  ?  H7f  H   H*f  MMH=7  HcEHM^  HcEHM?   2  1HcMH}H   Hi  H   LEUME^WLe     A   ALc]H]B8   U9A9MDOI   OAE      Hpe  H   Hce  E   He  
   	   M    @    HEH4H   H4@   *   H=6  He  H   He   1  E%   H=5  Hd  H   Hd   0  EH=6  Hd  H   Hd  uHcEHM8    0  UEHP[A^]fffff.     UHH0H!c  H   Hc  H}H=4  H
c  H   Hb  HEHEE    HM   U &0  E    EHb        M   @   HLH4H   H4@   z   Hb  H   Hb  HcEHM^     ^  HcHcMH}H?  Hi  H   HJb  H   H=b  M   M<1H+b  H   Hb  HcMHUH   Hi  H   LETE    EHa        MH}Df  D9AD9HLH4H   H4A      H]a  
   	   Hc}LEA^     A   HDH4H   H4A      H^a  H   HQa  E   HKa  H   H>a  H?a  H   H2a  M   MH`        M    @    HEH4H   H4@   *   H=2  H`  H   H`   -  E%   H="2  H`  H   H`   w-  EH`  H   H`  EH0] UHHH=!3  H5/  }@  1H5e3  7AA}UM-     H5A_       H533  1A}     H5_  ]     H53  u$\1A}     H5_  .     H52  \iy[1A}     H5$`      (  H]ffffff.     UHH^      H^      H^      H^      H^      H^      Hr^      H_^      HL^      H9^      H&^      H^      H ^      H]      H^      H^      H^      H^      H^      H^      Hp^      H]^      HJ^      H7^      H$^      H^      H]      H]      H]      H]      H]      H]      H]      Hq^      H^^      HK^      H8^      H%^      H^      H]      H]      H]      H]      H]      Hp^      H]^      HJ^      H7^      H$^      H^      H]      H]      H]      H]      H]      H]      H]      Hy]      ]    UHH=eH5^I(  ]UHH]  H   H]  H]          L9  HE  HEG  Lcn]  OHELHUHHHi  LcL]  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   He8  H]  H   H\  HMHc\  H2   H58  H\  H   H\  HMHHc\  H**  H7  H\  H   H\  Hc_\  H*^(]UHH@H\  H   Ht\  H}1Ho\  H   Hb\  HEHEHEm HE  [     [  M  H}  M[  E   H
\        M   @   HLH4H   H4@   K  H[        m L6  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   HJ6  H3[  H   H%[  HMHcUH/   H6  H[  H   H [  HMHHcUHHZ  H   HZ  HZ  H   HZ  M   MkHZ  H   HZ  H@]fUHHHq[  H   Hd[  }HZ[        MM}   =Y  =Y      A    HDH4H   H4A   n   HZ        Y      @    HEH4H   H4@   !   [HZ  H   HZ  HZ  H   HZ  H]    UHH0HY  H   HY  H}HY        H}H}E LEI    AI    HOH4H   H4A   )   HAY  H   H3Y  HEHHHUHY        H}H    AH    HLH4H   H4A   .   1HX  H   HX  $  1HHUHX        H}H    AH    HDH4H   H4A     HX  H   HzX  H+X     
   } @@@HEH4H   H4@   "  H=)   !#  H=)  HuE #  1H5W  1   A   ALUL9AL9MLJ<H   J<AEU   "   HW  H   HW  H}MEHGW        $EE< A< HEH<H   H<A%   H=(  HW  H   HtW   )"  EHkW  H   H^W  HZW  H   HMW  H1  HGW  H   H9W  HMHcU  HH0]@ UHHW  H   HW  H}H=1  HW  H   HV  HMHMHcU  HHUH]fff.     UHH0HW  H   HW  1HW  H   HV  E %   +HE    HV        H}H'  AH'  HLH4H   H4A   E   HV  H   HV  EHV  H   H|V  HEH   HEnH}   H}Z$EY   H}1H=U        M    A    HEH4H   H4AE   "   HU  H   HU  H}Y  MEHU  
   	   $EE< A< HEH<H   H<A   *   H=G&  HU  H   H~U   c  E%   H=J&  HiU  H   H\U   9  EHSU  H   HFU  H0]     UHHH=A&  H5R!  M_   1H5&  hnAM_UM     H5R  L     H5P&  8I1AM_     H5R       H5,&   1AM_     H5#S       H5&  r~61AM_`     H5S       H5%  XH1AM_1     H5S       H5%  
1AM_     H5S  a  <  g  H]UHHR      HQ      HQ      HQ      HQ      HQ      HR      HR      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HoQ      H\Q      HQR      H>R      H+R      HR      HR      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HmQ      HZQ      HGQ      H4Q      H!Q      HQ      HP      HP      HP      HzQ      HgQ      HQ      HQ      H~Q      HkQ      HXQ      HEQ      H2Q      HQ      HQ      HQ      HQ      HQ      HpQ      H]Q      HJQ      H7Q      H$Q      HQ      HP      HP      HP      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH=
$    HH=$    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IHz  IK|&I  HHHL  AD./tB3/IHLLL  EL<$H)P  *P      1H  }1  tL5!     O  H=O      1  G1  L5w!  uhH-O  H]fffff.     Ht/u   HE  /H=O      1@  0         =0  L  HRO  HOO      HLO      HIO      "O  u&1     HHO  HO        1   Hl  H=N  f  H%O  HtfD10  1      E1Hf  HHN  H     8H %  HH-~N  q  HH5!  1HH  cN  HhN      HeN      H-fN  1H  t)H H  1H  HH)N  H-*N  1   H  M  H-N  tbHEH;M  vrH  H  HH  HM  H-M  HM  M  adcgHM  HCHM  t?+adcgHM  HHM  1gHM  adcgH~M  HCHsM  HSH;^M  v8H  H  H=?M  H  H0M  H1M  H2M  M  HM  A74HM  HCHM  t?HKH;L  v2H  H  H=L  H  HL  HL  HL  HL  D,HL  H[A\A]A^A_]  8H	#  HH-gL  Z  HH5  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=K   1  T$D$K  u?HK  HCH;K  v+H  H  H=K  H  HK  HK  HK  HK     HK  L{L=K  MtLY  Hl(UK  tfHCH;^K     H  H  H=;K  H  H,K  H-K  H.K  K  ,HK  HCHK  u\HJ  B,8HJ  HHJ  HJ  D$HJ  HHJ     HJ  B,8HJ  HCHJ  HKH;J  vVH  H  H=}J  H=  HnJ  HoJ  HpJ  IJ  D$H^J  HCHSJ  u^H5J  D$H:J  HCH/J  HKH;J  v2H  H  H=I  H  HI  HI  HI  HI  T$H-I  H]HI  EtjI  u?HEH;I  v2H  H  H=I  HM  H~I  H-I  HI  HiI  $HlI  HHaI  My  L&  HH I  uKHCAH;%I  v>H  H  H=I  H  HH  HH  D=H  HH  E1HH  ,H-H  HH-H  L  IAtALHH;H  v2H H  H=H  HL  H}H  H~H  H-H  H-hH  HLL  H-cH  LH-YH  L'  H   H)H  u?L4+L;5&H  v2I I  H=H  L  HG  L5G  H-G  H-G  1HHn  HG  H[A\A]A^A_]     UAWAVAUATSPIAH=G      L%G  |G     L%G  ID$H;yG  }  I  I  H=VG  L  HGG  L%HG  HIG  "G    H4G  HCH)G  C,6E1  ;  H[A\A]A^A_]HF  B#ID$HF  E1       BL#Il$H-F    D9  DH  IEtvAN1AtH+HH-F  I   tOHILAVp)f.     Ht+H-LF  HqH4+H}H=9F  H1HHHuL%F  B#  HF  HHF  C,6jHE  B   HE  HCHE  C,6HKE1H;E  v5H  H  H=E  Hd  HE  HE  E1HE  H}E  ,HE  HHxE  E  M   Lff.     I] H] I] %E  u@L%9E  ID$H;%E  v+I  I  H=E  L  HD  L%D  HD  HD  HHD  HIAu   fff.     Im D  u?HCH;D  v2H  H  H=D  HF  HwD  HxD  HyD  HbD  H,HgD  HH\D  IAuLH[A\A]A^A_]  H  H8HD  H5  H  H8HC  H5  1H[A\A]A^A_]N  fffff.     SH=C     HC  C  tzHC  HCH;C     H  H  H=C  HK  H|C  H}C  H~C  WC     HiC  HKH^C       oH7C  HCH9C        LHCHC  	l  DHKHC     HB     HB  HKHB  HCH;B    H  H  H=B  Hi  HB  HB  HB  uB  	   HB  HKH|B     uS       HXB     HJB  HH?B  H(B  
	   H*B  HHB  HB  
    H
B  HHA  HA  
    HA  HHA  HA  
HA  HHA  HA      HA  HHA  HA      HA  HHA  HlA      HnA  HHcA  HLA      HNA  HHCA  H,A      H.A  HH#A  HA      HA  HHA  H@     H@  HH@  H@      H@  [H@  	   H@  HKH@  HCH;@  vbH  H  H=y@  H9
  Hj@  Hk@  Hl@  E@      HW@  HKHL@     ? H%@      H'@  HKH@  HCH;	@     H  H  H=?  H	  H?  H?  H?  ?      H?  HKH?     ZH  H8Hp?  H5  H  H8HV?  H5  1[  HX?      HZ?  HKHO?  HCH;<?  v]H  H  H=?  H  H?  H?  H?  >     H>  HCH>  $ H>     H>  HCH>  HKH;>  v[H  H  H=>  HS  H>  H>  H>  `>      Hr>  HCHg>   HF>      HH>  HCH=>  HKH;*>  v]H  H  H=>  H  H=  H=  H=  =      H=  HCH=  R H=      H=  HCH=  HKH;=  v]H  H  H==  HA  Hr=  Hs=  Ht=  M=      H_=  HCHT=   H2=      H4=  HCH)=  HKH;=  v]H  H  H=<  H  H<  H<  H<  <      H<  HCH<  ~ H<      H<  HCH<  HKH;<  v]H  H  H=m<  H-  H^<  H_<  H`<  9<      HK<  HCH@<   H<      H <  HCH<  HKH;<  vZH  H  H=;  H  H;  H;  H;  ;      H;  HCH;  u%H;      H;  HCH;  HKH;{;  v]H  H  H=\;  H  HM;  HN;  HO;  (;     H:;  HCH/;  C H;     H;  HCH;  HKH;:  H  H  H=:  H  H:  H:  H:  @ AVSPH=:   N  :  uIH:  HKH;~:  v5H  H  H=_:  H  HP:  HQ:  3:  1HH:  H1:  H
    H52:  HH5':  H=:  tH9     {  H=9  ]  sH5&:       u4
  8HI  L0H9    HH5  1LH  H=9  H59  @  H9      H9      H=k9    =       HK9      HH9      H=)9  H[A^  ffff.     SH     HH@    H=9   tH9  HAH9  [H
9  H8  [f     SH8  fD  1H[Hu[Pffff.     HGH8    H=8  HuH8      H8      Xfff.     SH     HH@    H=o8   tHn8  HAHc8  [HZ8  HK8  [f     SH88  fD  1H[Hu[Pffff.     HGH8  F  H=7  HuH7      H7      Xfff.     AVSPIHHtA     HH@    H=7   tH7  HAH7  H7  Hp7  MtA      L0H@    H=^7   tH]7  HAHR7  HI7  H:7  D7  tH[A^17  H=1   H=.%   H=H[A^   %`  %b  %d  %f  %h  %j  %l  %n  %p  %r  %t  %v  %x  %z  %|  %~  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %    L  AS%  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h~  h  h  h  h  h                    	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for great hall card effect
===================
      cardtest3.c handActionIncrease(&state)==1 emptyDeck(&state)==1 discard(&state)==1 All tests successful!

 	Test that Great Hall card discard is correct.
 	Test succeeds. Great hall present in discard.
 	##TEST FAIL## Great hall not present in final discard.
 	Test that hand increase is correct.
 	Test passed.  	##TEST FAILED##.  Target handcount: %d, Actual: %d; target action count = %d, Actual: %d
 	Test that empty deck will reshuffle for great hall.
 	Discard count: %d, Deck count: %d Target handcount: %d, Actual: %d
         /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest3.gcda      main discard      handActionIncrease emptyDeck    
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           4       4          !    `  L   L        L        X         ` P     W   `      P    p  0     a           zR x         zR x         zR x         zR x  <      `       ABB B(B0A8A@         \                  <   |   h       ABB B(B0A8A@      <      @       ABB B(B0A8A@            ,	       A  $     s       BAA      D  HG        A     d  x        A       xD        A         G        A               A       D        A    $             BAA                                                                                                       "    ,    6    @    J    T    ^    h    r    |                                           0             x&    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &     '    '    '    '     '    ('    0'    8'    @'    H'    P'    `(    h(    p(    x(    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (     )                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `#A`1@___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time     _  _mh_execute_header c n kingdomCards i s d updateCoins play hand buyCard g whoseTurn fullDeckCount e main Random P SelectStream GetSeed TestRandom     ompare ardEffect    ewGame umHandCards      nitializeGame sGameOver    huffle upplyCount coreFor  9  rawCard iscard  C  K  Card A S GreatHall  Q  Card ActionIncrease  W  X      et ainCard  Cost Winners            ndTurn mptyDeck          dventurer mbassador    Card     mithy teward                    lantSeeds utSeed                  P	mP`P	P
H  ` 	 P PP P           d           M   d           X   f W       .  `        $  `        $   P         N  P         .          $          $   P          N  P          .           $           $   @         N  @         .  @        $  @        $            N           .          $          $            N           .  !        $  !        $            N           .  %        $  %        $             N            .  (        $  (        $            N           .  +       $  +        $             N            .  0,       $  0,        $   6         N  6         .  c       $  c        $   p         N  p         .  e     &  $  e        $   P          N  P          .  e     3  $  e        $   p         N  p         .  @m     <  $  @m        $            N           .   p     F  $   p        $   `          N  `          .  p     T  $  p        $   P          N  P          .  p     _  $  p        $            N           .  t     n  $  t        $   p         N  p         .   x     w  $   x        $   P         N  P         .  pz       $  pz        $   0         N  0         .         $          $            N           .          $           $            N           .         $          $             N            .         $          $             N            .          $           $             N            .         $          $            N           .         $          $            N           .         $          $   P          N  P          .         $          $   0         N  0         .       ,  $          $   $         N  $         .        ?  $           $             N         Q  &  @    i  &         &        &        &        &  8      &  H      &  `    
  &  p      &      .  &      @  &       R  &  (     d  &  8     w  &  P       &   !      &  0!      &  !      &  @"      &  $      &  %      &  p&      &  @(    "  &  @1    5  &  1    H  &   2    [  &  2    n  &  `3      &  3      &  3      &  05       d             d             d             f W       .  @       $  @        $            N           .       "  $          $   P         N  P         .  `     6  $  `        $   `         N  `         .       A  $          $   0         N  0         .       J  $          $             N            .       `  $          $            N           .       s  $          $             N           &  5      &  5      &  6      &  6       d             d             d             f 
W       .       '  $          $   p         N  p         .       /  $          $   0         N  0         .  @     ;  $  @        $            N           .  P     I  $  P        $   0         N  0         .       R  $          $   `          N  `          .       [  $          $   P         N  P         .  0     g  $  0        $   P         N  P         .       }  $          $            N           .  0       $  0        $             N           &        &  `7      &  d7      &  p7      &  7      &   8      &  8      &  8      &   9       d          (         P         f         y                                         0                  0         P         @     =    `     V         k                      `                                	    p    	        >	        N	    @    f	         	        	        	        	        	        	    8    	    H    	    `    
    p    #
        5
        G
         Y
    (     k
    8     ~
    P     
     !    
    0!    
    !    
    @"    
    $    
    %        p&        @(    )    @1    <    1    O     2    b    2    u    `3        3        3        05        5        5        6        6        `7        d7         p7    1    7    C     8    U    8    g    8    y     9        p9        x9        9        9        9        9        9        9        9        9        9    1    9    <         E         Q    P     Z         b    @     p         |              c         0,         `                           !         `         t         p         @m         e                       $    +     .    @     >     x     J          X    @     ^         g     p     u                       (                                     pz                  e         %         p                                         (            ;            F            N            T            \            d            k            r            {                                                                                                                                                                                                                                                                                    j  k  l  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~                            m  n       @j  k  l  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~                              /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 cardtest3.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest3.o _main _handActionIncrease _emptyDeck _discard ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _compare _discard _discardCard _drawCard _emptyDeck _endTurn _fullDeckCount _gainCard _getCost _getWinners _handActionIncrease _handCard _initializeGame _isGameOver _kingdomCards _main _newGame _numHandCards _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder File 'dominion.c'
Lines executed:0.00% of 653
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
    #####:   12:    return -1;
    #####:   13:  return 0;
    #####:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
    #####:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
    #####:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
    #####:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
    #####:  215:    card = floor(Random() * state->deckCount[player]);
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
    #####:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
    #####:  226:  }
        -:  227:
    #####:  228:  return 0;
    #####:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  298:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  299:    state->numBuys--;
        -:  300:    if (DEBUG)
        -:  301:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  302:  }
        -:  303:
        -:  304:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  305:  //state->discardCount[who]++;
        -:  306:    
    #####:  307:  return 0;
    #####:  308:}
        -:  309:
        -:  310:int numHandCards(struct gameState *state) {
    #####:  311:  return state->handCount[ whoseTurn(state) ];
        -:  312:}
        -:  313:
        -:  314:int handCard(int handPos, struct gameState *state) {
    #####:  315:  int currentPlayer = whoseTurn(state);
    #####:  316:  return state->hand[currentPlayer][handPos];
        -:  317:}
        -:  318:
        -:  319:int supplyCount(int card, struct gameState *state) {
    #####:  320:  return state->supplyCount[card];
        -:  321:}
        -:  322:
        -:  323:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  324:  int i;
    #####:  325:  int count = 0;
        -:  326:
    #####:  327:  for (i = 0; i < state->deckCount[player]; i++)
        -:  328:    {
    #####:  329:      if (state->deck[player][i] == card) count++;
    #####:  330:    }
        -:  331:
    #####:  332:  for (i = 0; i < state->handCount[player]; i++)
        -:  333:    {
    #####:  334:      if (state->hand[player][i] == card) count++;
    #####:  335:    }
        -:  336:
    #####:  337:  for (i = 0; i < state->discardCount[player]; i++)
        -:  338:    {
    #####:  339:      if (state->discard[player][i] == card) count++;
    #####:  340:    }
        -:  341:
    #####:  342:  return count;
        -:  343:}
        -:  344:
        -:  345:int whoseTurn(struct gameState *state) {
    #####:  346:  return state->whoseTurn;
        -:  347:}
        -:  348:
        -:  349:int endTurn(struct gameState *state) {
        -:  350:  int k;
        -:  351:  int i;
    #####:  352:  int currentPlayer = whoseTurn(state);
        -:  353:  
        -:  354:  //Discard hand
    #####:  355:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  356:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  357:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  358:  }
    #####:  359:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  360:    
        -:  361:  //Code for determining the player
    #####:  362:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  363:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  364:  }
        -:  365:  else{
    #####:  366:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  367:  }
        -:  368:
    #####:  369:  state->outpostPlayed = 0;
    #####:  370:  state->phase = 0;
    #####:  371:  state->numActions = 1;
    #####:  372:  state->coins = 0;
    #####:  373:  state->numBuys = 1;
    #####:  374:  state->playedCardCount = 0;
    #####:  375:  state->handCount[state->whoseTurn] = 0;
        -:  376:
        -:  377:  //int k; move to top
        -:  378:  //Next player draws hand
    #####:  379:  for (k = 0; k < 5; k++){
    #####:  380:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  381:  }
        -:  382:
        -:  383:  //Update money
    #####:  384:  updateCoins(state->whoseTurn, state , 0);
        -:  385:
    #####:  386:  return 0;
        -:  387:}
        -:  388:
        -:  389:int isGameOver(struct gameState *state) {
        -:  390:  int i;
        -:  391:  int j;
        -:  392:	
        -:  393:  //if stack of Province cards is empty, the game ends
    #####:  394:  if (state->supplyCount[province] == 0)
        -:  395:    {
    #####:  396:      return 1;
        -:  397:    }
        -:  398:
        -:  399:  //if three supply pile are at 0, the game ends
    #####:  400:  j = 0;
    #####:  401:  for (i = 0; i < 25; i++)
        -:  402:    {
    #####:  403:      if (state->supplyCount[i] == 0)
        -:  404:	{
    #####:  405:	  j++;
    #####:  406:	}
    #####:  407:    }
    #####:  408:  if ( j >= 3)
        -:  409:    {
    #####:  410:      return 1;
        -:  411:    }
        -:  412:
    #####:  413:  return 0;
    #####:  414:}
        -:  415:
        -:  416:int scoreFor (int player, struct gameState *state) {
        -:  417:
        -:  418:  int i;
    #####:  419:  int score = 0;
        -:  420:  //score from hand
    #####:  421:  for (i = 0; i < state->handCount[player]; i++)
        -:  422:    {
    #####:  423:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  424:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  425:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  426:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  427:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  428:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  429:    }
        -:  430:
        -:  431:  //score from discard
    #####:  432:  for (i = 0; i < state->discardCount[player]; i++)
        -:  433:    {
    #####:  434:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  435:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  436:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  437:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  438:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  439:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  440:    }
        -:  441:
        -:  442:  //score from deck
    #####:  443:  for (i = 0; i < state->discardCount[player]; i++)
        -:  444:    {
    #####:  445:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  446:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  447:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  448:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  449:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  450:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  451:    }
        -:  452:
    #####:  453:  return score;
        -:  454:}
        -:  455:
        -:  456:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  457:  int i;	
        -:  458:  int j;
        -:  459:  int highScore;
        -:  460:  int currentPlayer;
        -:  461:
        -:  462:  //get score for each player
    #####:  463:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  464:    {
        -:  465:      //set unused player scores to -9999
    #####:  466:      if (i >= state->numPlayers)
        -:  467:	{
    #####:  468:	  players[i] = -9999;
    #####:  469:	}
        -:  470:      else
        -:  471:	{
    #####:  472:	  players[i] = scoreFor (i, state);
        -:  473:	}
    #####:  474:    }
        -:  475:
        -:  476:  //find highest score
    #####:  477:  j = 0;
    #####:  478:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  479:    {
    #####:  480:      if (players[i] > players[j])
        -:  481:	{
    #####:  482:	  j = i;
    #####:  483:	}
    #####:  484:    }
    #####:  485:  highScore = players[j];
        -:  486:
        -:  487:  //add 1 to players who had less turns
    #####:  488:  currentPlayer = whoseTurn(state);
    #####:  489:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  490:    {
    #####:  491:      if ( players[i] == highScore && i > currentPlayer )
        -:  492:	{
    #####:  493:	  players[i]++;
    #####:  494:	}
    #####:  495:    }
        -:  496:
        -:  497:  //find new highest score
    #####:  498:  j = 0;
    #####:  499:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  500:    {
    #####:  501:      if ( players[i] > players[j] )
        -:  502:	{
    #####:  503:	  j = i;
    #####:  504:	}
    #####:  505:    }
    #####:  506:  highScore = players[j];
        -:  507:
        -:  508:  //set winners in array to 1 and rest to 0
    #####:  509:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  510:    {
    #####:  511:      if ( players[i] == highScore )
        -:  512:	{
    #####:  513:	  players[i] = 1;
    #####:  514:	}
        -:  515:      else
        -:  516:	{
    #####:  517:	  players[i] = 0;
        -:  518:	}
    #####:  519:    }
        -:  520:
    #####:  521:  return 0;
        -:  522:}
        -:  523:
        -:  524:int drawCard(int player, struct gameState *state)
        -:  525:{	int count;
        -:  526:  int deckCounter;
    #####:  527:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  528:    
        -:  529:    //Step 1 Shuffle the discard pile back into a deck
        -:  530:    int i;
        -:  531:    //Move discard to deck
    #####:  532:    for (i = 0; i < state->discardCount[player];i++){
    #####:  533:      state->deck[player][i] = state->discard[player][i];
    #####:  534:      state->discard[player][i] = -1;
    #####:  535:    }
        -:  536:
    #####:  537:    state->deckCount[player] = state->discardCount[player];
    #####:  538:    state->discardCount[player] = 0;//Reset discard
        -:  539:
        -:  540:    //Shufffle the deck
    #####:  541:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  542:   
        -:  543:    if (DEBUG){//Debug statements
        -:  544:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  545:    }
        -:  546:    
    #####:  547:    state->discardCount[player] = 0;
        -:  548:
        -:  549:    //Step 2 Draw Card
    #####:  550:    count = state->handCount[player];//Get current player's hand count
        -:  551:    
        -:  552:    if (DEBUG){//Debug statements
        -:  553:      printf("Current hand count: %d\n", count);
        -:  554:    }
        -:  555:    
    #####:  556:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  557:
    #####:  558:    if (deckCounter == 0)
    #####:  559:      return -1;
        -:  560:
    #####:  561:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  562:    state->deckCount[player]--;
    #####:  563:    state->handCount[player]++;//Increment hand count
    #####:  564:  }
        -:  565:
        -:  566:  else{
    #####:  567:    int count = state->handCount[player];//Get current hand count for player
        -:  568:    int deckCounter;
        -:  569:    if (DEBUG){//Debug statements
        -:  570:      printf("Current hand count: %d\n", count);
        -:  571:    }
        -:  572:
    #####:  573:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  574:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  575:    state->deckCount[player]--;
    #####:  576:    state->handCount[player]++;//Increment hand count
        -:  577:  }
        -:  578:
    #####:  579:  return 0;
    #####:  580:}
        -:  581:
        -:  582:int getCost(int cardNumber)
        -:  583:{
    #####:  584:  switch( cardNumber ) 
        -:  585:    {
        -:  586:    case curse:
    #####:  587:      return 0;
        -:  588:    case estate:
    #####:  589:      return 2;
        -:  590:    case duchy:
    #####:  591:      return 5;
        -:  592:    case province:
    #####:  593:      return 8;
        -:  594:    case copper:
    #####:  595:      return 0;
        -:  596:    case silver:
    #####:  597:      return 3;
        -:  598:    case gold:
    #####:  599:      return 6;
        -:  600:    case adventurer:
    #####:  601:      return 6;
        -:  602:    case council_room:
    #####:  603:      return 5;
        -:  604:    case feast:
    #####:  605:      return 4;
        -:  606:    case gardens:
    #####:  607:      return 4;
        -:  608:    case mine:
    #####:  609:      return 5;
        -:  610:    case remodel:
    #####:  611:      return 4;
        -:  612:    case smithy:
    #####:  613:      return 4;
        -:  614:    case village:
    #####:  615:      return 3;
        -:  616:    case baron:
    #####:  617:      return 4;
        -:  618:    case great_hall:
    #####:  619:      return 3;
        -:  620:    case minion:
    #####:  621:      return 5;
        -:  622:    case steward:
    #####:  623:      return 3;
        -:  624:    case tribute:
    #####:  625:      return 5;
        -:  626:    case ambassador:
    #####:  627:      return 3;
        -:  628:    case cutpurse:
    #####:  629:      return 4;
        -:  630:    case embargo: 
    #####:  631:      return 2;
        -:  632:    case outpost:
    #####:  633:      return 5;
        -:  634:    case salvager:
    #####:  635:      return 4;
        -:  636:    case sea_hag:
    #####:  637:      return 4;
        -:  638:    case treasure_map:
    #####:  639:      return 4;
        -:  640:    }
        -:  641:	
    #####:  642:  return -1;
    #####:  643:}
        -:  644:
        -:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int k;
        -:  650:  int x;
        -:  651:  int index;
    #####:  652:  int currentPlayer = whoseTurn(state);
    #####:  653:  int nextPlayer = currentPlayer + 1;
        -:  654:
    #####:  655:  int tributeRevealedCards[2] = {-1, -1};
        -:  656:  int temphand[MAX_HAND];// moved above the if statement
    #####:  657:  int drawntreasure=0;
        -:  658:  int cardDrawn;
    #####:  659:  int z = 0;// this is the counter for the temp hand
    #####:  660:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  661:    nextPlayer = 0;
    #####:  662:  }
        -:  663:  
        -:  664:	
        -:  665:  //uses switch to select card and perform actions
    #####:  666:  switch( card ) 
        -:  667:    {
        -:  668:    case adventurer:
    #####:  669:      return playAdventurer(state, handPos);
        -:  670:			
        -:  671:    case council_room:
        -:  672:      //+4 Cards
    #####:  673:      for (i = 0; i < 4; i++)
        -:  674:	{
    #####:  675:	  drawCard(currentPlayer, state);
    #####:  676:	}
        -:  677:			
        -:  678:      //+1 Buy
    #####:  679:      state->numBuys++;
        -:  680:			
        -:  681:      //Each other player draws a card
    #####:  682:      for (i = 0; i < state->numPlayers; i++)
        -:  683:	{
    #####:  684:	  if ( i != currentPlayer )
        -:  685:	    {
    #####:  686:	      drawCard(i, state);
    #####:  687:	    }
    #####:  688:	}
        -:  689:			
        -:  690:      //put played card in played card pile
    #####:  691:      discardCard(handPos, currentPlayer, state, 0);
        -:  692:			
    #####:  693:      return 0;
        -:  694:			
        -:  695:    case feast:
        -:  696:      //gain card with cost up to 5
        -:  697:      //Backup hand
    #####:  698:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  699:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  700:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  701:      }
        -:  702:      //Backup hand
        -:  703:
        -:  704:      //Update Coins for Buy
    #####:  705:      updateCoins(currentPlayer, state, 5);
    #####:  706:      x = 1;//Condition to loop on
    #####:  707:      while( x == 1) {//Buy one card
    #####:  708:	if (supplyCount(choice1, state) <= 0){
        -:  709:	  if (DEBUG)
        -:  710:	    printf("None of that card left, sorry!\n");
        -:  711:
        -:  712:	  if (DEBUG){
        -:  713:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  714:	  }
    #####:  715:	}
    #####:  716:	else if (state->coins < getCost(choice1)){
    #####:  717:	  printf("That card is too expensive!\n");
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  721:	  }
    #####:  722:	}
        -:  723:	else{
        -:  724:
        -:  725:	  if (DEBUG){
        -:  726:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  727:	  }
        -:  728:
    #####:  729:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  730:	  x = 0;//No more buying cards
        -:  731:
        -:  732:	  if (DEBUG){
        -:  733:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  734:	  }
        -:  735:
        -:  736:	}
        -:  737:      }     
        -:  738:
        -:  739:      //Reset Hand
    #####:  740:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  741:	state->hand[currentPlayer][i] = temphand[i];
    #####:  742:	temphand[i] = -1;
    #####:  743:      }
        -:  744:      //Reset Hand
        -:  745:      			
    #####:  746:      return 0;
        -:  747:			
        -:  748:    case gardens:
    #####:  749:      return -1;
        -:  750:			
        -:  751:    case mine:
    #####:  752:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  753:
    #####:  754:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  755:	{
    #####:  756:	  return -1;
        -:  757:	}
        -:  758:		
    #####:  759:      if (choice2 > treasure_map || choice2 < curse)
        -:  760:	{
    #####:  761:	  return -1;
        -:  762:	}
        -:  763:
    #####:  764:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  765:	{
    #####:  766:	  return -1;
        -:  767:	}
        -:  768:
    #####:  769:      gainCard(choice2, state, 2, currentPlayer);
        -:  770:
        -:  771:      //discard card from hand
    #####:  772:      discardCard(handPos, currentPlayer, state, 0);
        -:  773:
        -:  774:      //discard trashed card
    #####:  775:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  776:	{
    #####:  777:	  if (state->hand[currentPlayer][i] == j)
        -:  778:	    {
    #####:  779:	      discardCard(i, currentPlayer, state, 0);			
    #####:  780:	      break;
        -:  781:	    }
    #####:  782:	}
        -:  783:			
    #####:  784:      return 0;
        -:  785:			
        -:  786:    case remodel:
    #####:  787:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  788:
    #####:  789:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  790:	{
    #####:  791:	  return -1;
        -:  792:	}
        -:  793:
    #####:  794:      gainCard(choice2, state, 0, currentPlayer);
        -:  795:
        -:  796:      //discard card from hand
    #####:  797:      discardCard(handPos, currentPlayer, state, 0);
        -:  798:
        -:  799:      //discard trashed card
    #####:  800:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  801:	{
    #####:  802:	  if (state->hand[currentPlayer][i] == j)
        -:  803:	    {
    #####:  804:	      discardCard(i, currentPlayer, state, 0);			
    #####:  805:	      break;
        -:  806:	    }
    #####:  807:	}
        -:  808:
        -:  809:
    #####:  810:      return 0;
        -:  811:		
        -:  812:    case smithy:
    #####:  813:      return playSmithy(state,handPos);
        -:  814:		
        -:  815:    case village:
        -:  816:      //+1 Card
    #####:  817:      drawCard(currentPlayer, state);
        -:  818:			
        -:  819:      //+2 Actions
    #####:  820:      state->numActions = state->numActions + 2;
        -:  821:			
        -:  822:      //discard played card from hand
    #####:  823:      discardCard(handPos, currentPlayer, state, 0);
    #####:  824:      return 0;
        -:  825:		
        -:  826:    case baron:
    #####:  827:      state->numBuys++;//Increase buys by 1!
    #####:  828:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  829:	int p = 0;//Iterator for hand!
    #####:  830:	int card_not_discarded = 1;//Flag for discard set!
    #####:  831:	while(card_not_discarded){
    #####:  832:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  833:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  834:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  835:	    state->discardCount[currentPlayer]++;
    #####:  836:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  837:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  838:	    }
    #####:  839:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  840:	    state->handCount[currentPlayer]--;
    #####:  841:	    card_not_discarded = 0;//Exit the loop
    #####:  842:	  }
    #####:  843:	  else if (p > state->handCount[currentPlayer]){
        -:  844:	    if(DEBUG) {
        -:  845:	      printf("No estate cards in your hand, invalid choice\n");
        -:  846:	      printf("Must gain an estate if there are any\n");
        -:  847:	    }
    #####:  848:	    if (supplyCount(estate, state) > 0){
    #####:  849:	      gainCard(estate, state, 0, currentPlayer);
    #####:  850:	      state->supplyCount[estate]--;//Decrement estates
    #####:  851:	      if (supplyCount(estate, state) == 0){
    #####:  852:		isGameOver(state);
    #####:  853:	      }
    #####:  854:	    }
    #####:  855:	    card_not_discarded = 0;//Exit the loop
    #####:  856:	  }
        -:  857:			    
        -:  858:	  else{
    #####:  859:	    p++;//Next card
        -:  860:	  }
        -:  861:	}
    #####:  862:      }
        -:  863:			    
        -:  864:      else{
    #####:  865:	if (supplyCount(estate, state) > 0){
    #####:  866:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  867:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  868:	  if (supplyCount(estate, state) == 0){
    #####:  869:	    isGameOver(state);
    #####:  870:	  }
    #####:  871:	}
        -:  872:      }
        -:  873:	    
        -:  874:      
    #####:  875:      return 0;
        -:  876:		
        -:  877:    case great_hall:
    #####:  878:      return playGreatHall(state,handPos);
        -:  879:		
        -:  880:    case minion:
        -:  881:      //+1 action
    #####:  882:      state->numActions++;
        -:  883:			
        -:  884:      //discard card from hand
    #####:  885:      discardCard(handPos, currentPlayer, state, 0);
        -:  886:			
    #####:  887:      if (choice1)		//+2 coins
        -:  888:	{
    #####:  889:	  state->coins = state->coins + 2;
    #####:  890:	}
        -:  891:			
    #####:  892:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  893:	{
        -:  894:	  //discard hand
    #####:  895:	  while(numHandCards(state) > 0)
        -:  896:	    {
    #####:  897:	      discardCard(handPos, currentPlayer, state, 0);
        -:  898:	    }
        -:  899:				
        -:  900:	  //draw 4
    #####:  901:	  for (i = 0; i < 4; i++)
        -:  902:	    {
    #####:  903:	      drawCard(currentPlayer, state);
    #####:  904:	    }
        -:  905:				
        -:  906:	  //other players discard hand and redraw if hand size > 4
    #####:  907:	  for (i = 0; i < state->numPlayers; i++)
        -:  908:	    {
    #####:  909:	      if (i != currentPlayer)
        -:  910:		{
    #####:  911:		  if ( state->handCount[i] > 4 )
        -:  912:		    {
        -:  913:		      //discard hand
    #####:  914:		      while( state->handCount[i] > 0 )
        -:  915:			{
    #####:  916:			  discardCard(handPos, i, state, 0);
        -:  917:			}
        -:  918:							
        -:  919:		      //draw 4
    #####:  920:		      for (j = 0; j < 4; j++)
        -:  921:			{
    #####:  922:			  drawCard(i, state);
    #####:  923:			}
    #####:  924:		    }
    #####:  925:		}
    #####:  926:	    }
        -:  927:				
    #####:  928:	}
    #####:  929:      return 0;
        -:  930:		
        -:  931:    case steward:
    #####:  932:      return playSteward(state,handPos,choice1,choice2,choice3);
        -:  933:
        -:  934:    case tribute:
    #####:  935:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  936:	if (state->deckCount[nextPlayer] > 0){
    #####:  937:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  938:	  state->deckCount[nextPlayer]--;
    #####:  939:	}
    #####:  940:	else if (state->discardCount[nextPlayer] > 0){
    #####:  941:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  942:	  state->discardCount[nextPlayer]--;
    #####:  943:	}
        -:  944:	else{
        -:  945:	  //No Card to Reveal
        -:  946:	  if (DEBUG){
        -:  947:	    printf("No cards to reveal\n");
        -:  948:	  }
        -:  949:	}
    #####:  950:      }
        -:  951:	    
        -:  952:      else{
    #####:  953:	if (state->deckCount[nextPlayer] == 0){
    #####:  954:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  955:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  956:	    state->deckCount[nextPlayer]++;
    #####:  957:	    state->discard[nextPlayer][i] = -1;
    #####:  958:	    state->discardCount[nextPlayer]--;
    #####:  959:	  }
        -:  960:			    
    #####:  961:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  962:	} 
    #####:  963:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  964:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  965:	state->deckCount[nextPlayer]--;
    #####:  966:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  967:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  968:	state->deckCount[nextPlayer]--;
        -:  969:      }    
        -:  970:		       
    #####:  971:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  972:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  973:	state->playedCardCount++;
    #####:  974:	tributeRevealedCards[1] = -1;
    #####:  975:      }
        -:  976:
    #####:  977:      for (i = 0; i <= 2; i ++){
    #####:  978:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  979:	  state->coins += 2;
    #####:  980:	}
        -:  981:		    
    #####:  982:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  983:	  drawCard(currentPlayer, state);
    #####:  984:	  drawCard(currentPlayer, state);
    #####:  985:	}
        -:  986:	else{//Action Card
    #####:  987:	  state->numActions = state->numActions + 2;
        -:  988:	}
    #####:  989:      }
        -:  990:	    
    #####:  991:      return 0;
        -:  992:		
        -:  993:    case ambassador:
    #####:  994:      return playAmbassador(state,handPos,choice1,choice2);
        -:  995:		
        -:  996:    case cutpurse:
        -:  997:
    #####:  998:      updateCoins(currentPlayer, state, 2);
    #####:  999:      for (i = 0; i < state->numPlayers; i++)
        -: 1000:	{
    #####: 1001:	  if (i != currentPlayer)
        -: 1002:	    {
    #####: 1003:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1004:		{
    #####: 1005:		  if (state->hand[i][j] == copper)
        -: 1006:		    {
    #####: 1007:		      discardCard(j, i, state, 0);
    #####: 1008:		      break;
        -: 1009:		    }
    #####: 1010:		  if (j == state->handCount[i])
        -: 1011:		    {
    #####: 1012:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1013:			{
        -: 1014:			  if (DEBUG)
        -: 1015:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1016:			}	
    #####: 1017:		      break;
        -: 1018:		    }		
    #####: 1019:		}
        -: 1020:					
    #####: 1021:	    }
        -: 1022:				
    #####: 1023:	}				
        -: 1024:
        -: 1025:      //discard played card from hand
    #####: 1026:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1027:
    #####: 1028:      return 0;
        -: 1029:
        -: 1030:		
        -: 1031:    case embargo: 
        -: 1032:      //+2 Coins
    #####: 1033:      state->coins = state->coins + 2;
        -: 1034:			
        -: 1035:      //see if selected pile is in play
    #####: 1036:      if ( state->supplyCount[choice1] == -1 )
        -: 1037:	{
    #####: 1038:	  return -1;
        -: 1039:	}
        -: 1040:			
        -: 1041:      //add embargo token to selected supply pile
    #####: 1042:      state->embargoTokens[choice1]++;
        -: 1043:			
        -: 1044:      //trash card
    #####: 1045:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case outpost:
        -: 1049:      //set outpost flag
    #####: 1050:      state->outpostPlayed++;
        -: 1051:			
        -: 1052:      //discard card
    #####: 1053:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case salvager:
        -: 1057:      //+1 buy
    #####: 1058:      state->numBuys++;
        -: 1059:			
    #####: 1060:      if (choice1)
        -: 1061:	{
        -: 1062:	  //gain coins equal to trashed card
    #####: 1063:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1064:	  //trash card
    #####: 1065:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1066:	}
        -: 1067:			
        -: 1068:      //discard card
    #####: 1069:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case sea_hag:
    #####: 1073:      for (i = 0; i < state->numPlayers; i++){
    #####: 1074:	if (i != currentPlayer){
    #####: 1075:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1076:	  state->discardCount[i]++;
    #####: 1077:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1078:	}
    #####: 1079:      }
    #####: 1080:      return 0;
        -: 1081:		
        -: 1082:    case treasure_map:
        -: 1083:      //search hand for another treasure_map
    #####: 1084:      index = -1;
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1086:	{
    #####: 1087:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1088:	    {
    #####: 1089:	      index = i;
    #####: 1090:	      break;
        -: 1091:	    }
    #####: 1092:	}
    #####: 1093:      if (index > -1)
        -: 1094:	{
        -: 1095:	  //trash both treasure cards
    #####: 1096:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1097:	  discardCard(index, currentPlayer, state, 1);
        -: 1098:
        -: 1099:	  //gain 4 Gold cards
    #####: 1100:	  for (i = 0; i < 4; i++)
        -: 1101:	    {
    #####: 1102:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1103:	    }
        -: 1104:				
        -: 1105:	  //return success
    #####: 1106:	  return 1;
        -: 1107:	}
        -: 1108:			
        -: 1109:      //no second treasure_map found in hand
    #####: 1110:      return -1;
        -: 1111:    }
        -: 1112:	
    #####: 1113:  return -1;
    #####: 1114:}
        -: 1115:
        -: 1116:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1117:{
        -: 1118:	
        -: 1119:  //if card is not trashed, added to Played pile 
    #####: 1120:  if (trashFlag < 1)
        -: 1121:    {
        -: 1122:      //add card to played pile
    #####: 1123:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1124:      state->playedCardCount++;
    #####: 1125:    }
        -: 1126:	
        -: 1127:  //set played card to -1
    #####: 1128:  state->hand[currentPlayer][handPos] = -1;
        -: 1129:	
        -: 1130:  //remove card from player's hand
    #####: 1131:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1132:    {
        -: 1133:      //reduce number of cards in hand
    #####: 1134:      state->handCount[currentPlayer]--;
    #####: 1135:    }
    #####: 1136:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1137:    {
        -: 1138:      //reduce number of cards in hand
    #####: 1139:      state->handCount[currentPlayer]--;
    #####: 1140:    }
        -: 1141:  else 	
        -: 1142:    {
        -: 1143:      //replace discarded card with last card in hand
    #####: 1144:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1145:      //set last card to -1
    #####: 1146:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1147:      //reduce number of cards in hand
    #####: 1148:      state->handCount[currentPlayer]--;
        -: 1149:    }
        -: 1150:	
    #####: 1151:  return 0;
        -: 1152:}
        -: 1153:
        -: 1154:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1155:{
        -: 1156:  //Note: supplyPos is enum of choosen card
        -: 1157:	
        -: 1158:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1159:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1160:    {
    #####: 1161:      return -1;
        -: 1162:    }
        -: 1163:	
        -: 1164:  //added card for [whoseTurn] current player:
        -: 1165:  // toFlag = 0 : add to discard
        -: 1166:  // toFlag = 1 : add to deck
        -: 1167:  // toFlag = 2 : add to hand
        -: 1168:
    #####: 1169:  if (toFlag == 1)
        -: 1170:    {
    #####: 1171:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1172:      state->deckCount[player]++;
    #####: 1173:    }
    #####: 1174:  else if (toFlag == 2)
        -: 1175:    {
    #####: 1176:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1177:      state->handCount[player]++;
    #####: 1178:    }
        -: 1179:  else
        -: 1180:    {
    #####: 1181:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1182:      state->discardCount[player]++;
        -: 1183:    }
        -: 1184:	
        -: 1185:  //decrease number in supply pile
    #####: 1186:  state->supplyCount[supplyPos]--;
        -: 1187:	 
    #####: 1188:  return 0;
    #####: 1189:}
        -: 1190:
        -: 1191:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1192:{
        -: 1193:  int i;
        -: 1194:	
        -: 1195:  //reset coin count
    #####: 1196:  state->coins = 0;
        -: 1197:
        -: 1198:  //add coins for each Treasure card in player's hand
    #####: 1199:  for (i = 0; i < state->handCount[player]; i++)
        -: 1200:    {
    #####: 1201:      if (state->hand[player][i] == copper)
        -: 1202:	{
    #####: 1203:	  state->coins += 1;
    #####: 1204:	}
    #####: 1205:      else if (state->hand[player][i] == silver)
        -: 1206:	{
    #####: 1207:	  state->coins += 2;
    #####: 1208:	}
    #####: 1209:      else if (state->hand[player][i] == gold)
        -: 1210:	{
    #####: 1211:	  state->coins += 3;
    #####: 1212:	}	
    #####: 1213:    }	
        -: 1214:
        -: 1215:  //add bonus
    #####: 1216:  state->coins += bonus;
        -: 1217:
    #####: 1218:  return 0;
        -: 1219:}
        -: 1220:
        -: 1221:int playAdventurer(struct gameState *state,int handPos){
    #####: 1222:  int currentPlayer= state->whoseTurn;
    #####: 1223:  int drawntreasure = 0;
        -: 1224:  int cardDrawn;
        -: 1225:  int temphand[MAX_HAND];
        -: 1226:  int z, i;//temphand counter
    #####: 1227:  while(drawntreasure<2){
    #####: 1228:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1229:      shuffle(currentPlayer, state);
    #####: 1230:    }
    #####: 1231:    drawCard(currentPlayer, state);
    #####: 1232:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1233:    printf("Card drawn: %d\n",cardDrawn);
    #####: 1234:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1235:      drawntreasure++;
        -: 1236:    else{
    #####: 1237:      temphand[z]=cardDrawn;
    #####: 1238:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1239:      z++;
        -: 1240:    }
        -: 1241:  }
    #####: 1242:  while(z-1>=0){
    #####: 1243:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1244:    z=z-1;
        -: 1245:  }
    #####: 1246:  discardCard(handPos,currentPlayer,state,0);
    #####: 1247:  return 0;
        -: 1248:}
        -: 1249:
        -: 1250:int playSmithy(struct gameState *state,int handPos){
        -: 1251:      //currentPlayer
    #####: 1252:      int currentPlayer = whoseTurn(state);
        -: 1253:      int i;
        -: 1254:      //+3 Cards
    #####: 1255:      for (i = 0; i < 3; i++)
        -: 1256:      {
    #####: 1257:        drawCard(currentPlayer, state);
    #####: 1258:      }
        -: 1259:      //discard card from hand
    #####: 1260:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1261:      return 0;
        -: 1262:}
        -: 1263:
        -: 1264:int playGreatHall(struct gameState *state, int handPos){
    #####: 1265:      int currentPlayer = whoseTurn(state);
        -: 1266:      //+1 Card
    #####: 1267:      drawCard(currentPlayer, state);
        -: 1268:      
        -: 1269:      //+1 Actions
    #####: 1270:      state->numActions++;
        -: 1271:      
        -: 1272:      //discard card from hand
    #####: 1273:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1274:}
        -: 1275:
        -: 1276:int playAmbassador(struct gameState *state, int handPos, int choice1, int choice2){
    #####: 1277:  int currentPlayer = whoseTurn(state);
    #####: 1278:  int j = 0;    //used to check if player has enough cards to discard
        -: 1279:  int i;
        -: 1280:
    #####: 1281:      if (choice2 > 2 || choice2 < 0)//cannot choose more than 2
        -: 1282:  {
    #####: 1283:    return -1;        
        -: 1284:  }
        -: 1285:
    #####: 1286:      if (choice1 == handPos)//cant choose this ambassador
        -: 1287:  {
    #####: 1288:    return -1;
        -: 1289:  }
        -: 1290:
    #####: 1291:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1292:  {
    #####: 1293:    if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1294:      {
    #####: 1295:        j++;
    #####: 1296:      }
    #####: 1297:  }
    #####: 1298:      if (j < choice2)
        -: 1299:  {
    #####: 1300:    return -1;        
        -: 1301:  }
        -: 1302:
        -: 1303:      if (DEBUG) 
        -: 1304:  printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1305:
        -: 1306:      //increase supply count for choosen card by amount being discarded
    #####: 1307:      state->supplyCount[choice2] += choice2;
        -: 1308:      
        -: 1309:      //each other player gains a copy of revealed card
    #####: 1310:      for (i = 0; i < state->numPlayers; i++)
        -: 1311:  {
    #####: 1312:    if (i != currentPlayer)
        -: 1313:      {
    #####: 1314:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1315:      }
    #####: 1316:  }
        -: 1317:
        -: 1318:      //discard played card from hand
    #####: 1319:      discardCard(handPos, currentPlayer, state, 0);      
        -: 1320:
        -: 1321:      //trash copies of cards returned to supply
    #####: 1322:      for (j = 0; j < choice2; j++)
        -: 1323:  {
    #####: 1324:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1325:      {
    #####: 1326:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1327:    {
    #####: 1328:      discardCard(i, currentPlayer, state, 1);
    #####: 1329:      break;
        -: 1330:    }
    #####: 1331:      }
    #####: 1332:  }     
        -: 1333:
    #####: 1334:      return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:int playSteward(struct gameState *state,int handPos,int choice1,int choice2,int choice3){
    #####: 1338:      int currentPlayer = whoseTurn(state);
    #####: 1339:      if (choice1 == 1)
        -: 1340:  {
        -: 1341:    //+2 cards
    #####: 1342:    drawCard(currentPlayer, state);
    #####: 1343:    drawCard(currentPlayer, state);
    #####: 1344:  }
    #####: 1345:      else if (choice1 == 2)
        -: 1346:  {
        -: 1347:    //+2 coins
    #####: 1348:    state->coins = state->coins + 2;
    #####: 1349:  }
        -: 1350:      else
        -: 1351:  {
        -: 1352:    //trash 2 cards in hand
    #####: 1353:    discardCard(choice2, currentPlayer, state, 0);
    #####: 1354:    discardCard(choice3, currentPlayer, state, 0);
        -: 1355:  }
        -: 1356:      
        -: 1357:      //discard card from hand
    #####: 1358:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1359:      return 0;
        -: 1360:}
        -: 1361:
        -: 1362:
        -: 1363://end of dominion.c
                      H   __PAGEZERO                                                        x  __TEXT                                                  __text          __TEXT          `     j      `                           __stubs         __TEXT                                             __stub_helper   __TEXT              P                                __const         __TEXT              @                                   __cstring       __TEXT                                                 __unwind_info   __TEXT                                                 __eh_frame      __TEXT              p                                     x  __DATA                0                                __got           __DATA                                                  __nl_symbol_ptr __DATA                                    "           __la_symbol_ptr __DATA                                      $           __mod_init_func __DATA                                   	               __const         __DATA          @          @                            __data          __DATA                                                __bss           __DATA                                                     H   __LINKEDIT       @     0             /                    "  0           @           H     "         x%   X? 0     P       D  D  &   j  #                           H> D                             /usr/lib/dyld             P0{$       
  
 *              (     @                 8         
   /usr/lib/libSystem.B.dylib      &      % p   )      x%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     UHH H   Hx H}HuHi       H}H}LELELMA	LMED9AD9HOH4H   H4A       H" H   H E      H       H}H}DD9AD9HLH4H   H4A       H H   H E   H H   H E    H H   H E]ffffff.     UHHHy H   Hl f  Hf H   HX 7  HEHEH]D  UHAWAVSHXE(DU D]]L5& I   L5 ]DMDEMUuEDUD]}(   H H   H EEUUuuDEDEDMDMDUDUD]D]]]DuDuD}D}i  HEUHEUHEPUHEPUHEPUHEPUHEPUHEPUHEPUHEP UHEP$HEHX[A^A_]ffffff.     UHHPH H   H UHu}HM   EEHMHMUUHuHu  Hc}  H       E=   A=   HOH<H   H<AJ   H}       M   @   HLH4H   H4@       H[ H   HN Ej  HC H   H6 MHEE    H       M
   @
   HLH4H   H4@     H H   H E    H    
   M
   @
   HLH4H   H4@      H@       M}9A9HEH4H   H4A   y   H
       Hc}LEAHc}LEED9AD9HDH4H   H4A       H" H   H E  H
 H   H
 H
 H   H
 M   MH
 H   H
 H
 H   H
 M   M!H
       M   @   HDH4H   H4@   $   H~
 H   Hq
 HE@
      H	       M   @   HDH4H   H4@   $   H(
 H   H
 HE@      H
 H   H	 HE@   H	 H   H	 H	       M   @   HDH4H   H4@   :   H	 H   H	 HE@   HE@   HE@   5   H}	 H   Hp	 HE@   HE@   HE@   <   HK	 H   H=	 iU   )HMAHMA(   HMA   E   H #   "   M   @   HNH4H   H4@     H H   H E    H &   %   M
   @
   HLH4H   H4@   <  HR (   '   Hc}LEADMD9AD9HDH4H   H4A     H *   )   Hc}LEA   A   HDH4H   H4AS   H ,   +   Hc}LEA
   A
   HDH4H   H4A      H` .   -   M   @   HDH4H   H4@   )   H H   H HcEHMD   $   Hm H   H` HcEHMD   HQ H   HD $   H@ H   H3 HcEHMD
   H$ H   H ]   H H   H HcEHMDH H   H H H   H M   MzH H   H H H   H M   MH H   H E    H ;   :   M}9A9HLH4H   H4A     H] H   HP HcEHM?      E    HO >   =   M   @   HLH4H   H4@   y   H H   H HcEHcMHUHH   Hi  H   HcEHM?     ?  H H   H M   M=H H   H E   Hq C   B   M
   @
   HLH4H   H4@   y   HG H   H: HcEHcMHUHH   Hi  H   HcEHM?     ?  H H   H M   M=H H   H H H   H M   MH H   H E    HZ J   I   M}9A9HLH4H   H4A      }Hu  H5	 L   K   =    A=    HLHH   HA       H, H   H E  H H   H H H   H M   MH H   H E    HP R   Q   M}9A9HLH4H   H4A   _   H H   H HcEHM8       HcEHM^      Hq H   Hd M   M\HT H   HG E    H  W   V   M   @   HNH4H   H4@   I   H H   H HcEHMDp    H H   H M   MmH H   H HE       HE       HE      HE      HEf      HE       HEHc   HM8       E    Hu  \   [   M   @   HLH4H   H4@   O   H H   H HE   Hu[  EH H   H M   Mg1H H   H HE   Hu	  E    EH H   H EHP] UHH  H  H HEH H   Hs  HH_        HH    LcLG?  A   AA   HLH4H   H4A   #   H  H   H       HH5  H   H5  HcHHH   Hi  HHcLIc?  M  H\        HcLA?      A    HOH4H   H4A     H7  H   H*  -  HcH*?  YW  ,HcHcHHH   Hi  HHc    Hg  	      HcLE?  A   D9AD9HLH4H   H4A      HS  H   HF     HcHcHHH   Hi  HHcHcHHH   Hi  HH  H   H     H  H   H  HcH?  ?  H  H   H      H        9A9HLH4H   H4A      HF  H   H9  Hc HcHcHHH   Hi  HHcH?     ?  H  H   H     H  H   H      H  H  H   H  H H;E   H  ]4  fffff.     UHH@H1 H   H$ }HuH       MMH}H}LcELMG?  A    AA    HNH4H   H4A     H H   H E    H       MHc}LEE^  D9AD9HLH4H   H4A      Hp H   Hc HcEHcMHUH?  Hi  H4HcEHcMHUHH   Hi  H4HcEHcMHUH?  Hi  HH  H   H M   MHcEHM^  HcEHM?  HcEHM^      }HuMHf 	      ALcMLUC^      LcMLUC8   ULcMLUC?  UU    A    IDLI   LAE       H. H   H! El  H H   H	 M   HcHcUHuHH   Hi  HHcEHcUHuH   Hi  HHcEHU?  ?  HcEHU8      8      H H   Hx HcEHM8   UHcEHM?  UU   HcHcMHuHH   Hi  HHcEHcMHuH   Hi  HHcEHM?  ?  HcEHM8      8   H  H   H  E    H  H   H  EH@]fff.     UHHU H   HH Hu}UH? H   H2 MMHEHEUUHu       E    H       MHc}LEE8   D9AD9HLH4H   H4A   !  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   Hn H   Ha HE         Q  H       Hc}LcELMI   Mi  MA   A   HDH4H   H4A   /   H
 H   H
 HE            Hx
    
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A   *   Hp
 H   Hc
 HE         HN
 H   HA
 HB
 H   H5
 H6
 H   H)
 H*
 H   H
 M   M1H
 H   H	 UHM      ]UHAVSHPH>  H   H1  MUu}LEH        MM}}DEDEDMDMLULUE    L]A       A    HEH4H   H4A       H  H   H  E  H}        H}      A   HLH4H   H4A       H\  H   HO  E  }Hu  H5         EE=   A=   HLHH   HAJ   H  
   	   M   @   HOH4H   H4@       H  H   H  E   HE}uUMLEDMH$V  L/     A   A=    =    MLOI   O       HZ  H   HM  EJ   HB  H   H5  HE      HE   HuUAE    EH   H   H  EHP[A^]    UHH Hi  H   H\  }HuHV  H   HI  MMHEHEH}D  EHc}HcUHuH   Hi  HH ]f     UHSH(	  HEL  MLUL  I   L  HDL HHDDLLHC  H=C     A   A   L  L]        LA   99MONI   N      H  H   H      +      H|o4  H4  HHcHH=  H1  H   Hq  H  H   H  H^  =4  H=  H  H   HFq  H  H   H      H           @   HLH4H   H4@   W   Hl  H   H_  HxHH  H   H;     \H%  H   H  H             H  !       HDD9AD9HLH4H   H4A      H  #   "   9A9HEH4H   H4A   ,   Hz  H   Hm  HtHV  H   HI  HJ  H   H=     1H%  H   H  HHa      p1  H=@  H  H   Hn  H  H   H      Hr  *   )   HcLE8   D9AD9HNH4H   H4A      Hm  H   H`  HcHcHH   Hi  H4HcHcHcHH   Hi  HH  H   H         H  H   H  H   lH7  /   .      @   HDH4H   H4@   l  H3  H5  1   0   =    A=    HNHH   HA      H#  H   H     H   h2  H\  4   3   Ah9A9ILLI   LA   -   H=  H  H   H     d>   1H  H   H  H9      `Hc  H   HV  HW  H   HJ  GHF  H   H9      H`  ;   :   HcLE8   D9AD9HNH4H   H4A      H  H   H  HcHcHcHH   Hi  HHcH  H   H     Hk  H   H^      -  H=  H1  H    Hj  H4  H   H'  K-  H=  H  H(   HTj  H  A   @   HcLcLI   Mi  MAHcLcLI   Mi  MA   A   HLHH   HAq   Ha  C   B   HcLcLI   Mi  MA   A   HOH4H   H4A   #   H  H   H  +  H  F   E       @   HOH4H   H4@M   H  H   G        @    HLH4H   H4@   #   H  H   Hs  G+  HcHcHH   Hi  H<~.      \h.  H  K   J   \9A9HOH4H   H4A   #   H  H   H  *     H  H   H   H?5  1HXY      TH  O   N   HcLE8   D9AD9HLH4H   H4A      H  Q   P   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1H  H   H  HX  P?   H  H   H  H  H   H     Hi  H   H\      (  H=2  Hw  H0   He  HcHcHH   Hi  HHcHcHH   Hi  H<+      L+  H5  W   V   AL9A9IOLI   LA   #   H  H   H|  '  1Hl  H   H_   H2  1HHV      DHH  [   Z   HcLE8   D9AD9HLH4H   H4A      H  ]   \   HcLcLI   Mi  MADD9AD9HDH4H   H4A   9   1Hg  H   HZ  HU  @?   H8  H   H+  H,  H   H     H	  H   H      &  H=r  H  H8   Hc  H  H   H  HCX  %  H=%  Hj  H@   Hb  H  H   H  H1H      H   H<T      8,%  H=  H  HH   H5b  H  e   d   H             A    HOHH   HA     H  H   H         HP  h   g       @    HEH4H   H4@     H  j   i   HcLcLI   Mi  MA   A   HDH4H   H4A   '  H  H   H  H         HcHcHH   Hi  HHcHHc^  HcHH?  Hi  HHcH^     ^  H  m   l   HcLE8   D9AD9HLH4H   H4A      H  H   H     HcHcHH   Hi  HHcHcHH   Hi  HH  H   H     
Hl  H   H_  HcHHc8   HcHH   Hi  HHcH8   8         Hk  r   q   HcLE8   D9AD9HOH4H   H4A   =     HD$  H5  t   s   =    A=    HOHH   HA         1H+     HNNH4#  H5u  v   Au   A=    A=    MDNI   NA   &   H  H   H  H5  0H  H   H  H  H   H      &   H  H   H     H  H   Hv  Hw  H   Hj  .Hf  H   HY  .     H"  H5T     ~   =    A=    HOHH   HA         1H)     HNNH,"  H5     A   A=    A=    MDNI   NA   &   H  H   H  HL4  (Hw  H   Hj  Hk  H   H^  H_  H   HR      F  H=  H  HP   HO[  H(  H   H  HQ    H=[  H  HX   H[  1H         HL  Hx     A   A    A    MENI   NA$   9   Hk  H   H^  H      H     H             @    HEH4H   H4@   ^  H  H   H  Hd*  H=}        =    A=    HOH4H   H4A   9   1H  H   H  HK   vH  H   Hr      H           @   HLH4H   H4@   W   H,  H   H  HH  H   H     \H  H   H      H        HDD9AD9HLH4H   H4A   {  H        9A9HEH4H   H4A     H        HcLA8      A   HOH4H   H4A     H  H   H  H        HcLA8       A    HOH4H   H4A   9   1H  H   H  HI  jH|  H   Ho      H^           @   HLH4H   H4@   W   H)  H   H  HbH  H   H     \H  H   H  H  H   H  H  H   H  H  H   H     4H  H   H  H  H   H  H  H   Hv      :  H=  H  H`   HCU  HL  H   H?  H DL    H=<  H  Hh   HT  H        HcLA^  HcLA?     A   HNHH   HA     H        HcLA?      A    HOH4H   H4A   ~   HD  H   H7  HcH?     HcHcHHH   Hi  HUHcH?  ?    H>        HcLA^      A    HOH4H   H4A   ~   H  H   Ht  HcH^     HcHcHH?  Hi  HUHcH^  ^     H  H   H  H  H   H  H  H   H  ~  H"        HcLA?      A    HDH4H   H4A     H  H   H      H        HcLE^  D9AD9HLH4H   H4A     H2  H   H%  HcHcHH?  Hi  H4HcHcHHH   Hi  H4HcH?     ?  HcHcHH?  Hi  HHcH^  ^  Hc  H   HV     H@  H   H3  HH  H   H  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  HcH?     HcHcHHH   Hi  HUHcH?  ?  HcHcHHH   Hi  HHcH?  ?  H        M}9A9HDH4H   H4A   S   Hw  H   Hj  MHHcf  H^  Hf     f  EH,  H   H      H           @   HNH4H   H4@   t  H        HcL   A   HDH4H   H4A   HT        HcL   A   HDH4H   H4AR   H        HcL   A   HDH4H   H4A   2   H  H   H  H           H        HcL   A   HDH4H   H4A9  H6        HcL   A   HDH4H   H4A   H        HcL   A   HDH4H   H4A   H        HcL
   A
   HDH4H   H4AR   HO        HcL   A   HDH4H   H4A   I   H  H   H  HNH64   H|  H   Ho  H      H   HP  H   HC  HD  H   H7  H8  H   H+     ?H  H   H      <  H=  H  Hp   HEJ  H  H   H  H C    H=E  H  Hx   HI     H  H   H{  H    HZ        HDD9AD9HLH4H   H4A   2  H	        9A9HEH4H   H4A     H  H   H      H        HcLE8   D9AD9HLH4H   H4A     HC        HcLcLI   Mi  MA   A   HDH4H   H4A   9   1H  H   H  H+:   o  H        HcLE8   D9AD9HDH4H   H4A      H  H   H      H        HcLE8   D9AD9HLH4H   H4A   ?   H9  H   H,  H-  H   H      dH
  H   H  ?   H  H   H  H  H   H     H  H   H  H  H   H  H  H   H     }1H  H   H  H08        H=(  Hm  H   HE  Hx        H      H   HcLALAHDHH   HA   #   H  H   H       H  H   H  HcHtp   tpH7        H=  HR  H   HD  1H;  H   H.  H         H6      3  H=  H  H   H<D  H        H             A    HEHH   HA   x   Hw  H   Hj  H   H	     H   H5  1H  H   H  H`5        H=X  H  H   HB  H  H   H      H      HDD9AD9HLH4H   H4A     H9      9A9HEH4H   H4A   &  H  H   H  HcH?  ?  HcHcHHH   Hi  HHcHHc^  HcHH?  Hi  HHcH?  ?  HcH^     ^  HcH?  ?  HcHcHHH   Hi  H    H   H   H  H  H   H     H  H   H        H=  H?  H   H@  H  H   H      H"      HcLE8   D9AD9HLH4H   H4A      H      HcLcLI   Mi  MA   A   HDH4H   H4A   p   HT      9A9HEH4H   H4A   %   H  H   H  ?   Ht  H   Hg  Hh  H   H[     H      @HOH4H   H4@   5     H  H   H  H0     H0      H         @   HLH4H   H4@   a         He  H   HX  H~  HA  H   H4     RH  H   H     U   H  H   H  2   H=  H5  D=  H5  H   H5  H  H  H   H  H H;E   H(	  []!   )v)hmyw     UHH0H  H   Ht  }HuHf        MMH}H}LEE   DMLEE   A   AA   HLH4H   H4A       H  H   H   E  }Hu  H5        =   A=   HLHH   HA       H  H   H  E*  HE   }M  HO        AM9A9ILLI   LA       HT  H   HG  E   1H:  H   H-  HE      }HuM`  Hu   }EM   M)Hu   Hu      H  H   H  H  H   H  H  H   H  E    H  H   H  EH0]@ UHH  H   H  }HuH  H   H  MMHEHEHcUHuD]UHH H  H   H  }      EEMHHHUHuh  H  HMHcHH=  H  H   HG9  H  H   H  E    G  H=`  H  H   H9  H  H   H  E     H=$  H  H   H8  H  H   H  E     H=  HQ  H    H8  Hl  H   H_  E     H=  H  H(   HW8  H8  H   H+  E    W  H=p  H  H0   H8  H  H   H  E     H=4  H  H8   H7  H  H   H  E     H=  Ha  H@   H7  H  H   H  E     H=  H%  HH   Hg7  Hh  H   H[  E   g  H=  H  HP   H+7  H4  H   H'  E   +  H=D  H  HX   H6  H   H   H  E     H=  Hq  H`   H6  H  H   H  E     H=  H5  Hh   Hw6  H  H   H  E   w  H=  H  Hp   H;6  Hd  H   HW  E   ;  H=T  H  Hx   H5  H0  H   H#  E     H=  H  H   H5  H  H   H  E     H=  HE  H   H5  H  H   H  E     H=  H	  H   HK5  H  H   H  E   K  H=d  H  H   H5  H`  H   HS  E     H=(  H  H   H4  H,  H   H  E     H=  HU  H   H4  H  H   H  E     H=  H  H   H[4  H  H   H  E   [  H=t  H  H   H4  H  H   H  E     H=8  H  H   H3  H\  H   HO  E      H=  He  H   H3  H(  H   H  E      H=  H)  H   Hk3  H  H   H  E   k   H=  H  H   H/3  H  H   H  E   /   H=H  H5  2  H5  H   H5  EH  H   Ht  EH ] ]M=y-iYI9u@ UHH0Ha  H   HT  UHu}MEEHMHMUUuu}HuH        A=   A=   ILLI   LA       H  H   H  E   H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc?  HcUHuHH   Hi  HHcEHU?     ?  !  H        M   @   HDH4H   H4@   d   H  H   H  MHcEHUHc8   HcUHuH   Hi  HHcEHU8      8   _   H  H   H  MHcEHUHc^  HcUHuH?  Hi  HHcEHU^     ^  HQ  H   HD  HE  H   H8  HcEHMTTE    H  H   H  EH0]fffff.     UHHH  H   H  H}H  H   H  HEHEH}   HcHM8   H]    UHH  H   H  H}H  H   Hx  HEHEHM   ]fff.     UHHu  H   Hh  u}HUH_  H   HR  MMUUHEHEE    E    H!        MHc}LEE?  D9AD9HLH4H   H4A      H        Hc}LcELMIH   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   Hr  Hs  H   Hf  M   MHV  H   HI  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A      H        Hc}LcELMI   Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   Hx  M   MHh  H   H[  E    H        MHc}LEE^  D9AD9HLH4H   H4A      Hq        Hc}LcELMI?  Mi  MADUD9AD9HDH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MHz  H   Hm  E]UHH0Hq  H   Hd  H}Ha  H   HT  HEHEH}EE    H*        MHc}LEE8   D9AD9HLH4H   H4A      H  H   H  HcEHcMHUH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHcMHUH   Hi  HHf  H   HY  M   MH        Hc}LEA8       MH}DA   D9AD9HLH4H   H4A   ,   H  H   H  M   HE   "   H  H   H  HE       H  H   H  HE       HE       HE      HE       HE      HEf      HEHc   HM8       E    H        M   @   HLH4H   H4@   O   H  H   H  HE   HuEH  H   H  M   Mg1H  H   H  HE   Hu1EH0]@ UHH  H   Hx  H}Hm        H}H}LEAH    A    HDH4H   H4A       H.  H   H!  E     H  H   H	  E    E    H        M   @   HLH4H   H4@      H        Hc}LEAL    A    HDH4H   H4A       H~  H   Hq  M   MHf  H   HY  HZ  H   HM  M   M	H        M   @   HMH4H   H4@       H  H   H  E      H  H   H  E    H  H   H  E]fD  UHH@H  H   H  }HuH  H   H  MMHEHEE    E    Hv        MHc}LEE8   D9AD9HLH4H   H4A     H"        Hc}LcELMI   Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       Hz  H   Hm  M   MH     
   Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI   Mi  MA   A   HDH4H   H4A       H*  H   H  M   MHz        Hc}LcELMI   Mi  MA
   A
   HDH4H   H4A   8   1H  H   H  M}HUM
   MMH  H   H}  H~  H   Hq  M   M+Ha  H   HT  E    H        MHc}LEE^  D9AD9HLH4H   H4A     H2        Hc}LcELMI?  Mi  MA    A    HDH4H   H4A       H  H   H  M   MH        Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       HB  H   H5  M   MH"  "   !   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  %   $   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       Hb  H   HU  M   MH  (   '   Hc}LcELMI?  Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  +   *   Hc}LcELMI?  Mi  MA
   A
   HDH4H   H4A   8   1H  H   Hs  M}HUM
   MMHR  H   HE  HF  H   H9  M   M+H)  H   H  E    H  1   0   MHc}LEE^  D9AD9HLH4H   H4A     HB  3   2   Hc}LcELMIH   Mi  MA    A    HDH4H   H4A       Hz  H   Hm  M   MH  6   5   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H
  H   H  M   MH2  9   8   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  <   ;   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H*  H   H  M   MH"  ?   >   Hc}LcELMIH   Mi  MA   A   HDH4H   H4A       H  H   H  M   MH  B   A   Hc}LcELMIH   Mi  MA
   A
   HDH4H   H4A   8   1HH  H   H;  M}HUM
   MMH  H   H  H  H   H  M   M+H  H   H  EH@]ff.     UHH0H  H   H  H}HuH  H   H  HEHEHMHME    H        M   @   HLH4H   H4@      H@        MH}DD9AD9HMH4H   H4A   (   H%  H   H  HcEHM+   H  H   H  }HuHcuHMH  H   H  H  H   H  M   MH  H   H  E    E    HG        M   @   HLH4H   H4@      H        Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH
  H   H  H  H   H  M   M
H  H   H  HcEHMUH}-EE    H        M   @   HLH4H   H4@      H        Hc}LEADMD9AD9HDH4H   H4A   m   H        M}9A9HOH4H   H4A   (   H  H   H  HcEHM   H  H   H  H  H   H  M   MH  H   H  E    E    H        M   @   HLH4H   H4@      Ho         Hc}LEAHc}LEED9AD9HOH4H   H4A      H  H   H  MMH  H   H  H   H   H  M   M
H  H   H  HcEHMUE    H  &   %   M   @   HLH4H   H4@      HP  (   '   Hc}LEADMD9AD9HDH4H   H4A   (   HG  H   H:  HcEHM   #   H'  H   H  HcEHM    H  H   H  H   H   H  M   M1H  H   H  H0]D  UHH   H  H HEHp  H   Hc  HHW  H   HJ  HHH       H           @   HLH4H   H4@     H        HcLA?     A   HLH4H   H4A   ,   H  H   H}  H[H#H=v  HcH8      HcHcLI   Hi  IA ft  H        A   A   IDLI   LA   Hl  
   	      @   HDH4H   H4@M   H$           @   HDH4H   H4@   +   H?  H   H2     \   H  H   H  Hc HcH8   8      H  H   H  3H  H   H  H#               @    HMH4H   H4@      Hh  H   H[     Hc HcH^     ^  HcHcLI?  Hi  IA   "1H  H   H  H.   Hg~  HH;U   1H   ]q  @ UHHu  H   Hh  HUu}MHT        MM}}LELEDMDMDUA   AA   HLH4H   H4A   `   H  H   H  HcEHcMHUH   Hi  H4HEHcf  HM^  HEf     f  H        Hc}LcELMI   Mi  MAMHc}LEE8   A   D9AD9HDH4H   H4A   5   H;  H   H.  HcEHM8   8   \  H        Hc}LEA8      A   HDH4H   H4A   5   H  H   H  HcEHM8   8      H  H   H  HcEHM8      HcHcMHuH   Hi  HHcEHcMHuH   Hi  HHcEHM8      HcHcMHuH   Hi  HHcEHM8   8   H  H   H  1H  H   H  ]     UHH0Hq  H   Hd  H}uH^  H   HQ  HEHEMMH}REE    H!        M   @   HLH4H   H4@   H   H  H   H  }HuEH  H   H  M   Mn1H  H   H  }uHU1EH0]@ UHH0H  H   H|  H}uHv  H   Hi  HEHEMMH}2E}HuS1Hu         }uHUE9MEH0]ff.     UHHPH  H   Ht  MUuH}DEHEHEMMUUuu}}H}H=3     A   AEE=   A=   MDNI   NA   7   H  H   H  }HuM}HuE>E   H        M   @   HDH4H   H4@   3   H  H   H  HE      HE   <   1Hh  H   H[  }uHU1}uHUEEH6  H   H)     H%  H   H  }uHUQ1EHP]@ UHHPH!  H   H  UuH}MHEHEMMUUuuH}H=     A   AEE    E=   A=   MONI   NAJ   H        M    @    HLH4H   H4@       Hl  H   H_  E  H$        M}9A9HDH4H   H4A       H  H   H  E{  H  H   H  E    H     
   MHc}LEE8   D9AD9HLH4H   H4A   H  HP        M}9A9HEH4H   H4A      H        MHc}LcELMI   Mi  MED9AD9HDH4H   H4A   e   H        M}9A9HEH4H   H4A       H  H   H  M   MH  H   H  H  H   H  M   MdH        M}9A9HLH4H   H4A       H{  H   Hn  E_  Hc  H   HV  MHcEHULLE    Hu        MH}DD9AD9HLH4H   H4A      H*        M}9A9HEH4H   H4A   E   1H  H   H  HcEHcMHuH   Hi  H<HuM:EH  H   H  H  H   Hw  M   M1He  H   HX  }uHUYE    EH8  "   !   M}9A9HLH4H   H4A     H  H   H  E    H  %   $   MHc}LEE8   D9AD9HLH4H   H4A      H  '   &   Hc}LcELMI   Mi  MAHc}LcELMI   Mi  MED9AD9HDH4H   H4A   0      H<  H   H/  }uHUE9   H  H   H  H  H   H   M   MH  H   H  H  H   H  M   M'H  H   H  E    H  H   H  EHP]fffff.     UH=HuE1   EHuHH    HU   HEHH   H]D  UHHH=ae  H5e  V`H  1H5e  /AVUMMM  	   H5z  Q     H5ue  [H1AVM     H5z  }Q     H5Ne  1AVL     H5z  NQ     H5,e  VI1AVL  a   H5z  Q     H5e  ;|1AVL     H5}  P     H5d  ] t1AVbL     H5}  P     H5d  T1AV3L     H5W~  P     H5d  w1AVL     H5~  cP     H5vd  YAr1AVK     H5~  4P  	   H5Pd  j1AVK     H5b~  P  
   H5-d  a'Hr1AVwK     H5K~  O     H5d  @1AVHK     H5~  O     H5c  -1AVK     H5~  xO     H5c  "mw1AVJ     H5  IO     H5c  |1AVJ  G   H5  O     H5vc  b1AVJ  .   H5  N     H5Rc  W71AV]J     H5  N     H5,c  `1AV.J  :   H5"  N     H5c  eW1AVI    H5  ^N     H5b  Qw1AVI     H5  /N     H5b  :/T1AVI     H5   N     H5b  r%1AVrI     H5  M     H5ub  Ba1AVCI     H5w  M     H5Ub  PR1AVI     H5  sM     H51b  Ce&1AVH     H5  DM     H5b  #e,1AVH  /   H5  M     H5a  Ql1AVH  
   H5;  L  P  Y  H]fD  UHHv      Hu      Hu      Hu      Hu      Hu      Hu      Hu      Htu      Hu      Hu      Hu      Hu      Hw      Hw      Hw      Hlw      HYw      HFw      H3w      H w      Hw      Hv      Hv      Hv      Hv      Hv      Hv      Hv      Huv      Hbv      HOv      H<v      H)v      Hv      Hv      Hu      Hu      Hu      Hu      Hu      Hu      H~u      Hku      HXu      HEu      H2u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Htt      Hat      HNt      H;t      H(t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      H}s      Hjs      HWs      HDs      H1s      Hs      Hs      Hr      Hu      Hu      Hu      Hu      Hu      Hu      H{u      Hhu      HUu      HBu      H/u      Hu      H	u      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hqt      H^t      HKt      H8t      H%t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      H*u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hlt      HYt      HFt      H3t      H t      Ht      Hs      Hs      Hs      Hs      Ht      Ht      Ht      Ht      Ht      Hwt      Hdt      HQt      H>t      H+t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Ht      Ht      Hut      Hbt      HOt      H<t      H)t      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Ht      Hs      H t      Hs      Hs      Hs      Ht      Ht      Ht      Ht      Hpt      H]t      HJt      H7t      H$t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hys      Hfs      HSs      H@s      H-s      Hs      Hs      Hr      Hr      Hs      Hs      Ht      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hms      HZs      HGs      H4s      H!s      Hs      Hr      Hs      Hs      Hs      Hs      Hs      Hs      H~s      Hks      HXs      HEs      H2s      Hs      Hs      Hr      Hr      Hr      Hr      H=u      H*u      Hu      Hu      Ht      Ht      Ht      Ht      Ht      Ht      Ht      Hlt      HYt      HFt      H3t      H t      Ht      Hs      Hs      Hs      Hs      Hs      Hs      Hs      Hus      Hbs      HOs      H<s      H)s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      H~r      Hkr      HXr      HEr      H2r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Htq      Haq      HNq      H;q      H(q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hr      Hr      Hr      H|r      Hir      HVr      HCr      Hs      Hs      Hs      Hs      Hs      Hs      Hns      H[s      HHs      H5s      H"s      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Hwr      Hdr      HQr      H>r      H+r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hmq      HZq      HGq      H4q      H!q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      H^r      HKr      H8r      H%r      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hzq      Hgq      HTq      Hs      H~s      Hks      HXs      HEs      H2s      Hs      Hs      Hr      Hr      Hr      Hr      Hr      Hr      Hr      Htr      Har      HNr      H;r      H(r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      H}q      Hjq      HWq      HDq      H1q      Hq      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hsp      H`p      HMp      H:p      H'p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      H|o      Hio      HVo      Hs      H s      Hr      Hr      Hr      Hr      Hr      Hr      H{r      Hhr      HUr      HBr      H/r      Hr      H	r      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hqq      H^q      HKq      H8q      H%q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hzp      Hgp      HTp      HAp      H.p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hpo      H]o      HJo      H7o      H$o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hyn      Hfn      HSr      H@r      H-r      Hr      Hr      Hq      Hq      Hq      Hq      Hq      Hq      Hq      Hoq      H\q      HIq      H6q      H#q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hxp      Hep      HRp      H?p      H,p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hno      H[o      HHo      H5o      H"o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hwn      Hdn      HQn      H>n      H+n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hq      Hq      Hmq      HZq      HGq      H4q      H!q      Hq      Hp      Hp      Hp      Hp      Hp      Hp      Hp      Hvp      Hcp      HPp      H=p      H*p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      Ho      Hlo      HYo      HFo      H3o      H o      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hun      Hbn      HOn      H<n      H)n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H~m      Hkm      HXm      HEm      H2m      Hm      Hm      Hl      Hl      Hp      Hp      Hp      Hp      Hp      Htp      Hap      HNp      H;p      H(p      Hp      Hp      Ho      Ho      Ho      Ho      Ho      Ho      H}o      Hjo      HWo      HDo      H1o      Ho      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hsn      H`n      HMn      H:n      H'n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H|m      Him      HVm      HCm      H0m      Hm      H
m      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hrl      H_l      HLl      H9l      H&l      Ho      Hn      Hn      Hn      Hn      Hn      Hn      Hn      Hsn      H`n      HMn      H:n      H'n      Hn      Hn      Hm      Hm      Hm      Hm      Hm      Hm      H|m      Him      HVm      HCm      H0m      Hm      H
m      Hl      Hl      Hl      H&n      Hn      H n      Hm      Hm      Hm      Hm      Hm      Hm      H{m      Hhm      HUm      HBm      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hwm      Hdm      HQm      H>m      H+m      Hm      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hmm      HZm      HGm      H4m      H!m      Hm      Hl      Hl      Hl      Hl      Hm      Hm      Hm      Hm      Hm      Hm      Hum      Hbm      HOm      H<m      H)m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      H~l      Hkl      H@m      H-m      Hm      Hm      Hl      Hl      Hl      Hm      Hl      Hmn      HZn      HGn      H4n      H!n      Hn      Hm      Hm      Hm      Hm      Hm      Hm      Hm      Hvm      Hcm      HPm      H=m      H*m      Hm      Hm      Hl      Hl      Hl      Hl      Hl      Hl      Hl      Hll      HYl      HFl      H3l      H l      Hl      Hk      Hk      Hk      Hk      Hk      Hk      Hk      Huk      Hbk      HOk      H<k      H)k      Hk      Hk      Hl      Hl      Hl      Hl      Htl      Hal      HNl      H;l      H(l      Hl      ] UHH=H58  ]UHH`g  HF  H HEH l  H   Hl  1E    :  9  H=S=  H\;  (   HuEJ  E   E    HHHd9  H 9  HHu1Af  DIHLHLHL9  }UHHDHEE  H,k        =   AAAALcI    AI    HEH<H   H<A      H=]<  H5[<  )   H[<  7  Hj  H   Hj  HHu1f  HHH%8  }UHHCHEE4  H=j        =   AAAALcI    AI    HEH<H   H<A      H=n;  H5l;  -   H;  7  Hi  H   Hi  HHu1f  HHH67  }UHH-BHEE  HNi  
   	   =   AAAALcI    AI    HEH<H   H<A      H=:  H5}:  1   H:  6  H.i  H   H!i  H=:  Hi  H   Hi   s6  H=C  H?H;}   1H`g  ]5  D  UHAVSH@Hni  H   Hai  H}H=:  HEHEE    HM   U 5  1HcMH}8   uHM      uHcMH}H   Hi  H   LEUME[Lh     A   ALc]H]B8   U9A9MDOI   OAE   j   Hyh        H}   DED9AD9HDH4H   H4A      HRh  H   HEh  E   Hh        M    @    HEH4H   H4@   *   H=l9  Hg  H   Hg   n4  E%   H=Q9  Hg  H   Hg   D4  EH=?9  Hg  H   Hg  uHcEHM8   MHED    3  MEH@[A^]f.     UHAVSHPHng  H   Hag  H}H=9  HWg  H   HJg  HEHEE    HM   U 3  HcMH}8   UHcMH}?  UHcMH}?     UEHf        M    @    HMH4H   H4@      Hf  H   Hf  HcEHcMHUHH   Hi  H4HcEHM^  AA   D^  HcHcMHUH?  Hi  H4HcEHM?  ?  H'f  H   Hf  MMH=7  HcEHM^  HcEHM?   2  1HcMH}H   Hi  H   LEUMENWLwe     A   ALc]H]B8   U9A9MDOI   OAE      H`e  H   HSe  E   He  
   	   M    @    HEH4H   H4@   *   H=6  He  H   Hd   1  E%   H=5  Hd  H   Hd   0  EH=s6  Hd  H   Hd  uHcEHM8    0  UEHP[A^]fffff.     UHH0Hc  H   Hc  H}H=4  Hb  H   Hb  HEHEE    HM   U &0  E    EHb        M   @   HLH4H   H4@   z   Hb  H   Hzb  HcEHM^     ^  HcHcMH}H?  Hi  H   H:b  H   H-b  M   M<1Hb  H   Hb  HcMHUH   Hi  H   LE}TE    EHa        MH}Df  D9AD9HLH4H   H4A      HMa  
   	   Hc}LEA^     A   HDH4H   H4A      HNa  H   HAa  E   H;a  H   H.a  H/a  H   H"a  M   MH`        M    @    HEH4H   H4@   *   H=2  H`  H   H`   -  E%   H=2  H`  H   H`   w-  EH`  H   H`  EH0] UHHH=3  H5/  }@  1H50  7AA}UM-     H51_       H5#3  1A}     H5r_  ]     H53  u$\1A}     H5_  .     H52  \iy[1A}     H5`      (  H]ffffff.     UHH^      H^      H^      H^      H^      Hu^      Hb^      HO^      H<^      H)^      H^      H^      H]      H]      H^      H^      H^      H^      H^      Hs^      H`^      HM^      H:^      H'^      H^      H^      H]      H]      H]      H]      H]      H]      H|]      Ha^      HN^      H;^      H(^      H^      H^      H]      H]      H]      H]      H]      H`^      HM^      H:^      H'^      H^      H^      H]      H]      H]      H]      H]      H]      H|]      Hi]      ]    UHH=eH5^I(  ]UHH]  H   H]  H]          L8  HE  HEG  Lc^]  OHELHUHHHi  Lc<]  OLHUHHHiG  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   0   HU8  H\  H   H\  HMHc\  H2   H%8  H\  H   H\  HMHHc~\  H**  H7  H\  H   H\  HcO\  H*^(]UHH@Hq\  H   Hd\  H}1H_\  H   HR\  HEHEHEm HE  [     [  M  H}  M[  E   H[        M   @   HLH4H   H4@   K  H[        m L6  M   LcOHELHUHHHiY  M   LcOLHUHHHi  H}H)H}HEH=    AH=    HEHOHuH<H   H<A   -   H:6  H#[  H   H[  HMHcUH/   H6  HZ  H   HZ  HMHHcUHHZ  H   HZ  HZ  H   HZ  M   MkHZ  H   HZ  H@]fUHHHa[  H   HT[  }HJ[        MM}   =Y  =Y      A    HDH4H   H4A   n   HZ        tY      @    HEH4H   H4@   !   [HZ  H   HZ  HZ  H   HZ  H]    UHH0HY  H   HY  H}HyY        H}H}E LEI    AI    HOH4H   H4A   )   H1Y  H   H#Y  HEHHHUHX        H}H    AH    HLH4H   H4A   .   1HX  H   HX  $  1HHUH|X        H}H    AH    HDH4H   H4A     HwX  H   HjX  HX     
   } @@@HEH4H   H4@   "  H=)   !#  H=)  HuE #  1H5W  1   A   ALUL9AL9MLJ<H   J<AEU   "   HW  H   HW  H}MEH7W        $EE< A< HEH<H   H<A%   H=(  HqW  H   HdW   )"  EH[W  H   HNW  HJW  H   H=W  H~1  H7W  H   H)W  HMHcU  HH0]@ UHHW  H   H W  H}H-1  HV  H   HV  HMHMHcU  HHUH]fff.     UHH0HW  H   HV  1HV  H   HV  E %   +HE    HV        H}H'  AH'  HLH4H   H4A   E   HV  H   HV  EHyV  H   HlV  HEH   HEnH}   H}Z$EY   H}1H=U        M    A    HEH4H   H4AE   "   HU  H   HU  H}Y  MEHvU  
   	   $EE< A< HEH<H   H<A   *   H=7&  H{U  H   HnU   c  E%   H=:&  HYU  H   HLU   9  EHCU  H   H6U  H0]     UHHH=1&  H5R!  M_   1H5p&  hnAM_UM     H5R  L     H5@&  8I1AM_     H5R       H5&   1AM_     H5S       H5%  r~61AM_`     H5S       H5%  XH1AM_1     H5uS       H5%  
1AM_     H5S  a  <  g  H]UHHQ      HQ      HQ      HQ      HQ      HQ      H
R      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HrQ      H_Q      HLQ      HAR      H.R      HR      HR      HQ      HQ      HQ      HQ      HQ      HQ      HQ      HpQ      H]Q      HJQ      H7Q      H$Q      HQ      HP      HP      HP      HP      HjQ      HWQ      HQ      HQ      HnQ      H[Q      HHQ      H5Q      H"Q      HQ      HQ      HQ      HQ      HsQ      H`Q      HMQ      H:Q      H'Q      HQ      HQ      HP      HP      HP      ]fD  UHH=H5>  ]UAWAVAUATSPAIIH=#    HH=#    HtA}  t;HtHL<$H7  ~<E1MAUt#I/u9M|L  HnM
L<$EML  IHz  IK|&I  HHHL  AD./tB3/IHLLL  EL<$HP  P      1H  m1  tL5!     O  H=O      1  71  L5g!  uhH-O  H]fffff.     Ht/u   HE  /H=sO      1@  0         =0  L  HBO  H?O      H<O      H9O      O  u&1     HHO  HO        1   Hl  H=N  f  HO  HtfD!0  1      E1Hf  HHN  H     8H%  HH-nN  q  HH5!  1HH  SN  HXN      HUN      H-VN  1H  t)H H  1H  HHN  H-N  1   H  M  H-N  tbHEH;M  vrH  H  HH  HM  H-M  HM  M  adcgHM  HCHM  t?+adcgHM  HHM  1gH|M  adcgHnM  HCHcM  HSH;NM  v8H  H  H=/M  H  H M  H!M  H"M  L  HM  A74HM  HCHL  t?HKH;L  v2H  H  H=L  H  HL  HL  HL  HL  D,HL  H[A\A]A^A_]  8H"  HH-WL  Z  HH5  1HHH[A\A]A^A_]  ffff.     H9tHHtH     UAWAVAUATSPAIAEH=K   1  T$D$K  u?HK  HCH;K  v+H  H  H=K  H  HK  HK  HK  HK     HK  L{L=K  MtLY  Hl(EK  tfHCH;NK     H  H  H=+K  H  HK  HK  HK  J  ,HK  HCHK  u\HJ  B,8HJ  HHJ  HJ  D$HJ  HHJ     HJ  B,8HJ  HCHJ  HKH;J  vVH  H  H=mJ  H=  H^J  H_J  H`J  9J  D$HNJ  HCHCJ  u^H%J  D$H*J  HCHJ  HKH;J  v2H  H  H=I  H  HI  HI  HI  HI  T$H-I  H]HI  EtjI  u?HEH;I  v2H  H  H=}I  HM  HnI  H-oI  HpI  HYI  $H\I  HHQI  My  L&  HHI  uKHCAH;I  v>H  H  H=H  H  HH  HH  D=H  HH  E1HH  ,H-H  HH-H  L  IAtALHH;H  v2H H  H=|H  HL  HmH  HnH  H-oH  H-XH  HLL  H-SH  LH-IH  L'  H   H)H  u?L4+L;5H  v2I I  H=G  L  HG  L5G  H-G  H-G  1HHn  HG  H[A\A]A^A_]     UAWAVAUATSPIAH=G      L%G  lG     L%}G  ID$H;iG  }  I  I  H=FG  L  H7G  L%8G  H9G  G    H$G  HCHG  C,6E1  ;  H[A\A]A^A_]HF  B#ID$HF  E1       BL#Il$H-F    D9  DH  IEtvAN1AtH+HH-pF  I   tOHILAVp)f.     Ht+H-<F  HqH4+H}H=)F  H1HHHuL%F  B#  HE  HHE  C,6jHE  B   HE  HCHE  C,6HKE1H;E  v5H  H  H=E  Hd  HE  HE  E1HE  HmE  ,HsE  HHhE  E  M   Lff.     I] H] I] E  u@L%)E  ID$H;E  v+I  I  H=D  L  HD  L%D  HD  HD  HHD  HIAu   fff.     Im D  u?HCH;D  v2H  H  H=vD  HF  HgD  HhD  HiD  HRD  H,HWD  HHLD  IAuLH[A\A]A^A_]  H  H8HC  H5  H|  H8HC  H5  1H[A\A]A^A_]N  fffff.     SH=C     HC  C  tzHC  HCH;C     H  H  H={C  HK  HlC  HmC  HnC  GC     HYC  HKHNC       oH'C  HCH)C        LHCHC  	l  DHKHB     HB     HB  HKHB  HCH;B    H  H  H=B  Hi  HB  HB  HB  eB  	   HwB  HKHlB     uS       HHB     H:B  HH/B  HB  
	   HB  HHB  HA  
    HA  HHA  HA  
    HA  HHA  HA  
HA  HHA  HA      HA  HHA  H|A      H~A  HHsA  H\A      H^A  HHSA  H<A      H>A  HH3A  HA      HA  HHA  H@      H@  HH@  H@     H@  HH@  H@      H@  [H@  	   H@  HKH@  HCH;@  vbH  H  H=i@  H9
  HZ@  H[@  H\@  5@      HG@  HKH<@     ? H@      H@  HKH@  HCH;?     H  H  H=?  H	  H?  H?  H?  ?      H?  HKH?     ZH  H8H`?  H5  H  H8HF?  H5  1[  HH?      HJ?  HKH??  HCH;,?  v]H  H  H=?  H  H>  H>  H ?  >     H>  HCH>  $ H>     H>  HCH>  HKH;>  v[H  H  H=>  HS  Ht>  Hu>  Hv>  P>      Hb>  HCHW>   H6>      H8>  HCH->  HKH;>  v]H  H  H==  H  H=  H=  H=  =      H=  HCH=  R H=      H=  HCH=  HKH;=  v]H  H  H=q=  HA  Hb=  Hc=  Hd=  ==      HO=  HCHD=   H"=      H$=  HCH=  HKH;=  v]H  H  H=<  H  H<  H<  H<  <      H<  HCH<  ~ H<      H<  HCH<  HKH;|<  v]H  H  H=]<  H-  HN<  HO<  HP<  )<      H;<  HCH0<   H<      H<  HCH<  HKH;;  vZH  H  H=;  H  H;  H;  H;  ;      H;  HCH;  u%H;      H;  HCH~;  HKH;k;  v]H  H  H=L;  H  H=;  H>;  H?;  ;     H*;  HCH;  C H:     H:  HCH:  HKH;:  H  H  H=:  H  H:  H:  H:  @ AVSPH=:   N  o:  uIH:  HKH;n:  v5H  H  H=O:  H  H@:  HA:  #:  1H8:  H!:  H
    H5":  HH5:  H= :  tH9     {  H=9  ]  sH5:       u4
  8H9  L0H9    HH5  1LH  H=9  H59  @  Hu9      H9      H=[9    =       H;9      H89      H=9  H[A^  ffff.     SH     HH@    H=9   tH9  HAH9  [H8  H8  [f     SH8  fD  1H[Hu[Pffff.     HGH8    H=8  HuH8      H~8      Xfff.     SH     HH@    H=_8   tH^8  HAHS8  [HJ8  H;8  [f     SH(8  fD  1H[Hu[Pffff.     HGH7  F  H=7  HuH7      H7      Xfff.     AVSPIHHtA     HH@    H=7   tH7  HAHx7  Ho7  H`7  MtA      L0H@    H=N7   tHM7  HAHB7  H97  H*7  47  tH[A^!7  H=1   H=.%   H=H[A^   %P  %R  %T  %V  %X  %Z  %\  %^  %`  %b  %d  %f  %h  %j  %l  %n  %p  %r  %t  %v  %x  %z  %|  %~  %  %  %  %  %  %  %  %    L  AS%u  h    h   h#   h;   hI   hU   hc   hq   h~   h   h   h   xh   nh   dh   Zh   Ph   Fh   <h  2h  (h'  h5  hD  
hQ   h`  hn  h~  h  h  h  h  h                    	   
                       AThat card is too expensive!
 Card drawn: %d
    /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.gcda *204 compare newGame kingdomCards initializeGame shuffle playCard buyCard numHandCards handCard supplyCount fullDeckCount whoseTurn endTurn isGameOver scoreFor getWinners drawCard getCost cardEffect discardCard gainCard updateCoins playAdventurer playSmithy playGreatHall playAmbassador playSteward              Test for village card effect
===================
 main cardtest4.c handActionIncrease(&state)==1 emptyDeck(&state)==1 discard(&state)==1 All tests successful!

 	Test that Village card discard is correct.
 	Test succeeds. Village present in discard.
 	##TEST FAIL## Village not present in final discard.
 	Test that hand increase is correct.
 	Test passed.  	##TEST FAILED##.  Target handcount: %d, Actual: %d; target action count = %d, Actual: %d
 	Test that empty deck will reshuffle for village.
 	Discard count: %d, Deck count: %d Target handcount: %d, Actual: %d
        /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest4.gcda           discard      handActionIncrease emptyDeck    
Enter a positive integer seed (9 digits or less) >>  %ld 
Input out of range ... try again
 
 The implementation of rngs.c is correct.

 
 ERROR -- the implementation of rngs.c is not correct.

            /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.gcda      Random PlantSeeds PutSeed GetSeed SelectStream TestRandom r+b w+b profiling: %s: cannot open: %s
 profiling: %s: cannot merge previous GCDA file: corrupt arc tag (0x%08x)
 profiling: %s: cannot merge previous GCDA file: mismatched number of counters (%d)
 profiling: %s: cannot merge previous run count: corrupt object tag (0x%08x)
 profiling: %s: cannot merge previous run count: mismatched object length (%d)
 GCOV_PREFIX GCOV_PREFIX_STRIP profiling: %s: cannot map: %s
 profiling: %s: cannot msync: %s
           4       4          !    `  L   L        L        X         ` P     W   p      `     @     a           zR x         zR x         zR x         zR x  <      p       ABB B(B0A8A@         \                   <   |    h       ABB B(B0A8A@      <      P       ABB B(B0A8A@            ,	       A  $      s       BAA      D  XG        A     d          A       D        A         G        A               A       D        A    $             BAA                                                                                        
            (    2    <    F    P    Z    d    n    x                                                   @             x&    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &     '    '    '    '     '    ('    0'    8'    @'    H'    P'    `(    h(    p(    x(    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (     )                    [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " `#A`1@___stack_chk_guard Qr @___stderrp @dyld_stub_binder        r @___assert_rtn  r(@___error  r0@___stack_chk_fail  r8@_atexit  r@@_atoi  rH@_fclose  rP@_fdopen  rX@_flock  r`@_floor  rh@_fprintf  rp@_free  rx@_fseek  r@_ftell  r@_fwrite  r@_getenv  r@_malloc  r@_memcpy  r@_memset  r@_mkdir  r@_mmap  r@_msync  r@_munmap  r@_open  r@_printf  r@_qsort  r@_realloc  r@_scanf  r@_srand  r@_strdup  r@_strerror  r@_strlen  r@_time     _  _mh_execute_header c n kingdomCards i s d updateCoins play hand buyCard g whoseTurn fullDeckCount e main Random P SelectStream GetSeed TestRandom     ompare ardEffect    ewGame umHandCards      nitializeGame sGameOver    huffle upplyCount coreFor  9  rawCard iscard  C  K  Card A S GreatHall  Q  Card ActionIncrease  W  X      et ainCard  Cost Winners            ndTurn mptyDeck          dventurer mbassador    Card     mithy teward                    lantSeeds utSeed                  P	mP`P	P
H  ` 	 P PP P           d           M   d           X   f W       .  `        $  `        $   P         N  P         .          $          $   P          N  P          .           $           $   @         N  @         .  @        $  @        $            N           .          $          $            N           .  !        $  !        $            N           .  %        $  %        $             N            .  (        $  (        $            N           .  +       $  +        $             N            .  0,       $  0,        $   6         N  6         .  c       $  c        $   p         N  p         .  e     &  $  e        $   P          N  P          .  e     3  $  e        $   p         N  p         .  @m     <  $  @m        $            N           .   p     F  $   p        $   `          N  `          .  p     T  $  p        $   P          N  P          .  p     _  $  p        $            N           .  t     n  $  t        $   p         N  p         .   x     w  $   x        $   P         N  P         .  pz       $  pz        $   0         N  0         .         $          $            N           .          $           $            N           .         $          $             N            .         $          $             N            .          $           $             N            .         $          $            N           .         $          $            N           .         $          $   P          N  P          .         $          $   0         N  0         .       ,  $          $   $         N  $         .        ?  $           $             N         Q  &  @    i  &         &        &        &        &  8      &  H      &  `    
  &  p      &      .  &      @  &       R  &  (     d  &  8     w  &  P       &   !      &  0!      &  !      &  @"      &  $      &  %      &  p&      &  @(    "  &  @1    5  &  1    H  &   2    [  &  2    n  &  `3      &  3      &  3      &  05       d             d             d             f W       .  @       $  @        $            N           .       "  $          $   `         N  `         .  p     6  $  p        $   `         N  `         .       A  $          $   0         N  0         .        J  $           $             N            .        `  $           $            N           .       s  $          $             N           &  5      &  5      &  6      &  6       d             d             d             f 
W       .       '  $          $   p         N  p         .        /  $           $   0         N  0         .  P     ;  $  P        $            N           .  `     I  $  `        $   0         N  0         .       R  $          $   `          N  `          .       [  $          $   P         N  P         .  @     g  $  @        $   P         N  P         .       }  $          $            N           .  @       $  @        $             N           &        &  `7      &  d7      &  p7      &  7      &   8      &  8      &  8      &   9       d          (         P         f         y                                           @                  @         `         P     =    p     V         k                      p                           0    	        	        >	        N	    @    f	         	        	        	        	        	        	    8    	    H    	    `    
    p    #
        5
        G
         Y
    (     k
    8     ~
    P     
     !    
    0!    
    !    
    @"    
    $    
    %        p&        @(    )    @1    <    1    O     2    b    2    u    `3        3        3        05        5        5        6        6        `7        d7         p7    1    7    C     8    U    8    g    8    y     9        p9        x9        9        9        9        9        9        9        9        9        9    1    9    <         E          Q    `     Z         b    P     p         |              c         0,         `                           !         p         t         p         @m         e                       $    +     .    @     >     x     J          X    @     ^         g     p     u                       (                                     pz                  e         %         p                                         (            ;            F            N            T            \            d            k            r            {                                                                                                                                                                                                                                                                                    j  k  l  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~                            m  n       @j  k  l  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~                              /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/ dominion.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/dominion.o _compare _newGame _kingdomCards _initializeGame _shuffle _drawCard _updateCoins _playCard _handCard _cardEffect _buyCard _supplyCount _getCost _gainCard _numHandCards _whoseTurn _fullDeckCount _endTurn _isGameOver _scoreFor _getWinners _playAdventurer _discardCard _playSmithy _playGreatHall _playSteward _playAmbassador ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 cardtest4.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/cardtest4.o _main _handActionIncrease _emptyDeck _discard ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_ctr ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 rngs.c /Users/markdillman/Documents/OSU Program/CS362/projects/dillmanm/dominion/rngs.o _Random _PlantSeeds _SelectStream _PutSeed _GetSeed _TestRandom ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _seed _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_indirect_counter_increment ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init ___llvm_gcov_writeout ___llvm_gcov_flush ___llvm_gcov_init _llvm_gcda_start_file _llvm_gcda_increment_indirect_counter _llvm_gcda_emit_function _llvm_gcda_emit_arcs _llvm_gcda_summary_info _llvm_gcda_end_file _llvm_register_writeout_function _llvm_writeout_files _llvm_delete_writeout_function_list _llvm_register_flush_function ___gcov_flush _llvm_delete_flush_function_list _llvm_gcov_init ___llvm_gcda_edge_table ___llvm_gcda_edge_table20 ___llvm_gcov_global_state_pred ___llvm_gcov_global_state_pred21 _seed _fd ___llvm_gcov_ctr ___llvm_gcov_ctr2 ___llvm_gcov_ctr3 ___llvm_gcov_ctr4 ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 ___llvm_gcov_ctr10 ___llvm_gcov_ctr11 ___llvm_gcov_ctr12 ___llvm_gcov_ctr13 ___llvm_gcov_ctr14 ___llvm_gcov_ctr15 ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 ___llvm_gcov_ctr19 ___llvm_gcov_ctr22 ___llvm_gcov_ctr23 ___llvm_gcov_ctr24 ___llvm_gcov_ctr25 ___llvm_gcov_ctr26 ___llvm_gcov_ctr27 ___llvm_gcov_ctr28 ___llvm_gcov_ctr29 ___llvm_gcov_ctr ___llvm_gcov_ctr16 ___llvm_gcov_ctr17 ___llvm_gcov_ctr18 _stream _initialized ___llvm_gcov_ctr ___llvm_gcov_ctr5 ___llvm_gcov_ctr6 ___llvm_gcov_ctr7 ___llvm_gcov_ctr8 ___llvm_gcov_ctr9 _filename _new_file _output_file _write_buffer _cur_buffer_size _cur_pos _writeout_fn_head _writeout_fn_tail _flush_fn_head _flush_fn_tail _llvm_gcov_init.atexit_ran _file_size _GetSeed _PlantSeeds _PutSeed _Random _SelectStream _TestRandom __mh_execute_header _buyCard _cardEffect _compare _discard _discardCard _drawCard _emptyDeck _endTurn _fullDeckCount _gainCard _getCost _getWinners _handActionIncrease _handCard _initializeGame _isGameOver _kingdomCards _main _newGame _numHandCards _playAdventurer _playAmbassador _playCard _playGreatHall _playSmithy _playSteward _scoreFor _shuffle _supplyCount _updateCoins _whoseTurn ___assert_rtn ___error ___stack_chk_fail ___stack_chk_guard ___stderrp _atexit _atoi _fclose _fdopen _flock _floor _fprintf _free _fseek _ftell _fwrite _getenv _malloc _memcpy _memset _mkdir _mmap _msync _munmap _open _printf _qsort _realloc _scanf _srand _strdup _strerror _strlen _time dyld_stub_binder Test for: buyCard()
===================
	Running test: insufficient coins.
	Test succesful.
	Running test: insufficient buys.
	Test succesful.
	Running test: insufficient supply.
	Test succesful.
numBuys: 2	Test succesful. State coins: 6, Proper coins: 6
	Test succesful. State properly changed to 1.
	Test succesful. Initial buys: 2, Buys after two rounds: 0
All tests succesful!

Test for: isGameOver()
===================
Test routine for : 2 Players
	Test no victory cards:
	Test succesful.
	Test no kingdom cards:
	Test succesful.
	Testing game end after depletion of province pile:
	Test succesful.
	Testing 3 empty kingdom decks: 11, 8, 13	Test succesful.
	Test: Fresh game continuation:
	Test succesful.
	Test: Random nonzero number of provinces (12):
	Test succesful.
	Test: One kingdom pile (7) empty:
	Test succesful.
	Test: Two kingdom pile (7,14) empty:
	Test succesful.
Test routine for : 3 Players
	Test no victory cards:
	Test succesful.
	Test no kingdom cards:
	Test succesful.
	Testing game end after depletion of province pile:
	Test succesful.
	Testing 3 empty kingdom decks: 11, 16, 7	Test succesful.
	Test: Fresh game continuation:
	Test succesful.
	Test: Random nonzero number of provinces (17):
	Test succesful.
	Test: One kingdom pile (7) empty:
	Test succesful.
	Test: Two kingdom pile (7,11) empty:
	Test succesful.
Test routine for : 4 Players
	Test no victory cards:
	Test succesful.
	Test no kingdom cards:
	Test succesful.
	Testing game end after depletion of province pile:
	Test succesful.
	Testing 3 empty kingdom decks: 14, 10, 7	Test succesful.
	Test: Fresh game continuation:
	Test succesful.
	Test: Random nonzero number of provinces (15):
	Test succesful.
	Test: One kingdom pile (15) empty:
	Test succesful.
	Test: Two kingdom pile (15,7) empty:
	Test succesful.
All tests succesful!
Test for: gainCard()
===================
	Testing attempt to gain a depleted card stock:
	Test passed.
	Testing attempt to gain an unused card:
	Test passed.
	Testing: checking proper kingdom card decrement:
	Test passed! Target supply: 9, Supply after gain: 9
	Test passed. Card at hand position 5 has enum 15
	Test passed. Card at deck position 5 has enum 15
	Test passed. Card at discard position 7 has enum 15
All tests passed!

Test for: discardCard()
===================
	Testing discard of last card in hand:
	Test passed. Target:4, Last played card 4
	Testing discard of every card in hand:
		Discarding card at hand index 4
		Discarding card at hand index 3
		Discarding card at hand index 2
		Discarding card at hand index 1
		Discarding card at hand index 0
		Card in played: 4, Target: 4
		Card in played: 4, Target: 4
		Card in played: 1, Target: 1
		Card in played: 4, Target: 4
		Card in played: 1, Target: 1
	Test passed.
	Testing trash discard:
	Test passed. Target hand count: 4, Actual: 4; Target played count: 0, Actual: 0
	Testing that hand is not re-ordered post discard:
	Test passed. Target card: 4, Actual: 4; Order preserved.
All tests passed!

Test for smithy card effect
===================
	Test that hand increase is correct.
	Test passed. Target handcount: 7, Actual: 7
	Test that empty deck will reshuffle for smithy.
	Discard count: 5, Deck count: 0	Test passed. Target handcount: 7, Actual: 7
All tests successful!

Test for adventurer card effect
===================
	Test that Adventurer card discard is correct.
Card drawn: 4
Card drawn: 4
	Test succeeds. Adventurer present in discard.
	Test that Adventurer gets 2 new treasure cards in hand.
7 4 1 4 1 Card drawn: 4
Card drawn: 4
	Test succeeds. Newest cards in hand are treasure.
All tests successful!

Test for great hall card effect
===================
	Test that hand increase is correct.
	Test passed. Target handcount: 5, Actual: 5; target action count = 1, Actual: 1
	Test that empty deck will reshuffle for great hall.
	Discard count: 5, Deck count: 0	Test passed. Target handcount: 5, Actual: 5
	Test that Great Hall card discard is correct.
	Test succeeds. Great hall present in discard.
All tests successful!

